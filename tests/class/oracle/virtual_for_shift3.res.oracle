[kernel] Parsing tests/class/virtual_for_shift3.cc (external front-end)
Now output intermediate result
/* Generated by Frama-C */
struct _frama_c_vmt_content {
   void (*method_ptr)() ;
   int shift_this ;
};
struct _frama_c_rtti_name_info_node;
struct _frama_c_vmt {
   struct _frama_c_vmt_content *table ;
   int table_size ;
   struct _frama_c_rtti_name_info_node *rtti_info ;
};
struct _frama_c_rtti_name_info_content {
   struct _frama_c_rtti_name_info_node *value ;
   int shift_object ;
   int shift_vmt ;
};
struct _frama_c_rtti_name_info_node {
   char const *name ;
   struct _frama_c_rtti_name_info_content *base_classes ;
   int number_of_base_classes ;
   struct _frama_c_vmt *pvmt ;
};
struct A;
struct A {
   struct _frama_c_vmt *pvmt ;
   int _count ;
};
struct B;
struct B {
   struct A _frama_c__Z1A ;
   char _ch ;
};
struct C;
struct C {
   struct B _frama_c__Z1B ;
   double _value ;
};
struct D;
struct D {
   struct C _frama_c__Z1C ;
   struct C _origin ;
};
void A::Ctor(struct A const *this, struct A const *__frama_c_arg_0);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[3];

/*@ requires \valid_read(this); */
void A::Ctor(struct A const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  this->_count = 0;
  return;
}

/*@ requires \valid_read(this); */
void A::Dtor(struct A const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  return;
}

/*@ requires \valid_read(this); */
int getCount(struct A const *this)
{
  int __retres;
  __retres = this->_count;
  return __retres;
}

/*@ requires \valid(this); */
void setCount(struct A *this, int count)
{
  this->_count = count;
  return;
}

/*@ requires \valid(this);
    requires \valid_read(source); */
void assign(struct A *this, struct A const *source)
{
  this->_count = source->_count;
  return;
}

/*@ requires \valid_read(this);
    requires \valid_read(source); */
int compare(struct A const *this, struct A const *source)
{
  int tmp_0;
  if (this->_count < source->_count) tmp_0 = -1;
  else {
    int tmp;
    if (this->_count > source->_count) tmp = 1; else tmp = 0;
    tmp_0 = tmp;
  }
  return tmp_0;
}

/*@ requires \valid(this);
    requires \valid_read(source);
    ensures \valid(\result);
 */
struct A *operator=(struct A *this, struct A const *source)
{
  struct _frama_c_vmt_content *__virtual_tmp_0 =
    (*((struct _frama_c_vmt **)this))->table + 1;
  (*((void (*)(struct A *, struct A const *))__virtual_tmp_0->method_ptr))
  ((struct A *)((char *)this - __virtual_tmp_0->shift_this),source);
  return this;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void A::Ctor(struct A const *this, struct A const *__frama_c_arg_0)
{
  this->pvmt = __frama_c_arg_0->pvmt;
  this->_count = __frama_c_arg_0->_count;
  return;
}

int _frama_c_find_dynamic_cast_aux(struct _frama_c_rtti_name_info_node *target_info,
                                   struct _frama_c_rtti_name_info_content *concrete_base,
                                   int number_of_bases,
                                   int found_shift_object,
                                   int found_shift_vmt, int last_shift_vmt,
                                   int *shift_object, int *distance)
{
  int result = 0;
  struct _frama_c_rtti_name_info_content *cursor = concrete_base;
  int is_over = 0;
  int base_index = 0;
  while (base_index < number_of_bases) {
    if (cursor->value == target_info) {
      if (*distance < 0) goto _LOR;
      else 
        if (*distance >= 1) {
          _LOR:
          {
            if (found_shift_vmt == cursor->shift_vmt) *distance = 0;
            else *distance = 1;
            *shift_object = found_shift_object - cursor->shift_object;
            result = 1;
          }
        }
    }
    else 
      if (cursor->shift_vmt <= found_shift_vmt) {
        int tmp_5;
        if (base_index < number_of_bases - 1) tmp_5 = (cursor + 1)->shift_vmt > found_shift_vmt;
        else {
          int tmp_4;
          if (last_shift_vmt == -1) tmp_4 = 1;
          else 
            if (found_shift_vmt < last_shift_vmt) tmp_4 = 1; else tmp_4 = 0;
          tmp_5 = tmp_4;
        }
        if (tmp_5) {
          int tmp_0;
          int tmp;
          int local_distance = 0;
          int local_shift_object = 0;
          if (base_index < number_of_bases - 1) tmp = (cursor + 1)->shift_vmt;
          else tmp = last_shift_vmt;
          ;
          ;
          ;
          ;
          ;
          tmp_0 = _frama_c_find_dynamic_cast_aux(target_info,
                                                 (cursor->value)->base_classes,
                                                 (cursor->value)->number_of_base_classes,
                                                 found_shift_object - cursor->shift_object,
                                                 found_shift_vmt - cursor->shift_vmt,
                                                 tmp,& local_shift_object,
                                                 & local_distance);
          int local_result = tmp_0;
          if (local_result != 0) 
            if (local_distance >= 0) 
              if (*distance < 0) goto _LOR_0;
              else 
                if (*distance >= local_distance) {
                  _LOR_0:
                  {
                    result = local_result;
                    *shift_object = local_shift_object - cursor->shift_object;
                    *distance = local_distance;
                  }
                }
          is_over = 1;
        }
        else goto _LAND;
      }
      else {
        _LAND: ;
        if (*distance < 0) goto _LOR_2;
        else 
          if (*distance >= 1) {
            _LOR_2:
            {
              int tmp_2;
              int tmp_1;
              int local_distance_0 = 0;
              int local_shift_object_0 = 0;
              if (base_index < number_of_bases + 1) tmp_1 = (cursor + 1)->shift_vmt;
              else tmp_1 = last_shift_vmt;
              ;
              ;
              ;
              ;
              ;
              tmp_2 = _frama_c_find_dynamic_cast_aux(target_info,
                                                     (cursor->value)->base_classes,
                                                     (cursor->value)->number_of_base_classes,
                                                     found_shift_object - cursor->shift_object,
                                                     found_shift_vmt - cursor->shift_vmt,
                                                     tmp_1,
                                                     & local_shift_object_0,
                                                     & local_distance_0);
              int local_result_0 = tmp_2;
              if (local_result_0 != 0) 
                if (local_distance_0 >= 0) 
                  if (*distance < 0) goto _LOR_1;
                  else {
                    int tmp_3;
                    if (is_over == 0) tmp_3 = local_distance_0;
                    else tmp_3 = local_distance_0 + 1;
                    ;
                    if (*distance > tmp_3) {
                      _LOR_1:
                      {
                        result = local_result_0;
                        *shift_object = local_shift_object_0 - cursor->shift_object;
                        *distance = local_distance_0 + 1;
                      }
                    }
                  }
            }
          }
      }
    cursor ++;
    base_index ++;
  }
  return result;
}

int _frama_c_find_dynamic_cast(struct _frama_c_rtti_name_info_node *declared_info,
                               struct _frama_c_vmt *declared_vmt,
                               struct _frama_c_rtti_name_info_node *target_info,
                               int *shift_object)
{
  int __retres;
  int shift_vmt;
  int elaborated_shift_target;
  struct _frama_c_rtti_name_info_content *cursor;
  int number_of_bases;
  int tmp_0;
  struct _frama_c_rtti_name_info_node *concrete_info =
    declared_vmt->rtti_info;
  int elaborated_shift_vmt = 0;
  int elaborated_shift_object = 0;
  int cursor_index = 0;
  int distance = -1;
  if (concrete_info->pvmt > declared_vmt) {
    __retres = 0;
    goto return_label;
  }
  else 
    if (declared_vmt > concrete_info->pvmt + declared_vmt->table_size) {
      __retres = 0;
      goto return_label;
    }
  shift_vmt = declared_vmt - concrete_info->pvmt;
  if (concrete_info == declared_info) {
    *shift_object = 0;
    __retres = target_info == declared_info;
    goto return_label;
  }
  if (target_info == concrete_info) elaborated_shift_target = 0;
  else elaborated_shift_target = -1;
  cursor = concrete_info->base_classes;
  number_of_bases = concrete_info->number_of_base_classes;
  while (1) {
    while (1) {
      if (cursor_index < number_of_bases) {
        if (! (elaborated_shift_vmt + cursor->shift_vmt < shift_vmt)) 
          break;
      }
      else break;
      {
        struct _frama_c_rtti_name_info_content *tmp;
        if (cursor_index < number_of_bases - 1) tmp = cursor + 1;
        else tmp = (struct _frama_c_rtti_name_info_content *)0;
        struct _frama_c_rtti_name_info_content *next_cursor = tmp;
        if (next_cursor != (struct _frama_c_rtti_name_info_content *)0) 
          if (elaborated_shift_vmt + next_cursor->shift_vmt <= shift_vmt) {
            cursor = next_cursor;
            cursor_index ++;
          }
          else break;
        else break;
      }
    }
    if (cursor_index < number_of_bases) {
      elaborated_shift_vmt += cursor->shift_vmt;
      elaborated_shift_object += cursor->shift_object;
      if (cursor->value == target_info) elaborated_shift_target = elaborated_shift_object;
      if (elaborated_shift_vmt == shift_vmt) 
        if (cursor->value == declared_info) {
          if (elaborated_shift_target >= 0) {
            *shift_object = elaborated_shift_target - elaborated_shift_object;
            __retres = 1;
            goto return_label;
          }
          break;
        }
      cursor = (cursor->value)->base_classes;
      number_of_bases = (cursor->value)->number_of_base_classes;
      cursor_index = 0;
    }
    if (! (cursor_index < number_of_bases)) break;
  }
  if (cursor_index >= number_of_bases) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = _frama_c_find_dynamic_cast_aux(target_info,
                                         concrete_info->base_classes,
                                         concrete_info->number_of_base_classes,
                                         elaborated_shift_object,shift_vmt,
                                         -1,shift_object,& distance);
  __retres = tmp_0;
  return_label: return __retres;
}

struct _frama_c_vmt_content _frama_c_vmt[3] =
  {{.method_ptr = (void (*)())(& A::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& assign), .shift_this = 0},
   {.method_ptr = (void (*)())(& compare), .shift_this = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "A",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 3,
   .rtti_info = & _frama_c_rtti_name_info};
void B::Ctor(struct B const *this, struct B const *__frama_c_arg_0);

void B::Dtor(struct B const *this);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];

struct _frama_c_vmt_content _frama_c_vmt[3];

/*@ requires \valid_read(this); */
void B::Ctor(struct B const *this)
{
  A::Ctor(& this->_frama_c__Z1A);
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  this->_ch = (char)97;
  setCount((struct A *)(& this->_frama_c__Z1A),42);
  return;
}

/*@ requires \valid(this);
    requires \valid_read(source); */
void assign(struct B *this, struct A const *source)
{
  assign(& this->_frama_c__Z1A,source);
  struct B *__cast_tmp_0 = (struct B *)0;
  this->_ch = ((struct B const *)((char *)source + ((char *)__cast_tmp_0 - (char *)(& __cast_tmp_0->_frama_c__Z1A))))->_ch;
  return;
}

/*@ requires \valid(this);
    requires \valid_read(source);
    ensures \valid(\result);
 */
struct B *operator=(struct B *this, struct B const *source)
{
  struct _frama_c_vmt_content *__virtual_tmp_1 =
    (*((struct _frama_c_vmt **)this))->table + 1;
  (*((void (*)(struct B *, struct A const *))__virtual_tmp_1->method_ptr))
  ((struct B *)((char *)this - __virtual_tmp_1->shift_this),
   & source->_frama_c__Z1A);
  return this;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void B::Ctor(struct B const *this, struct B const *__frama_c_arg_0)
{
  A::Ctor(& this->_frama_c__Z1A,& __frama_c_arg_0->_frama_c__Z1A);
  this->_ch = __frama_c_arg_0->_ch;
  return;
}

/*@ requires \valid_read(this); */
void B::Dtor(struct B const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  A::Dtor(& this->_frama_c__Z1A);
  return;
}

struct _frama_c_vmt_content _frama_c_vmt[3] =
  {{.method_ptr = (void (*)())(& B::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& assign), .shift_this = 0},
   {.method_ptr = (void (*)())(& compare),
    .shift_this = (char *)(& ((struct B *)0)->_frama_c__Z1A) - (char *)(& ((struct B *)0)->_frama_c__Z1A)}};
struct _frama_c_rtti_name_info_content _frama_c_base_classes[1] =
  {{.value = & _frama_c_rtti_name_info,
    .shift_object = (char *)0 - (char *)(& ((struct B *)0)->_frama_c__Z1A),
    .shift_vmt = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "B",
   .base_classes = _frama_c_base_classes,
   .number_of_base_classes = 1,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 3,
   .rtti_info = & _frama_c_rtti_name_info};
void C::Dtor(struct C const *this);

void C::Ctor(struct C const *this, struct C const *__frama_c_arg_0);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];

struct _frama_c_vmt_content _frama_c_vmt[3];

/*@ requires \valid_read(this); */
void C::Ctor(struct C const *this)
{
  B::Ctor(& this->_frama_c__Z1B);
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  this->_value = 1.0;
  setCount(& ((struct B *)(& this->_frama_c__Z1B))->_frama_c__Z1A,21);
  return;
}

/*@ requires \valid(this);
    requires \valid_read(source); */
void assign(struct C *this, struct A const *source)
{
  assign(& this->_frama_c__Z1B._frama_c__Z1A,source);
  struct B *__cast_tmp_1 = (struct B *)0;
  struct C *__cast_tmp_2 = (struct C *)0;
  this->_value = ((struct C const *)(((char *)source + ((char *)__cast_tmp_1 - (char *)(& __cast_tmp_1->_frama_c__Z1A))) + (
                                     (char *)__cast_tmp_2 - (char *)(& __cast_tmp_2->_frama_c__Z1B))))->_value;
  return;
}

/*@ requires \valid(this);
    requires \valid_read(source);
    ensures \valid(\result);
 */
struct C *operator=(struct C *this, struct C const *source)
{
  struct _frama_c_vmt_content *__virtual_tmp_2 =
    (*((struct _frama_c_vmt **)this))->table + 1;
  (*((void (*)(struct C *, struct A const *))__virtual_tmp_2->method_ptr))
  ((struct C *)((char *)this - __virtual_tmp_2->shift_this),
   (struct A const *)(& ((struct B *)(& source->_frama_c__Z1B))->_frama_c__Z1A));
  return this;
}

/*@ requires \valid_read(this); */
void C::Dtor(struct C const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  B::Dtor(& this->_frama_c__Z1B);
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void C::Ctor(struct C const *this, struct C const *__frama_c_arg_0)
{
  B::Ctor(& this->_frama_c__Z1B,& __frama_c_arg_0->_frama_c__Z1B);
  this->_value = __frama_c_arg_0->_value;
  return;
}

struct _frama_c_vmt_content _frama_c_vmt[3] =
  {{.method_ptr = (void (*)())(& C::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& assign), .shift_this = 0},
   {.method_ptr = (void (*)())(& compare),
    .shift_this = (char *)(& ((struct C *)0)->_frama_c__Z1B._frama_c__Z1A) - (char *)(& ((struct C *)0)->_frama_c__Z1B._frama_c__Z1A)}};
struct _frama_c_rtti_name_info_content _frama_c_base_classes[1] =
  {{.value = & _frama_c_rtti_name_info,
    .shift_object = (char *)0 - (char *)(& ((struct C *)0)->_frama_c__Z1B),
    .shift_vmt = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "C",
   .base_classes = _frama_c_base_classes,
   .number_of_base_classes = 1,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 3,
   .rtti_info = & _frama_c_rtti_name_info};
void D::Dtor(struct D const *this);

void D::Ctor(struct D const *this, struct D const *__frama_c_arg_0);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];

struct _frama_c_vmt_content _frama_c_vmt[3];

/*@ requires \valid_read(this); */
void D::Ctor(struct D const *this)
{
  C::Ctor(& this->_frama_c__Z1C);
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  C::Ctor(& this->_origin);
  return;
}

/*@ requires \valid(this);
    requires \valid_read(source); */
void assign(struct D *this, struct A const *source)
{
  struct C *tmp;
  assign(& this->_frama_c__Z1C,source);
  struct B *__cast_tmp_3 = (struct B *)0;
  struct C *__cast_tmp_4 = (struct C *)0;
  struct D *__cast_tmp_5 = (struct D *)0;
  tmp = operator=(& this->_origin,
                  & ((struct D const *)((((char *)source + ((char *)__cast_tmp_3 - (char *)(& __cast_tmp_3->_frama_c__Z1A))) + (
                                         (char *)__cast_tmp_4 - (char *)(& __cast_tmp_4->_frama_c__Z1B))) + (
                                        (char *)__cast_tmp_5 - (char *)(& __cast_tmp_5->_frama_c__Z1C))))->_origin);
  return;
}

/*@ requires \valid(this);
    requires \valid_read(source);
    ensures \valid(\result);
 */
struct D *operator=(struct D *this, struct D const *source)
{
  struct _frama_c_vmt_content *__virtual_tmp_3 =
    (*((struct _frama_c_vmt **)this))->table + 1;
  (*((void (*)(struct D *, struct A const *))__virtual_tmp_3->method_ptr))
  ((struct D *)((char *)this - __virtual_tmp_3->shift_this),
   (struct A const *)(& ((struct C *)(& source->_frama_c__Z1C))->_frama_c__Z1B._frama_c__Z1A));
  return this;
}

/*@ requires \valid_read(this); */
void D::Dtor(struct D const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  C::Dtor(& this->_frama_c__Z1C);
  C::Dtor(& this->_origin);
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void D::Ctor(struct D const *this, struct D const *__frama_c_arg_0)
{
  C::Ctor(& this->_frama_c__Z1C,& __frama_c_arg_0->_frama_c__Z1C);
  C::Ctor(& this->_origin,& __frama_c_arg_0->_origin);
  return;
}

struct _frama_c_vmt_content _frama_c_vmt[3] =
  {{.method_ptr = (void (*)())(& D::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& assign), .shift_this = 0},
   {.method_ptr = (void (*)())(& compare),
    .shift_this = (char *)(& ((struct D *)0)->_frama_c__Z1C._frama_c__Z1B._frama_c__Z1A) - (char *)(& ((struct D *)0)->_frama_c__Z1C._frama_c__Z1B._frama_c__Z1A)}};
struct _frama_c_rtti_name_info_content _frama_c_base_classes[1] =
  {{.value = & _frama_c_rtti_name_info,
    .shift_object = (char *)0 - (char *)(& ((struct D *)0)->_frama_c__Z1C),
    .shift_vmt = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "D",
   .base_classes = _frama_c_base_classes,
   .number_of_base_classes = 1,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 3,
   .rtti_info = & _frama_c_rtti_name_info};
int main(void)
{
  struct D *tmp;
  int tmp_0;
  struct D d1;
  D::Ctor(& d1);
  struct D d2;
  D::Ctor(& d2);
  tmp = operator=(& d1,(struct D const *)(& d2));
  struct _frama_c_vmt_content *__virtual_tmp_4 =
    (*((struct _frama_c_vmt **)(& d1._frama_c__Z1C._frama_c__Z1B._frama_c__Z1A)))->table + 2;
  tmp_0 = (*((int (*)(struct A *, struct A const *))__virtual_tmp_4->method_ptr))
  ((struct A *)((char *)(& d1._frama_c__Z1C._frama_c__Z1B._frama_c__Z1A) - __virtual_tmp_4->shift_this),
   (struct A const *)(& d2._frama_c__Z1C._frama_c__Z1B._frama_c__Z1A));
  D::Dtor((struct D const *)(& d2));
  D::Dtor((struct D const *)(& d1));
  return tmp_0;
}


