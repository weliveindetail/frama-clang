[kernel] Parsing tests/stl/stl_algorithm.cpp (external front-end)
Now output intermediate result
[kernel] Warning: Assuming declared function exception::Dtor can't throw any exception
[kernel] Warning: Assuming declared function exception::Dtor can't throw any exception
[kernel] Warning: Assuming declared function exception::Dtor can't throw any exception
[kernel] Warning: Assuming declared function exception::Ctor can't throw any exception
[kernel] Warning: Assuming declared function exception::Dtor can't throw any exception
[kernel] Warning: Assuming declared function initializer_list<int>::Ctor can't throw any exception
[kernel] Warning: Assuming declared function initializer_list<int>::Ctor can't throw any exception
[kernel] Warning: Assuming declared function initializer_list<int>::Ctor can't throw any exception
/* Generated by Frama-C */
struct _frama_c_vmt_content {
   void (*method_ptr)() ;
   int shift_this ;
};
struct _frama_c_rtti_name_info_node;
struct _frama_c_vmt {
   struct _frama_c_vmt_content *table ;
   int table_size ;
   struct _frama_c_rtti_name_info_node *rtti_info ;
};
struct _frama_c_rtti_name_info_content {
   struct _frama_c_rtti_name_info_node *value ;
   int shift_object ;
   int shift_vmt ;
};
struct _frama_c_rtti_name_info_node {
   char const *name ;
   struct _frama_c_rtti_name_info_content *base_classes ;
   int number_of_base_classes ;
   struct _frama_c_vmt *pvmt ;
};
typedef int ptrdiff_t;
typedef unsigned int size_t;
typedef size_t size_t;
typedef ptrdiff_t ptrdiff_t;
typedef int const *iterator;
struct initializer_list<int> {
   int const *base ;
   size_t length ;
};
typedef _Bool value_type;
struct integral_constant<bool,0>;
struct integral_constant<bool,0> {
   
};
typedef _Bool value_type;
struct integral_constant<bool,1>;
struct integral_constant<bool,1> {
   
};
typedef int *type;
typedef type *type;
typedef int *type;
typedef type *type;
typedef int *type;
typedef type *type;
typedef int type;
typedef void (*type)(int );
struct piecewise_construct_t;
struct piecewise_construct_t {
   
};
struct pair<int*,int*> {
   int *first ;
   int *second ;
};
struct exception;
struct bad_exception;
struct nested_exception;
struct exception {
   struct _frama_c_vmt *pvmt ;
};
struct bad_exception {
   struct exception _frama_c__ZN3stdE9exception ;
};
typedef void *exception_ptr;
struct nested_exception {
   struct _frama_c_vmt *pvmt ;
};
struct type_info;
struct bad_cast;
struct bad_typeid;
struct type_info {
   struct _frama_c_vmt *pvmt ;
};
struct bad_cast {
   struct exception _frama_c__ZN3stdE9exception ;
};
struct bad_typeid {
   struct exception _frama_c__ZN3stdE9exception ;
};
typedef _Bool (*type)(int );
typedef int argument_type;
struct reference_wrapper<bool*,<abst>> {
   _Bool (*obj)(int ) ;
};
typedef _Bool (*type)(int );
typedef int argument_type;
struct reference_wrapper<bool&,<abst>> {
   _Bool (*obj)(int ) ;
};
typedef _Bool (*__funtype)(int const *, int const *);
struct __bool_binop<int,std::__less> {
   
};
typedef _Bool (*__funtype)(int const *, int const *);
struct __bool_binop<int,std::__equal_to> {
   
};
struct equal_to<int> {
   struct __bool_binop<int,std::__equal_to> _frama_c__ZN3stdE12__bool_binopIiN3stdE10__equal_toE ;
};
struct less<int> {
   struct __bool_binop<int,std::__less> _frama_c__ZN3stdE12__bool_binopIiN3stdE6__lessE ;
};
struct unary_negate<bool*,<abst>> {
   _Bool (* const *__predicate)(int ) ;
};
struct unary_negate<std::reference_wrapper<bool&,<abst>>> {
   struct reference_wrapper<bool&,<abst>> const *__predicate ;
};
struct bad_function_call;
struct bad_function_call {
   struct exception _frama_c__ZN3stdE9exception ;
};
typedef ptrdiff_t difference_type;
typedef int value_type;
struct reverse_iterator<int*>;
struct reverse_iterator<int*>;
struct UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE_;
struct UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE_ {
   _Bool (*__fc_lambda_apply)(struct UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE_ const *,
                              value_type ) ;
   struct equal_to<int> pred ;
   int *it1 ;
};
typedef int *reference;
typedef int const *const_reference;
typedef int *iterator;
typedef int const *const_iterator;
typedef size_t size_type;
typedef struct reverse_iterator<int*> reverse_iterator;
typedef struct reverse_iterator<int*> const_reverse_iterator;
struct array<int,5> {
   int elems[5] ;
};
typedef int *reference;
typedef int const *const_reference;
typedef int *iterator;
typedef int const *const_iterator;
typedef size_t size_type;
typedef struct reverse_iterator<int*> reverse_iterator;
typedef struct reverse_iterator<int*> const_reverse_iterator;
struct array<int,2> {
   int elems[2] ;
};
void initializer_list<int>::Dtor(struct initializer_list<int> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void initializer_list<int>::Ctor(struct initializer_list<int> const *this)
{
  this->base = (int const *)0;
  this->length = (unsigned int)0;
  return;
}

/*@ requires \valid_read(this); */
void initializer_list<int>::Ctor(struct initializer_list<int> const *this,
                                 int const *b, size_t s);

/*@ requires \valid_read(this); */
size_t size(struct initializer_list<int> const *this)
{
  size_t __retres;
  __retres = this->length;
  return __retres;
}

/*@ requires \valid_read(this); */
int const *begin(struct initializer_list<int> const *this)
{
  int const *__retres;
  __retres = this->base;
  return __retres;
}

/*@ requires \valid_read(this); */
int const *end(struct initializer_list<int> const *this);

/*@ requires \valid_read(this); */
void initializer_list<int>::Dtor(struct initializer_list<int> const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "initializer_list",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
value_type value_type)(struct integral_constant<bool,0> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "integral_constant",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
value_type value_type)(struct integral_constant<bool,1> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "integral_constant",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__boolean",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__boolean",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__and",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "_is_void",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "add_rvalue_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "add_rvalue_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "add_rvalue_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ ensures \valid(\result); */
type declval<int*&>(void);

/*@ ensures \valid(\result); */
type declval<int*&&>(void);

/*@ ensures \valid(\result); */
type declval<int*&>(void);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "ok_type",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "ko_type",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_constructible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_constructible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_constructible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_copy_constructible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_assignable",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_assignable",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_copy_assignable",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_move_assignable",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_nothrow_constructible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_convertible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_convertible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "enable_if",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@ requires \valid(t);
    ensures \valid(\result); */
int **forward<int*&>(type *t)
{
  return t;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
type *move<int&>(int *t)
{
  return t;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
type *move<void*&,<abst>>(void (**t)(int ))
{
  return t;
}

void piecewise_construct_t::Ctor(struct piecewise_construct_t const *this);

void piecewise_construct_t::Dtor(struct piecewise_construct_t const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void piecewise_construct_t::Ctor(struct piecewise_construct_t const *this)
{
  return;
}

/*@ requires \valid_read(this); */
void piecewise_construct_t::Dtor(struct piecewise_construct_t const *this)
{
  return;
}

struct piecewise_construct_t piecewise_construct;
void __fc_init_ZN3stdE19piecewise_construct(void) __attribute__((__constructor__));
void __fc_init_ZN3stdE19piecewise_construct(void)
{
  struct piecewise_construct_t __fc_tmp_0;
  piecewise_construct_t::Ctor(& __fc_tmp_0);
  piecewise_construct = __fc_tmp_0;
  piecewise_construct_t::Dtor((struct piecewise_construct_t const *)(& __fc_tmp_0));
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "piecewise_construct_t",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void pair<int*,int*>::Dtor(struct pair<int*,int*> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this);
    requires \valid_read(y);
    requires \valid_read(x);
 */
void pair<int*,int*>::Ctor(struct pair<int*,int*> const *this,
                           int * const *x, int * const *y)
{
  this->first = *x;
  this->second = *y;
  return;
}

/*@ requires \valid(this);
    requires \valid(p); */
void swap(struct pair<int*,int*> *this, struct pair<int*,int*> *p);

/*@ requires \valid_read(this); */
void pair<int*,int*>::Dtor(struct pair<int*,int*> const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "pair",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@ requires \valid(y);
    requires \valid(x); */
struct pair<int*,int*> make_pair<int*&,int*&>(int **x, int **y)
{
  int **tmp;
  int **tmp_0;
  tmp = forward<int*&>(y);
  tmp_0 = forward<int*&>(x);
  struct pair<int*,int*> __fc_tmp_1;
  pair<int*,int*>::Ctor(& __fc_tmp_1,(int * const *)tmp_0,(int * const *)tmp);
  return __fc_tmp_1;
}

/*@
axiomatic MemCmp {
  logic ℤ memcmp{L1, L2}(char *s1, char *s2, ℤ n) 
    reads \at(*(s1 + (0 .. n - 1)),L1), \at(*(s2 + (0 .. n - 1)),L2);
  
  axiom memcmp_zero{L1, L2}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L1, L2}(s1, s2, n) ≡ 0 ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ \at(*(s1 + i),L1) ≡ \at(*(s2 + i),L2));
  
  }
 */
/*@
axiomatic MemChr {
  logic 𝔹 memchr{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  logic ℤ memchr_off{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memchr(s, c, n) ≢ (0 ≢ 0) ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic MemSet {
  logic 𝔹 memset{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memset_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memset(s, c, n) ≢ (0 ≢ 0) ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic StrLen {
  logic ℤ strlen{L}(char *s) 
    reads *(s + (0 ..));
  
  axiom strlen_pos_or_null{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ (char)0) ∧
      *(s + i) ≡ (char)0 ⇒ strlen(s) ≡ i;
  
  axiom strlen_neg{L}:
    ∀ char *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ (char)0) ⇒ strlen(s) < 0;
  
  axiom strlen_before_null{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i < strlen(s) ⇒ *(s + i) ≢ (char)0;
  
  axiom strlen_at_null{L}:
    ∀ char *s; 0 ≤ strlen(s) ⇒ *(s + strlen(s)) ≡ (char)0;
  
  axiom strlen_not_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≢ (char)0 ⇒ i < strlen(s);
  
  axiom strlen_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ (char)0 ⇒ i ≡ strlen(s);
  
  axiom strlen_sup{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ (char)0 ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_shift{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ≤ strlen(s) ⇒ strlen(s + i) ≡ strlen(s) - i;
  
  axiom strlen_create{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ (char)0 ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_create_shift{L}:
    ∀ char *s;
    ∀ ℤ i;
    ∀ ℤ k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ (char)0 ⇒
      0 ≤ strlen(s + k) ≤ i - k;
  
  axiom memcmp_strlen_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s1) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s2) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_shift_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1, s2 + k, n) ≡ 0 ≤ k ∧ strlen(s1) < n ⇒
      0 ≤ strlen(s2) ≤ k + strlen(s1);
  
  axiom memcmp_strlen_shift_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1 + k, s2, n) ≡ 0 ≤ k ∧ strlen(s2) < n ⇒
      0 ≤ strlen(s1) ≤ k + strlen(s2);
  
  }
 */
/*@
axiomatic StrCmp {
  logic ℤ strcmp{L}(char *s1, char *s2) 
    reads *(s1 + (0 .. strlen(s1))), *(s2 + (0 .. strlen(s2)));
  
  axiom strcmp_zero{L}:
    ∀ char *s1, char *s2;
      strcmp(s1, s2) ≡ 0 ⇔
      strlen(s1) ≡ strlen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ strlen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrNCmp {
  logic ℤ strncmp{L}(char *s1, char *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom strncmp_zero{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      strncmp(s1, s2, n) ≡ 0 ⇔
      (strlen(s1) < n ∧ strcmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrChr {
  logic 𝔹 strchr{L}(char *s, ℤ c) 
    reads *(s + (0 .. strlen(s)));
  
  axiom strchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
      strchr(s, c) ≢ (0 ≢ 0) ⇔
      (∃ ℤ i; 0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ (char)((int)c));
  
  }
 */
/*@
axiomatic WMemChr {
  logic 𝔹 wmemchr{L}(int *s, int c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  logic ℤ wmemchr_off{L}(int *s, int c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom wmemchr_def{L}:
    ∀ int *s;
    ∀ int c;
    ∀ ℤ n;
      wmemchr(s, c, n) ≢ (0 ≢ 0) ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic WcsLen {
  logic ℤ wcslen{L}(int *s) 
    reads *(s + (0 ..));
  
  axiom wcslen_pos_or_null{L}:
    ∀ int *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ (int)0) ∧
      *(s + i) ≡ (int)0 ⇒ wcslen(s) ≡ i;
  
  axiom wcslen_neg{L}:
    ∀ int *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ (int)0) ⇒ wcslen(s) < 0;
  
  axiom wcslen_before_null{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i < wcslen(s) ⇒ *(s + i) ≢ (int)0;
  
  axiom wcslen_at_null{L}:
    ∀ int *s; 0 ≤ wcslen(s) ⇒ *(s + wcslen(s)) ≡ (int)0;
  
  axiom wcslen_not_zero{L}:
    ∀ int *s;
    ∀ int i;
      0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≢ (int)0 ⇒ i < wcslen(s);
  
  axiom wcslen_zero{L}:
    ∀ int *s;
    ∀ int i;
      0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≡ (int)0 ⇒ i ≡ wcslen(s);
  
  axiom wcslen_sup{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ (int)0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_shift{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ⇒ wcslen(s + i) ≡ wcslen(s) - i;
  
  axiom wcslen_create{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ (int)0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_create_shift{L}:
    ∀ int *s;
    ∀ int i;
    ∀ int k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ (int)0 ⇒ 0 ≤ wcslen(s + k) ≤ i - k;
  
  }
 */
/*@
axiomatic WcsCmp {
  logic ℤ wcscmp{L}(int *s1, int *s2) 
    reads *(s1 + (0 .. wcslen(s1))), *(s2 + (0 .. wcslen(s2)));
  
  axiom wcscmp_zero{L}:
    ∀ int *s1, int *s2;
      wcscmp(s1, s2) ≡ 0 ⇔
      wcslen(s1) ≡ wcslen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ wcslen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsNCmp {
  logic ℤ wcsncmp{L}(int *s1, int *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom wcsncmp_zero{L}:
    ∀ int *s1, int *s2;
    ∀ ℤ n;
      wcsncmp(s1, s2, n) ≡ 0 ⇔
      (wcslen(s1) < n ∧ wcscmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsChr {
  logic 𝔹 wcschr{L}(int *wcs, ℤ wc) 
    reads *(wcs + (0 .. wcslen(wcs)));
  
  axiom wcschr_def{L}:
    ∀ int *wcs;
    ∀ ℤ wc;
      wcschr(wcs, wc) ≢ (0 ≢ 0) ⇔
      (∃ ℤ i; 0 ≤ i ≤ wcslen(wcs) ∧ *(wcs + i) ≡ (int)((int)wc));
  
  }
 */
/*@ logic ℤ minimum(ℤ i, ℤ j) = i < j? i: j;
 */
/*@ logic ℤ maximum(ℤ i, ℤ j) = i < j? j: i;
 */
/*@
predicate valid_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid_read(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_nstring{L}(char *s, ℤ n) =
  (\valid_read(s + (0 .. n - 1)) ∧ \initialized(s + (0 .. n - 1))) ∨
  valid_read_string(s);
 */
/*@
predicate valid_string_or_null{L}(char *s) = s ≡ \null ∨ valid_string(s);
 */
/*@
predicate valid_wstring{L}(int *s) =
  0 ≤ wcslen(s) ∧ \valid(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_read_wstring{L}(int *s) =
  0 ≤ wcslen(s) ∧ \valid_read(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_read_nwstring{L}(int *s, ℤ n) =
  (\valid_read(s + (0 .. n - 1)) ∧ \initialized(s + (0 .. n - 1))) ∨
  valid_read_wstring(s);
 */
/*@
predicate valid_wstring_or_null{L}(int *s) =
  s ≡ \null ∨ valid_wstring(s);
 */
/*@ ghost int __fc_heap_status; */
/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(ℤ n) 
    reads __fc_heap_status;
  
  axiom never_allocable{L}:
    ∀ ℤ i; i < 0 ∨ i > 4294967295U ⇒ ¬is_allocable(i);
  
  }
 */
/*@
predicate non_escaping{L}(void *s, ℤ n) =
  ∀ ℤ i; 0 ≤ i < n ⇒ ¬\initialized((char *)s + i);
 */
/*@
predicate empty_block{L}(void *s) =
  \block_length((char *)s) ≡ 0 ∧ \offset((char *)s) ≡ 0;
 */
/*@
predicate valid_or_empty{L}(void *s, size_t n) =
  (empty_block(s) ∨ \valid_read((char *)s)) ∧
  \valid((char *)s + (0 .. n - 1));
 */
/*@
predicate valid_read_or_empty{L}(void *s, size_t n) =
  (empty_block(s) ∨ \valid_read((char *)s)) ∧
  \valid_read((char *)s + (1 .. n - 1));

*/
/*@ requires valid_s1: valid_read_or_empty(s1, n);
    requires valid_s2: valid_read_or_empty(s2, n);
    requires s1: initialization: \initialized((char *)s1 + (0 .. n - 1));
    requires s2: initialization: \initialized((char *)s2 + (0 .. n - 1));
    requires s1: danglingness: non_escaping(s1, n);
    requires s2: danglingness: non_escaping(s2, n);
    ensures
      logic_spec:
        \result ≡
        memcmp{Pre, Pre}((char *)\old(s1), (char *)\old(s2), \old(n));
    assigns \result;
    assigns \result
      \from (indirect: *((char *)s1 + (0 .. n - 1))),
            (indirect: *((char *)s2 + (0 .. n - 1)));
 */
int memcmp(void const *s1, void const *s2, size_t n);

/*@ requires
      valid:
        valid_read_or_empty(s, n) ∨
        \valid_read((unsigned char *)s + (0 .. memchr_off((char *)s, c, n)));
    requires
      initialization:
        \initialized((unsigned char *)s + (0 .. n - 1)) ∨
        \initialized((unsigned char *)s + (0 .. memchr_off((char *)s, c, n)));
    requires
      danglingness:
        non_escaping(s, n) ∨
        non_escaping(s, (size_t)((int)(memchr_off((char *)s, c, n) + 1)));
    assigns \result;
    assigns \result \from s, c, *((unsigned char *)s + (0 .. n - 1));
    
    behavior found:
      assumes char_found: memchr((char *)s, c, n) ≢ (0 ≢ 0);
      ensures result_same_base: \base_addr(\result) ≡ \base_addr(\old(s));
      ensures result_char: (int)*((char *)\result) ≡ \old(c);
      ensures
        result_in_str:
          ∀ ℤ i;
            (0 ≤ i < \old(n) ⇒
             *((unsigned char *)\old(s) + i) ≡ \old(c)) ⇒
            (unsigned char *)\result ≤ (unsigned char *)\old(s) + i;
    
    behavior not_found:
      assumes char_not_found: memchr((char *)s, c, n) ≡ (0 ≢ 0);
      ensures result_null: \result ≡ \null;
 */
void *memchr(void const *s, int c, size_t n);

/*@ requires valid_dest: valid_or_empty(dest, n);
    requires valid_src: valid_read_or_empty(src, n);
    requires
      separation:
        \separated((char *)dest + (0 .. n - 1), (char *)src + (0 .. n - 1));
    ensures
      copied_contents:
        memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡
        0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
void *memcpy(void * restrict dest, void const * restrict src, size_t n);

/*@ requires valid_dest: valid_or_empty(dest, n);
    requires valid_src: valid_read_or_empty(src, n);
    ensures
      copied_contents:
        memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡
        0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
void *memmove(void *dest, void const *src, size_t n);

/*@ requires valid_s: valid_or_empty(s, n);
    ensures
      acsl_c_equiv: memset((char *)\old(s), \old(c), \old(n)) ≢ (0 ≢ 0);
    ensures result_ptr: \result ≡ \old(s);
    assigns *((char *)s + (0 .. n - 1)), \result;
    assigns *((char *)s + (0 .. n - 1)) \from c;
    assigns \result \from s;
 */
void *memset(void *s, int c, size_t n);

/*@ requires valid_string_s: valid_read_string(s);
    ensures acsl_c_equiv: \result ≡ strlen(\old(s));
    assigns \result;
    assigns \result \from (indirect: *(s + (0 ..)));
 */
size_t strlen(char const *s);

/*@ requires valid_string_s: valid_read_nstring(s, n);
    ensures
      result_bounded: \result ≡ strlen(\old(s)) ∨ \result ≡ \old(n);
    assigns \result;
    assigns \result \from (indirect: *(s + (0 .. n - 1))), (indirect: n);
 */
size_t strnlen(char const *s, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    ensures acsl_c_equiv: \result ≡ strcmp(\old(s1), \old(s2));
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
int strcmp(char const *s1, char const *s2);

/*@ requires valid_string_s1: valid_read_nstring(s1, n);
    requires valid_string_s2: valid_read_nstring(s2, n);
    ensures acsl_c_equiv: \result ≡ strncmp(\old(s1), \old(s2), \old(n));
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
int strncmp(char const *s1, char const *s2, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
int strcoll(char const *s1, char const *s2);

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result
      \from s, (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: c);
    
    behavior found:
      assumes char_found: strchr(s, c) ≢ (0 ≢ 0);
      ensures result_char: *\result ≡ (char)\old(c);
      ensures result_same_base: \base_addr(\result) ≡ \base_addr(\old(s));
      ensures
        result_in_length: \old(s) ≤ \result ≤ \old(s) + strlen(\old(s));
      ensures result_valid_string: valid_read_string(\result);
      ensures
        result_first_occur:
          ∀ char *p; \old(s) ≤ p < \result ⇒ *p ≢ (char)\old(c);
    
    behavior not_found:
      assumes char_not_found: strchr(s, c) ≡ (0 ≢ 0);
      ensures result_null: \result ≡ \null;
    
    behavior default:
      ensures
        result_null_or_same_base:
          \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
char *strchr(char const *s, int c);

/*@ requires valid_string_s: valid_read_string(s);
    ensures
      result_same_base: \subset(\result, \old(s) + (0 .. strlen(\old(s))));
    assigns \result;
    assigns \result
      \from s, (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: c);
 */
char *strchrnul(char const *s, int c);

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), c;
    
    behavior found:
      assumes char_found: strchr(s, c) ≢ (0 ≢ 0);
      ensures result_char: (int)*\result ≡ \old(c);
      ensures result_same_base: \base_addr(\result) ≡ \base_addr(\old(s));
      ensures result_valid_string: valid_read_string(\result);
    
    behavior not_found:
      assumes char_not_found: strchr(s, c) ≡ (0 ≢ 0);
      ensures result_null: \result ≡ \null;
    
    behavior default:
      ensures
        result_null_or_same_base:
          \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
char *strrchr(char const *s, int c);

/*@ requires valid_string_s: valid_read_string(s);
    requires valid_string_reject: valid_read_string(reject);
    ensures result_bounded: 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(reject + (0 ..)));
 */
size_t strcspn(char const *s, char const *reject);

/*@ requires valid_string_s: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures result_bounded: 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..)), *(accept + (0 ..));
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(accept + (0 ..)));
 */
size_t strspn(char const *s, char const *accept);

/*@ requires valid_string_s: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures
      result_null_or_same_base:
        \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), *(accept + (0 ..));
 */
char *strpbrk(char const *s, char const *accept);

/*@ requires valid_string_haystack: valid_read_string(haystack);
    requires valid_string_needle: valid_read_string(needle);
    ensures
      result_null_or_in_haystack:
        \result ≡ \null ∨
        (\subset(\result, \old(haystack) + (0 ..)) ∧
         \valid_read(\result) ∧
         memcmp{Pre, Pre}(\result, \old(needle), strlen(\old(needle))) ≡ 0);
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
char *strstr(char const *haystack, char const *needle);

/*@ requires valid_string_haystack: valid_read_string(haystack);
    requires valid_string_needle: valid_read_string(needle);
    ensures
      result_null_or_in_haystack:
        \result ≡ \null ∨
        (\subset(\result, \old(haystack) + (0 ..)) ∧ \valid_read(\result));
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
char *strcasestr(char const *haystack, char const *needle);

char *__fc_strtok_ptr;
/*@ requires valid_string_delim: valid_read_string(delim);
    assigns *(s + (0 ..)), *(__fc_strtok_ptr + (0 ..)), \result,
            __fc_strtok_ptr;
    assigns *(s + (0 ..))
      \from *(s + (0 ..)), (indirect: s), (indirect: __fc_strtok_ptr),
            (indirect: *(delim + (0 ..)));
    assigns *(__fc_strtok_ptr + (0 ..))
      \from *(__fc_strtok_ptr + (0 ..)), (indirect: s),
            (indirect: __fc_strtok_ptr), (indirect: *(delim + (0 ..)));
    assigns \result
      \from s, __fc_strtok_ptr, (indirect: *(s + (0 ..))),
            (indirect: *(__fc_strtok_ptr + (0 ..))),
            (indirect: *(delim + (0 ..)));
    assigns __fc_strtok_ptr
      \from \old(__fc_strtok_ptr), s,
            (indirect: *(__fc_strtok_ptr + (0 ..))),
            (indirect: *(delim + (0 ..)));
    
    behavior new_str:
      assumes s_not_null: s ≢ \null;
      requires
        valid_string_s_or_delim_not_found:
          valid_string(s) ∨
          (valid_read_string(s) ∧
           (∀ int i;
              0 ≤ i < strlen(delim) ⇒
              strchr(s, *(delim + i)) ≡ (0 ≢ 0)));
      ensures
        result_subset:
          \result ≡ \null ∨ \subset(\result, \old(s) + (0 ..));
      ensures ptr_subset: \subset(__fc_strtok_ptr, \old(s) + (0 ..));
      assigns __fc_strtok_ptr, *(s + (0 ..)), \result;
      assigns __fc_strtok_ptr
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
      assigns *(s + (0 ..))
        \from *(s + (0 ..)), (indirect: s), (indirect: *(delim + (0 ..)));
      assigns \result
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
    
    behavior resume_str:
      assumes s_null: s ≡ \null;
      requires not_first_call: __fc_strtok_ptr ≢ \null;
      ensures
        result_subset:
          \result ≡ \null ∨
          \subset(\result, \old(__fc_strtok_ptr) + (0 ..));
      ensures
        ptr_subset: \subset(__fc_strtok_ptr, \old(__fc_strtok_ptr) + (0 ..));
      assigns *(__fc_strtok_ptr + (0 ..)), __fc_strtok_ptr, \result;
      assigns *(__fc_strtok_ptr + (0 ..))
        \from *(__fc_strtok_ptr + (0 ..)), (indirect: __fc_strtok_ptr),
              (indirect: *(delim + (0 ..)));
      assigns __fc_strtok_ptr
        \from \old(__fc_strtok_ptr), (indirect: *(__fc_strtok_ptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
      assigns \result
        \from __fc_strtok_ptr, (indirect: *(__fc_strtok_ptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
    
    complete behaviors resume_str, new_str;
    disjoint behaviors resume_str, new_str;
 */
char *strtok(char * restrict s, char const * restrict delim);

/*@ requires valid_string_delim: valid_read_string(delim);
    requires valid_saveptr: \valid(saveptr);
    assigns *(s + (0 ..)), *(*saveptr + (0 ..)), \result, *saveptr;
    assigns *(s + (0 ..))
      \from *(s + (0 ..)), (indirect: s), (indirect: *saveptr),
            (indirect: *(delim + (0 ..)));
    assigns *(*saveptr + (0 ..))
      \from *(*saveptr + (0 ..)), (indirect: s), (indirect: *saveptr),
            (indirect: *(delim + (0 ..)));
    assigns \result
      \from s, *saveptr, (indirect: *(s + (0 ..))),
            (indirect: *(*saveptr + (0 ..))), (indirect: *(delim + (0 ..)));
    assigns *saveptr
      \from \old(*saveptr), s, (indirect: *(*saveptr + (0 ..))),
            (indirect: *(delim + (0 ..)));
    
    behavior new_str:
      assumes s_not_null: s ≢ \null;
      requires
        valid_string_s_or_delim_not_found:
          valid_string(s) ∨
          (valid_read_string(s) ∧
           (∀ int i;
              0 ≤ i < strlen(delim) ⇒
              strchr(s, *(delim + i)) ≡ (0 ≢ 0)));
      ensures
        result_subset:
          \result ≡ \null ∨ \subset(\result, \old(s) + (0 ..));
      ensures initialization: \initialized(\old(saveptr));
      ensures saveptr_subset: \subset(*\old(saveptr), \old(s) + (0 ..));
      assigns *saveptr, *(s + (0 ..)), \result;
      assigns *saveptr
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
      assigns *(s + (0 ..))
        \from *(s + (0 ..)), (indirect: s), (indirect: *(delim + (0 ..)));
      assigns \result
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
    
    behavior resume_str:
      assumes s_null: s ≡ \null;
      requires not_first_call: *saveptr ≢ \null;
      requires saveptr: initialization: \initialized(saveptr);
      ensures
        result_subset:
          \result ≡ \null ∨ \subset(\result, \old(*saveptr) + (0 ..));
      ensures
        saveptr_subset: \subset(*\old(saveptr), \old(*saveptr) + (0 ..));
      assigns *(*saveptr + (0 ..)), *saveptr, \result;
      assigns *(*saveptr + (0 ..))
        \from *(*saveptr + (0 ..)), (indirect: *saveptr),
              (indirect: *(delim + (0 ..)));
      assigns *saveptr
        \from \old(*saveptr), (indirect: *(*saveptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
      assigns \result
        \from *saveptr, (indirect: *(*saveptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
    
    complete behaviors resume_str, new_str;
    disjoint behaviors resume_str, new_str;
 */
char *strtok_r(char * restrict s, char const * restrict delim,
               char ** restrict saveptr);

/*@ requires
      valid_string_stringp: \valid(stringp) ∧ valid_string(*stringp);
    requires valid_string_delim: valid_read_string(delim);
    assigns *stringp, \result;
    assigns *stringp \from *(delim + (..)), *(*(stringp + (..)));
    assigns \result \from *(delim + (..)), *(*(stringp + (..)));
 */
char *strsep(char **stringp, char const *delim);

char __fc_strerror[64];
char * const __fc_p_strerror = __fc_strerror;
/*@ ensures result_internal_str: \result ≡ __fc_p_strerror;
    ensures result_nul_terminated: *(\result + 63) ≡ 0;
    ensures result_valid_string: valid_read_string(\result);
    assigns \result;
    assigns \result \from __fc_p_strerror, (indirect: errnum);
 */
char *strerror(int errnum);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_string: \valid(dest + (0 .. strlen(src)));
    requires
      separation:
        \separated(dest + (0 .. strlen(src)), src + (0 .. strlen(src)));
    ensures equal_contents: strcmp(\old(dest), \old(src)) ≡ 0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (0 .. strlen{Old}(src))), \result;
    assigns *(dest + (0 .. strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *strcpy(char * restrict dest, char const * restrict src);

/*@ requires valid_nstring_src: valid_read_nstring(src, n);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    requires separation: \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    ensures result_ptr: \result ≡ \old(dest);
    ensures initialization: \initialized(\old(dest) + (0 .. \old(n) - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 .. n - 1));
    assigns \result \from dest;
    
    behavior complete:
      assumes src_fits: strlen(src) < n;
      ensures equal_after_copy: strcmp(\old(dest), \old(src)) ≡ 0;
    
    behavior partial:
      assumes src_too_long: n ≤ strlen(src);
      ensures
        equal_prefix:
          memcmp{Post, Post}(\old(dest), \old(src), \old(n)) ≡ 0;
 */
char *strncpy(char * restrict dest, char const * restrict src, size_t n);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    requires
      separation:
        \separated(
          dest + (0 .. n - 1), src + (0 .. \max(n - 1, strlen(src)))
          );
    ensures
      initialization:
        \initialized(\old(dest) + (0 .. \min(strlen(\old(src)), \old(n) - 1)));
    ensures bounded_result: \result ≡ strlen(\old(src));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 .. n - 1));
    assigns \result
      \from (indirect: src), (indirect: *(src + (0 .. n - 1))), (indirect: n);
 */
size_t strlcpy(char * restrict dest, char const * restrict src, size_t n);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_string: \valid(dest + (0 .. strlen(src)));
    requires
      separation:
        \separated(dest + (0 .. strlen(src)), src + (0 .. strlen(src)));
    ensures equal_contents: strcmp(\old(dest), \old(src)) ≡ 0;
    ensures points_to_end: \result ≡ \old(dest) + strlen(\old(dest));
    assigns *(dest + (0 .. strlen{Old}(src))), \result;
    assigns *(dest + (0 .. strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *stpcpy(char * restrict dest, char const * restrict src);

/*@ requires valid_string_src: valid_read_string(src);
    requires valid_string_dest: valid_string(dest);
    requires room_string: \valid(dest + (0 .. strlen(dest) + strlen(src)));
    ensures
      sum_of_lengths: strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
    ensures
      dest: initialization:
        \initialized(\old(dest) + (0 .. \old(strlen(dest) + strlen(src))));
    ensures
      dest_null_terminated:
        *(\old(dest) + \old(strlen(dest) + strlen(src))) ≡ 0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest +
              (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
            \result;
    assigns
    *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *strcat(char * restrict dest, char const * restrict src);

/*@ requires valid_nstring_src: valid_read_nstring(src, n);
    requires valid_string_dest: valid_string(dest);
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)), \result;
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
      \from *(src + (0 .. n));
    assigns \result \from dest;
    
    behavior complete:
      assumes
        valid_string_src_fits: valid_read_string(src) ∧ strlen(src) ≤ n;
      requires
        room_string: \valid((dest + strlen(dest)) + (0 .. strlen(src)));
      ensures
        sum_of_lengths:
          strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
      assigns *(dest +
                (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
              \result;
      assigns
      *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
    
    behavior partial:
      assumes
        valid_string_src_too_large:
          ¬(valid_read_string(src) ∧ strlen(src) ≤ n);
      requires room_string: \valid((dest + strlen(dest)) + (0 .. n));
      ensures
        sum_of_bounded_lengths:
          strlen(\old(dest)) ≡ \old(strlen(dest)) + \old(n);
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)),
              \result;
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
 */
char *strncat(char * restrict dest, char const * restrict src, size_t n);

/*@ requires valid_string_src: valid_read_string(src);
    requires valid_string_dest: valid_string(dest);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    ensures
      bounded_result: \result ≡ strlen(\old(dest)) + strlen(\old(src));
    assigns *(dest + (strlen{Old}(dest) .. n)), \result;
    assigns *(dest + (strlen{Old}(dest) .. n))
      \from (indirect: n), *(src + (0 .. strlen{Old}(src)));
    assigns \result
      \from (indirect: src), (indirect: *(src + (0 .. n - 1))), (indirect: n);
 */
size_t strlcat(char * restrict dest, char const * restrict src, size_t n);

/*@ requires valid_dest: \valid(dest + (0 .. n - 1));
    requires valid_string_src: valid_read_string(src);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from (indirect: *(src + (0 ..))), (indirect: n);
    assigns \result \from dest;
 */
size_t strxfrm(char * restrict dest, char const * restrict src, size_t n);

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result
      \from (indirect: *(s + (0 .. strlen{Old}(s)))),
            (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(strlen(s));
      ensures allocation: \fresh{Old, Here}(\result,strlen(\old(s)));
      ensures
        result_valid_string_and_same_contents:
          valid_string(\result) ∧ strcmp(\result, \old(s)) ≡ 0;
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status \from (indirect: s), __fc_heap_status;
      assigns \result
        \from (indirect: *(s + (0 .. strlen{Old}(s)))),
              (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(strlen(s));
      ensures result_null: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
 */
char *strdup(char const *s);

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result
      \from (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: n),
            (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(\min(strlen(s), n + 1));
      ensures
        allocation:
          \fresh{Old, Here}(\result,\min(strlen(\old(s)), \old(n) + 1));
      ensures
        result_valid_string_bounded_and_same_prefix:
          \valid(\result + (0 .. \min(strlen(\old(s)), \old(n)))) ∧
          valid_string(\result) ∧ strlen(\result) ≤ \old(n) ∧
          strncmp(\result, \old(s), \old(n)) ≡ 0;
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status
        \from (indirect: s), (indirect: n), __fc_heap_status;
      assigns \result
        \from (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: n),
              (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(\min(strlen(s), n + 1));
      ensures result_null: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
 */
char *strndup(char const *s, size_t n);

char __fc_strsignal[64];
char * const __fc_p_strsignal = __fc_strsignal;
/*@ ensures result_internal_str: \result ≡ __fc_p_strsignal;
    ensures result_nul_terminated: *(\result + 63) ≡ 0;
    ensures result_valid_string: valid_read_string(\result);
    assigns \result;
    assigns \result \from __fc_p_strsignal, (indirect: signum);
 */
char *strsignal(int signum);

/*@ requires valid_memory_area: \valid((char *)s + (0 .. n - 1));
    ensures
      initialization: s_initialized:
        \initialized((char *)\old(s) + (0 .. \old(n) - 1));
    ensures
      zero_initialized: \subset(*((char *)\old(s) + (0 .. \old(n) - 1)), {0});
    assigns *((char *)s + (0 .. n - 1));
    assigns *((char *)s + (0 .. n - 1)) \from \nothing;
 */
void bzero(void *s, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
int strcasecmp(char const *s1, char const *s2);

/*@ requires valid_string_s1: valid_read_nstring(s1, n);
    requires valid_string_s2: valid_read_nstring(s2, n);
    assigns \result;
    assigns \result
      \from (indirect: n), (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1)));
 */
int strncasecmp(char const *s1, char const *s2, size_t n);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[2];

/*@ requires \valid_read(this); */
void exception::Ctor(struct exception const *this);

/*@ requires \separated(this, exn);
    requires \valid_read(this);
    requires \valid_read(exn);
 */
void exception::Ctor(struct exception const *this,
                     struct exception const *exn);

/*@ requires \valid(this);
    requires \valid_read(exn);
    ensures \valid(\result);
 */
struct exception *operator=(struct exception *this,
                            struct exception const *exn);

/*@ requires \valid_read(this); */
void exception::Dtor(struct exception const *this);

/*@ requires \valid_read(this); */
char const *what(struct exception const *this);

void bad_exception::Dtor(struct bad_exception const *this);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];

struct _frama_c_vmt_content _frama_c_vmt[2];

/*@ requires \valid_read(this); */
void bad_exception::Ctor(struct bad_exception const *this);

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void bad_exception::Ctor(struct bad_exception const *this,
                         struct bad_exception const *__frama_c_arg_0);

/*@ requires \valid(this);
    requires \valid_read(__frama_c_arg_0);
    ensures \valid(\result);
 */
struct bad_exception *operator=(struct bad_exception *this,
                                struct bad_exception const *__frama_c_arg_0);

/*@ requires \valid_read(this); */
char const *what(struct bad_exception const *this);

/*@ requires \valid_read(this); */
void bad_exception::Dtor(struct bad_exception const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  exception::Dtor(& this->_frama_c__ZN3stdE9exception);
  return;
}

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];

/*@ requires \valid_read(this); */
void nested_exception::Ctor(struct nested_exception const *this);

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void nested_exception::Ctor(struct nested_exception const *this,
                            struct nested_exception const *__frama_c_arg_0);

/*@ requires \valid(this);
    requires \valid_read(__frama_c_arg_0);
    ensures \valid(\result);
 */
struct nested_exception *operator=(struct nested_exception *this,
                                   struct nested_exception const *__frama_c_arg_0);

/*@ requires \valid_read(this); */
void nested_exception::Dtor(struct nested_exception const *this);

/*@ requires \valid_read(this); */
void rethrow_nested(struct nested_exception const *this);

/*@ requires \valid_read(this); */
exception_ptr nested_ptr(struct nested_exception const *this);

int _frama_c_find_dynamic_cast_aux(struct _frama_c_rtti_name_info_node *target_info,
                                   struct _frama_c_rtti_name_info_content *concrete_base,
                                   int number_of_bases,
                                   int found_shift_object,
                                   int found_shift_vmt, int last_shift_vmt,
                                   int *shift_object, int *distance)
{
  int result = 0;
  struct _frama_c_rtti_name_info_content *cursor = concrete_base;
  int is_over = 0;
  int base_index = 0;
  while (base_index < number_of_bases) {
    if (cursor->value == target_info) {
      if (*distance < 0) goto _LOR;
      else 
        if (*distance >= 1) {
          _LOR:
          {
            if (found_shift_vmt == cursor->shift_vmt) *distance = 0;
            else *distance = 1;
            *shift_object = found_shift_object - cursor->shift_object;
            result = 1;
          }
        }
    }
    else 
      if (cursor->shift_vmt <= found_shift_vmt) {
        int tmp_5;
        if (base_index < number_of_bases - 1) tmp_5 = (cursor + 1)->shift_vmt > found_shift_vmt;
        else {
          int tmp_4;
          if (last_shift_vmt == -1) tmp_4 = 1;
          else 
            if (found_shift_vmt < last_shift_vmt) tmp_4 = 1; else tmp_4 = 0;
          tmp_5 = tmp_4;
        }
        if (tmp_5) {
          int tmp_0;
          int tmp;
          int local_distance = 0;
          int local_shift_object = 0;
          if (base_index < number_of_bases - 1) tmp = (cursor + 1)->shift_vmt;
          else tmp = last_shift_vmt;
          ;
          ;
          ;
          ;
          ;
          tmp_0 = _frama_c_find_dynamic_cast_aux(target_info,
                                                 (cursor->value)->base_classes,
                                                 (cursor->value)->number_of_base_classes,
                                                 found_shift_object - cursor->shift_object,
                                                 found_shift_vmt - cursor->shift_vmt,
                                                 tmp,& local_shift_object,
                                                 & local_distance);
          int local_result = tmp_0;
          if (local_result != 0) 
            if (local_distance >= 0) 
              if (*distance < 0) goto _LOR_0;
              else 
                if (*distance >= local_distance) {
                  _LOR_0:
                  {
                    result = local_result;
                    *shift_object = local_shift_object - cursor->shift_object;
                    *distance = local_distance;
                  }
                }
          is_over = 1;
        }
        else goto _LAND;
      }
      else {
        _LAND: ;
        if (*distance < 0) goto _LOR_2;
        else 
          if (*distance >= 1) {
            _LOR_2:
            {
              int tmp_2;
              int tmp_1;
              int local_distance_0 = 0;
              int local_shift_object_0 = 0;
              if (base_index < number_of_bases + 1) tmp_1 = (cursor + 1)->shift_vmt;
              else tmp_1 = last_shift_vmt;
              ;
              ;
              ;
              ;
              ;
              tmp_2 = _frama_c_find_dynamic_cast_aux(target_info,
                                                     (cursor->value)->base_classes,
                                                     (cursor->value)->number_of_base_classes,
                                                     found_shift_object - cursor->shift_object,
                                                     found_shift_vmt - cursor->shift_vmt,
                                                     tmp_1,
                                                     & local_shift_object_0,
                                                     & local_distance_0);
              int local_result_0 = tmp_2;
              if (local_result_0 != 0) 
                if (local_distance_0 >= 0) 
                  if (*distance < 0) goto _LOR_1;
                  else {
                    int tmp_3;
                    if (is_over == 0) tmp_3 = local_distance_0;
                    else tmp_3 = local_distance_0 + 1;
                    ;
                    if (*distance > tmp_3) {
                      _LOR_1:
                      {
                        result = local_result_0;
                        *shift_object = local_shift_object_0 - cursor->shift_object;
                        *distance = local_distance_0 + 1;
                      }
                    }
                  }
            }
          }
      }
    cursor ++;
    base_index ++;
  }
  return result;
}

int _frama_c_find_dynamic_cast(struct _frama_c_rtti_name_info_node *declared_info,
                               struct _frama_c_vmt *declared_vmt,
                               struct _frama_c_rtti_name_info_node *target_info,
                               int *shift_object)
{
  int __retres;
  int shift_vmt;
  int elaborated_shift_target;
  struct _frama_c_rtti_name_info_content *cursor;
  int number_of_bases;
  int tmp_0;
  struct _frama_c_rtti_name_info_node *concrete_info =
    declared_vmt->rtti_info;
  int elaborated_shift_vmt = 0;
  int elaborated_shift_object = 0;
  int cursor_index = 0;
  int distance = -1;
  if (concrete_info->pvmt > declared_vmt) {
    __retres = 0;
    goto return_label;
  }
  else 
    if (declared_vmt > concrete_info->pvmt + declared_vmt->table_size) {
      __retres = 0;
      goto return_label;
    }
  shift_vmt = declared_vmt - concrete_info->pvmt;
  if (concrete_info == declared_info) {
    *shift_object = 0;
    __retres = target_info == declared_info;
    goto return_label;
  }
  if (target_info == concrete_info) elaborated_shift_target = 0;
  else elaborated_shift_target = -1;
  cursor = concrete_info->base_classes;
  number_of_bases = concrete_info->number_of_base_classes;
  while (1) {
    while (1) {
      if (cursor_index < number_of_bases) {
        if (! (elaborated_shift_vmt + cursor->shift_vmt < shift_vmt)) 
          break;
      }
      else break;
      {
        struct _frama_c_rtti_name_info_content *tmp;
        if (cursor_index < number_of_bases - 1) tmp = cursor + 1;
        else tmp = (struct _frama_c_rtti_name_info_content *)0;
        struct _frama_c_rtti_name_info_content *next_cursor = tmp;
        if (next_cursor != (struct _frama_c_rtti_name_info_content *)0) 
          if (elaborated_shift_vmt + next_cursor->shift_vmt <= shift_vmt) {
            cursor = next_cursor;
            cursor_index ++;
          }
          else break;
        else break;
      }
    }
    if (cursor_index < number_of_bases) {
      elaborated_shift_vmt += cursor->shift_vmt;
      elaborated_shift_object += cursor->shift_object;
      if (cursor->value == target_info) elaborated_shift_target = elaborated_shift_object;
      if (elaborated_shift_vmt == shift_vmt) 
        if (cursor->value == declared_info) {
          if (elaborated_shift_target >= 0) {
            *shift_object = elaborated_shift_target - elaborated_shift_object;
            __retres = 1;
            goto return_label;
          }
          break;
        }
      cursor = (cursor->value)->base_classes;
      number_of_bases = (cursor->value)->number_of_base_classes;
      cursor_index = 0;
    }
    if (! (cursor_index < number_of_bases)) break;
  }
  if (cursor_index >= number_of_bases) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = _frama_c_find_dynamic_cast_aux(target_info,
                                         concrete_info->base_classes,
                                         concrete_info->number_of_base_classes,
                                         elaborated_shift_object,shift_vmt,
                                         -1,shift_object,& distance);
  __retres = tmp_0;
  return_label: return __retres;
}

struct _frama_c_vmt_content _frama_c_vmt[2] =
  {{.method_ptr = (void (*)())(& exception::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& what), .shift_this = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "exception",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 2,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_vmt_content _frama_c_vmt[2] =
  {{.method_ptr = (void (*)())(& bad_exception::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& what), .shift_this = 0}};
struct _frama_c_rtti_name_info_content _frama_c_base_classes[1] =
  {{.value = & _frama_c_rtti_name_info,
    .shift_object = (char *)0 - (char *)(& ((struct bad_exception *)0)->_frama_c__ZN3stdE9exception),
    .shift_vmt = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "bad_exception",
   .base_classes = _frama_c_base_classes,
   .number_of_base_classes = 1,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 2,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_vmt_content _frama_c_vmt[1] =
  {{.method_ptr = (void (*)())(& nested_exception::Dtor), .shift_this = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "nested_exception",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 1,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];

/*@ requires \valid_read(this); */
void type_info::Dtor(struct type_info const *this);

/*@ requires \valid_read(this); */
void type_info::Ctor(struct type_info const *this,
                     char const *__frama_c_arg_0);

/*@ requires \valid_read(this);
    requires \valid_read(rhs); */
_Bool operator==(struct type_info const *this, struct type_info const *rhs);

/*@ requires \valid_read(this);
    requires \valid_read(rhs); */
_Bool operator!=(struct type_info const *this, struct type_info const *rhs);

/*@ requires \valid_read(this);
    requires \valid_read(rhs); */
_Bool before(struct type_info const *this, struct type_info const *rhs);

/*@ requires \valid_read(this); */
size_t hash_code(struct type_info const *this);

/*@ requires \valid_read(this); */
char const *name(struct type_info const *this);

void bad_cast::Dtor(struct bad_cast const *this);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];

struct _frama_c_vmt_content _frama_c_vmt[2];

/*@ requires \valid_read(this); */
void bad_cast::Ctor(struct bad_cast const *this);

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void bad_cast::Ctor(struct bad_cast const *this,
                    struct bad_cast const *__frama_c_arg_0);

/*@ requires \valid(this);
    requires \valid_read(__frama_c_arg_0);
    ensures \valid(\result);
 */
struct bad_cast *operator=(struct bad_cast *this,
                           struct bad_cast const *__frama_c_arg_0);

/*@ requires \valid_read(this); */
char const *what(struct bad_cast const *this);

/*@ requires \valid_read(this); */
void bad_cast::Dtor(struct bad_cast const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  exception::Dtor(& this->_frama_c__ZN3stdE9exception);
  return;
}

void bad_typeid::Dtor(struct bad_typeid const *this);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];

struct _frama_c_vmt_content _frama_c_vmt[2];

/*@ requires \valid_read(this); */
void bad_typeid::Ctor(struct bad_typeid const *this);

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void bad_typeid::Ctor(struct bad_typeid const *this,
                      struct bad_typeid const *__frama_c_arg_0);

/*@ requires \valid(this);
    requires \valid_read(__frama_c_arg_0);
    ensures \valid(\result);
 */
struct bad_typeid *operator=(struct bad_typeid *this,
                             struct bad_typeid const *__frama_c_arg_0);

/*@ requires \valid_read(this); */
char const *what(struct bad_typeid const *this);

/*@ requires \valid_read(this); */
void bad_typeid::Dtor(struct bad_typeid const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  exception::Dtor(& this->_frama_c__ZN3stdE9exception);
  return;
}

struct _frama_c_vmt_content _frama_c_vmt[1] =
  {{.method_ptr = (void (*)())(& type_info::Dtor), .shift_this = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "type_info",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 1,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_vmt_content _frama_c_vmt[2] =
  {{.method_ptr = (void (*)())(& bad_cast::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& what), .shift_this = 0}};
struct _frama_c_rtti_name_info_content _frama_c_base_classes[1] =
  {{.value = & _frama_c_rtti_name_info,
    .shift_object = (char *)0 - (char *)(& ((struct bad_cast *)0)->_frama_c__ZN3stdE9exception),
    .shift_vmt = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "bad_cast",
   .base_classes = _frama_c_base_classes,
   .number_of_base_classes = 1,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 2,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_vmt_content _frama_c_vmt[2] =
  {{.method_ptr = (void (*)())(& bad_typeid::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& what), .shift_this = 0}};
struct _frama_c_rtti_name_info_content _frama_c_base_classes[1] =
  {{.value = & _frama_c_rtti_name_info,
    .shift_object = (char *)0 - (char *)(& ((struct bad_typeid *)0)->_frama_c__ZN3stdE9exception),
    .shift_vmt = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "bad_typeid",
   .base_classes = _frama_c_base_classes,
   .number_of_base_classes = 1,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 2,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this);
    requires \valid(t); */
void reference_wrapper<bool*,<abst>>::Ctor(struct reference_wrapper<bool*,<abst>> const *this,
                                           type *t);

/*@ requires \valid_read(this);
    requires \valid_read(t); */
void reference_wrapper<bool*,<abst>>::Ctor(struct reference_wrapper<bool*,<abst>> const *this,
                                           type const *t);

/*@ requires \separated(this, x);
    requires \valid_read(this);
    requires \valid_read(x);
 */
void reference_wrapper<bool*,<abst>>::Ctor(struct reference_wrapper<bool*,<abst>> const *this,
                                           struct reference_wrapper<bool*,<abst>> const *x);

/*@ requires \valid(this);
    requires \valid_read(x);
    ensures \valid(\result); */
struct reference_wrapper<bool*,<abst>> *operator=(struct reference_wrapper<bool*,<abst>> *this,
                                                  struct reference_wrapper<bool*,<abst>> const *x);

/*@ requires \valid_read(this);
    ensures \valid(\result); */
type *type&)(struct reference_wrapper<bool*,<abst>> const *this);

/*@ requires \valid_read(this);
    ensures \valid(\result); */
type *get(struct reference_wrapper<bool*,<abst>> const *this);

/*@ requires \valid_read(this); */
_Bool operator()(struct reference_wrapper<bool*,<abst>> const *this, int arg);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "reference_wrapper",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void reference_wrapper<bool&,<abst>>::Dtor(struct reference_wrapper<bool&,<abst>> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this);
    requires \valid(t); */
void reference_wrapper<bool&,<abst>>::Ctor(struct reference_wrapper<bool&,<abst>> const *this,
                                           type *t)
{
  this->obj = *t;
  return;
}

/*@ requires \valid_read(this);
    requires \valid_read(t); */
void reference_wrapper<bool&,<abst>>::Ctor(struct reference_wrapper<bool&,<abst>> const *this,
                                           type const *t);

/*@ requires \valid_read(this);
    requires \valid_read(x); */
void reference_wrapper<bool&,<abst>>::Ctor(struct reference_wrapper<bool&,<abst>> const *this,
                                           struct reference_wrapper<bool*,<abst>> const *x);

/*@ requires \valid(this);
    requires \valid_read(x);
    ensures \valid(\result); */
struct reference_wrapper<bool&,<abst>> *operator=(struct reference_wrapper<bool&,<abst>> *this,
                                                  struct reference_wrapper<bool*,<abst>> const *x);

/*@ requires \valid_read(this);
    ensures \valid(\result); */
type *type&)(struct reference_wrapper<bool&,<abst>> const *this);

/*@ requires \valid_read(this);
    ensures \valid(\result); */
type *get(struct reference_wrapper<bool&,<abst>> const *this);

/*@ requires \valid_read(this); */
_Bool operator()(struct reference_wrapper<bool&,<abst>> const *this, int arg)
{
  _Bool tmp;
  tmp = (*(this->obj))(arg);
  return tmp;
}

/*@ requires \valid_read(this); */
void reference_wrapper<bool&,<abst>>::Dtor(struct reference_wrapper<bool&,<abst>> const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "reference_wrapper",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "reference_wrapper",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void __bool_binop<int,std::__less>::Ctor(struct __bool_binop<int,std::__less> const *this);

void __bool_binop<int,std::__less>::Dtor(struct __bool_binop<int,std::__less> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

_Bool operator()(struct __bool_binop<int,std::__less> const *this,
                 int const *x, int const *y);

/*@ requires \valid(this); */
__funtype __funtype)(struct __bool_binop<int,std::__less> *this);

/*@ requires \valid_read(this); */
void __bool_binop<int,std::__less>::Ctor(struct __bool_binop<int,std::__less> const *this)
{
  return;
}

/*@ requires \valid_read(this); */
void __bool_binop<int,std::__less>::Dtor(struct __bool_binop<int,std::__less> const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__bool_binop",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void __bool_binop<int,std::__equal_to>::Ctor(struct __bool_binop<int,std::__equal_to> const *this);

void __bool_binop<int,std::__equal_to>::Ctor(struct __bool_binop<int,std::__equal_to> const *this,
                                             struct __bool_binop<int,std::__equal_to> const *__frama_c_arg_0);

void __bool_binop<int,std::__equal_to>::Dtor(struct __bool_binop<int,std::__equal_to> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

_Bool operator()(struct __bool_binop<int,std::__equal_to> const *this,
                 int const *x, int const *y);

/*@ requires \valid(this); */
__funtype __funtype)(struct __bool_binop<int,std::__equal_to> *this);

/*@ requires \valid_read(this); */
void __bool_binop<int,std::__equal_to>::Ctor(struct __bool_binop<int,std::__equal_to> const *this)
{
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void __bool_binop<int,std::__equal_to>::Ctor(struct __bool_binop<int,std::__equal_to> const *this,
                                             struct __bool_binop<int,std::__equal_to> const *__frama_c_arg_0)
{
  return;
}

/*@ requires \valid_read(this); */
void __bool_binop<int,std::__equal_to>::Dtor(struct __bool_binop<int,std::__equal_to> const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__bool_binop",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@ requires \valid_read(y);
    requires \valid_read(x); */
_Bool __equal_to<int>(int const *x, int const *y)
{
  _Bool __retres;
  __retres = (_Bool)(*x == *y);
  return __retres;
}

/*@ requires \valid_read(this);
    requires \valid_read(y);
    requires \valid_read(x);
 */
_Bool operator()(struct __bool_binop<int,std::__equal_to> const *this,
                 int const *x, int const *y)
{
  _Bool tmp;
  tmp = __equal_to<int>(x,y);
  return tmp;
}

void equal_to<int>::Ctor(struct equal_to<int> const *this);

void equal_to<int>::Ctor(struct equal_to<int> const *this,
                         struct equal_to<int> const *__frama_c_arg_0);

void equal_to<int>::Dtor(struct equal_to<int> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void equal_to<int>::Ctor(struct equal_to<int> const *this)
{
  __bool_binop<int,std::__equal_to>::Ctor(& this->_frama_c__ZN3stdE12__bool_binopIiN3stdE10__equal_toE);
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void equal_to<int>::Ctor(struct equal_to<int> const *this,
                         struct equal_to<int> const *__frama_c_arg_0)
{
  __bool_binop<int,std::__equal_to>::Ctor(& this->_frama_c__ZN3stdE12__bool_binopIiN3stdE10__equal_toE,
                                          & __frama_c_arg_0->_frama_c__ZN3stdE12__bool_binopIiN3stdE10__equal_toE);
  return;
}

/*@ requires \valid_read(this); */
void equal_to<int>::Dtor(struct equal_to<int> const *this)
{
  __bool_binop<int,std::__equal_to>::Dtor(& this->_frama_c__ZN3stdE12__bool_binopIiN3stdE10__equal_toE);
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "equal_to",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@ requires \valid_read(y);
    requires \valid_read(x); */
_Bool __less<int>(int const *x, int const *y)
{
  _Bool __retres;
  __retres = (_Bool)(*x < *y);
  return __retres;
}

/*@ requires \valid_read(this);
    requires \valid_read(y);
    requires \valid_read(x);
 */
_Bool operator()(struct __bool_binop<int,std::__less> const *this,
                 int const *x, int const *y)
{
  _Bool tmp;
  tmp = __less<int>(x,y);
  return tmp;
}

void less<int>::Ctor(struct less<int> const *this);

void less<int>::Dtor(struct less<int> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void less<int>::Ctor(struct less<int> const *this)
{
  __bool_binop<int,std::__less>::Ctor(& this->_frama_c__ZN3stdE12__bool_binopIiN3stdE6__lessE);
  return;
}

/*@ requires \valid_read(this); */
void less<int>::Dtor(struct less<int> const *this)
{
  __bool_binop<int,std::__less>::Dtor(& this->_frama_c__ZN3stdE12__bool_binopIiN3stdE6__lessE);
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "less",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void unary_negate<bool*,<abst>>::Dtor(struct unary_negate<bool*,<abst>> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this);
    requires \valid_read(pred); */
void unary_negate<bool*,<abst>>::Ctor(struct unary_negate<bool*,<abst>> const *this,
                                      _Bool (* const *pred)(int ))
{
  this->__predicate = pred;
  return;
}

/*@ requires \valid_read(this);
    requires \valid_read(x); */
_Bool operator()(struct unary_negate<bool*,<abst>> const *this,
                 argument_type const *x)
{
  _Bool __retres;
  int tmp_0;
  _Bool tmp;
  tmp = (*(*(this->__predicate)))(*x);
  if (tmp) tmp_0 = 0; else tmp_0 = 1;
  __retres = (_Bool)(tmp_0 != 0);
  return __retres;
}

/*@ requires \valid_read(this); */
void unary_negate<bool*,<abst>>::Dtor(struct unary_negate<bool*,<abst>> const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "unary_negate",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void unary_negate<std::reference_wrapper<bool&,<abst>>>::Dtor(struct unary_negate<std::reference_wrapper<bool&,<abst>>> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this);
    requires \valid_read(pred); */
void unary_negate<std::reference_wrapper<bool&,<abst>>>::Ctor(struct unary_negate<std::reference_wrapper<bool&,<abst>>> const *this,
                                                              struct reference_wrapper<bool&,<abst>> const *pred)
{
  this->__predicate = pred;
  return;
}

/*@ requires \valid_read(this);
    requires \valid_read(x); */
_Bool operator()(struct unary_negate<std::reference_wrapper<bool&,<abst>>> const *this,
                 argument_type const *x)
{
  _Bool __retres;
  int tmp_0;
  _Bool tmp;
  tmp = operator()(this->__predicate,*x);
  if (tmp) tmp_0 = 0; else tmp_0 = 1;
  __retres = (_Bool)(tmp_0 != 0);
  return __retres;
}

/*@ requires \valid_read(this); */
void unary_negate<std::reference_wrapper<bool&,<abst>>>::Dtor(struct unary_negate<std::reference_wrapper<bool&,<abst>>> const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "unary_negate",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@ requires \valid_read(pred); */
struct unary_negate<bool*,<abst>> not1<bool*,<abst>>(_Bool (* const *pred)
                                                     (int ))
{
  struct unary_negate<bool*,<abst>> __fc_tmp_2;
  unary_negate<bool*,<abst>>::Ctor(& __fc_tmp_2,pred);
  return __fc_tmp_2;
}

/*@ requires \valid_read(pred); */
struct unary_negate<std::reference_wrapper<bool&,<abst>>> not1<std::reference_wrapper<bool&,<abst>>>
(struct reference_wrapper<bool&,<abst>> const *pred)
{
  struct unary_negate<std::reference_wrapper<bool&,<abst>>> __fc_tmp_3;
  unary_negate<std::reference_wrapper<bool&,<abst>>>::Ctor(& __fc_tmp_3,pred);
  return __fc_tmp_3;
}

void bad_function_call::Dtor(struct bad_function_call const *this);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];

struct _frama_c_vmt_content _frama_c_vmt[2];

/*@ requires \valid_read(this); */
void bad_function_call::Ctor(struct bad_function_call const *this)
{
  exception::Ctor(& this->_frama_c__ZN3stdE9exception);
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  return;
}

/*@ requires \valid_read(this); */
void bad_function_call::Dtor(struct bad_function_call const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  exception::Dtor(& this->_frama_c__ZN3stdE9exception);
  return;
}

struct _frama_c_vmt_content _frama_c_vmt[2] =
  {{.method_ptr = (void (*)())(& bad_function_call::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& what),
    .shift_this = (char *)(& ((struct bad_function_call *)0)->_frama_c__ZN3stdE9exception) - (char *)(& ((struct bad_function_call *)0)->_frama_c__ZN3stdE9exception)}};
struct _frama_c_rtti_name_info_content _frama_c_base_classes[1] =
  {{.value = & _frama_c_rtti_name_info,
    .shift_object = (char *)0 - (char *)(& ((struct bad_function_call *)0)->_frama_c__ZN3stdE9exception),
    .shift_vmt = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "bad_function_call",
   .base_classes = _frama_c_base_classes,
   .number_of_base_classes = 1,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 2,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "input_iterator_tag",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "output_iterator_tag",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "forward_iterator_tag",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "bidirectional_iterator_tag",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "random_access_iterator_tag",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "iterator_traits",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "iterator",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@ requires \valid_function(pred); */
_Bool all_of<int*,bool&,<abst>>(int *first, int *last, _Bool (*pred)(int ))
{
  _Bool __retres;
  int **it = & first;
  while (*it < last) {
    _Bool tmp;
    tmp = (*pred)(*(*it));
    if (! tmp) {
      __retres = (_Bool)0;
      goto return_label;
    }
    (*it) ++;
  }
  __retres = (_Bool)1;
  return_label: return __retres;
}

_Bool all_of<int*,std::unary_negate<bool*,<abst>>>(int *first, int *last,
                                                   struct unary_negate<bool*,<abst>> pred)
{
  _Bool __retres;
  int **it = & first;
  while (*it < last) {
    _Bool tmp;
    tmp = operator()((struct unary_negate<bool*,<abst>> const *)(& pred),
                     (argument_type const *)*it);
    if (! tmp) {
      __retres = (_Bool)0;
      goto return_label;
    }
    (*it) ++;
  }
  __retres = (_Bool)1;
  return_label: return __retres;
}

/*@ requires \valid_function(pred); */
_Bool any_of<int*,bool&,<abst>>(int *first, int *last, _Bool (*pred)(int ))
{
  _Bool __retres;
  int **it = & first;
  while (*it < last) {
    _Bool tmp;
    tmp = (*pred)(*(*it));
    if (tmp) {
      __retres = (_Bool)1;
      goto return_label;
    }
    (*it) ++;
  }
  __retres = (_Bool)0;
  return_label: return __retres;
}

_Bool none_of<int*,bool*,<abst>>(int *first, int *last, _Bool (*pred)(int ))
{
  _Bool tmp_0;
  struct unary_negate<bool*,<abst>> __fc_tmp_4 =
    not1<bool*,<abst>>((_Bool (* const *)(int ))(& pred));
  tmp_0 = all_of<int*,std::unary_negate<bool*,<abst>>>(first,last,__fc_tmp_4);
  unary_negate<bool*,<abst>>::Dtor((struct unary_negate<bool*,<abst>> const *)(& __fc_tmp_4));
  return tmp_0;
}

void (*for_each<int*,void*,<abst>>(int *first, int *last, void (*f)(int )))
(int )
{
  void (*__retres)(int );
  type *tmp_0;
  int **it = & first;
  while (*it < last) {
    type *tmp;
    tmp = move<int&>(*it);
    (*f)(*tmp);
    (*it) ++;
  }
  tmp_0 = move<void*&,<abst>>(& f);
  __retres = *tmp_0;
  return __retres;
}

/*@ requires \valid_read(value); */
int *find<int*,int>(int *first, int *last, int const *value)
{
  int *__retres;
  int **it = & first;
  while (*it < last) {
    if (*(*it) == *value) {
      __retres = *it;
      goto return_label;
    }
    (*it) ++;
  }
  __retres = last;
  return_label: return __retres;
}

/*@ requires \valid_function(pred); */
int *find_if<int*,bool&,<abst>>(int *first, int *last, _Bool (*pred)(int ))
{
  int *__retres;
  int **it = & first;
  while (*it < last) {
    _Bool tmp;
    tmp = (*pred)(*(*it));
    if (tmp) {
      __retres = *it;
      goto return_label;
    }
    (*it) ++;
  }
  __retres = last;
  return_label: return __retres;
}

int *find_if<int*,std::unary_negate<std::reference_wrapper<bool&,<abst>>>>
(int *first, int *last,
 struct unary_negate<std::reference_wrapper<bool&,<abst>>> pred)
{
  int *__retres;
  int **it = & first;
  while (*it < last) {
    _Bool tmp;
    tmp = operator()((struct unary_negate<std::reference_wrapper<bool&,<abst>>> const *)(& pred),
                     (argument_type const *)*it);
    if (tmp) {
      __retres = *it;
      goto return_label;
    }
    (*it) ++;
  }
  __retres = last;
  return_label: return __retres;
}

/*@ requires \valid_function(pred); */
int *find_if_not<int*,bool&,<abst>>(int *first, int *last,
                                    _Bool (*pred)(int ))
{
  struct reference_wrapper<bool&,<abst>> rpred;
  struct reference_wrapper<bool&,<abst>> __fc_tmp_5;
  reference_wrapper<bool&,<abst>>::Ctor(& __fc_tmp_5,& pred);
  rpred = __fc_tmp_5;
  {
    int *tmp_0;
    struct reference_wrapper<bool&,<abst>> const __clang_tmp_7;
    reference_wrapper<bool&,<abst>>::Ctor(& __clang_tmp_7,& pred);
    struct unary_negate<std::reference_wrapper<bool&,<abst>>> __fc_tmp_6 =
      not1<std::reference_wrapper<bool&,<abst>>>(& __clang_tmp_7);
    tmp_0 = find_if<int*,std::unary_negate<std::reference_wrapper<bool&,<abst>>>>
    (first,last,__fc_tmp_6);
    unary_negate<std::reference_wrapper<bool&,<abst>>>::Dtor((struct unary_negate<std::reference_wrapper<bool&,<abst>>> const *)(& __fc_tmp_6));
    reference_wrapper<bool&,<abst>>::Dtor(& __clang_tmp_7);
    reference_wrapper<bool&,<abst>>::Dtor((struct reference_wrapper<bool&,<abst>> const *)(& __fc_tmp_5));
    reference_wrapper<bool&,<abst>>::Dtor((struct reference_wrapper<bool&,<abst>> const *)(& rpred));
    return tmp_0;
  }
}

int *find_end<int*,int*>(int *first1, int *last1, int *first2, int *last2)
{
  int *__retres;
  int **start = & first1;
  int **res = & last1;
  while (*start < last1 - (last2 - first2)) {
    int **it1 = start;
    int **it2 = & first2;
    while (*it2 < last2) {
      if (*(*it1) != *(*it2)) break;
      (*it1) ++;
      (*it2) ++;
    }
    if (*it2 == last2) *res = *start;
    (*start) ++;
  }
  __retres = *res;
  return __retres;
}

int *find_end<int*,int*,std::less<int>>(int *first1, int *last1, int *first2,
                                        int *last2, struct less<int> pred)
{
  int *__retres;
  int **start = & first1;
  int **res = & last1;
  while (*start < last1 - (last2 - first2)) {
    int **it1 = start;
    int **it2 = & first2;
    while (*it2 < last2) {
      _Bool tmp;
      tmp = operator()((struct __bool_binop<int,std::__less> const *)(& pred._frama_c__ZN3stdE12__bool_binopIiN3stdE6__lessE),
                       (int const *)*it1,(int const *)*it2);
      if (! tmp) break;
      (*it1) ++;
      (*it2) ++;
    }
    if (*it2 == last2) *res = *start;
    (*start) ++;
  }
  __retres = *res;
  return __retres;
}

int *find_first_of<int*,int*>(int *first1, int *last1, int *first2,
                              int *last2)
{
  int *__retres;
  int *it1 = first1;
  while (it1 < last1) {
    int **it2 = & first2;
    while (*it2 < last2) {
      if (*it1 == *(*it2)) {
        __retres = it1;
        goto return_label;
      }
      (*it2) ++;
    }
    it1 ++;
  }
  __retres = last1;
  return_label: return __retres;
}

int *find_first_of<int*,int*,std::less<int>>(int *first1, int *last1,
                                             int *first2, int *last2,
                                             struct less<int> pred)
{
  int *__retres;
  int **it1 = & first1;
  while (*it1 < last1) {
    int *it2 = first2;
    while (it2 < last2) {
      _Bool tmp;
      tmp = operator()((struct __bool_binop<int,std::__less> const *)(& pred._frama_c__ZN3stdE12__bool_binopIiN3stdE6__lessE),
                       (int const *)*it1,(int const *)it2);
      if (tmp) {
        __retres = *it1;
        goto return_label;
      }
      it2 ++;
    }
    (*it1) ++;
  }
  __retres = last1;
  return_label: return __retres;
}

int *adjacent_find<int*>(int *first, int *last)
{
  int *__retres;
  int **it = & first;
  while (*it + 1 < last) {
    if (*(*it) == *(*it + 1)) {
      __retres = *it;
      goto return_label;
    }
    (*it) ++;
  }
  __retres = last;
  return_label: return __retres;
}

int *adjacent_find<int*,std::less<int>>(int *first, int *last,
                                        struct less<int> pred)
{
  int *__retres;
  int **it = & first;
  while (*it + 1 < last) {
    _Bool tmp;
    tmp = operator()((struct __bool_binop<int,std::__less> const *)(& pred._frama_c__ZN3stdE12__bool_binopIiN3stdE6__lessE),
                     (int const *)*it,(int const *)(*it + 1));
    if (tmp) {
      __retres = *it;
      goto return_label;
    }
    (*it) ++;
  }
  __retres = last;
  return_label: return __retres;
}

/*@ requires \valid_read(value); */
difference_type count<int*,int>(int *first, int *last, int const *value)
{
  difference_type c = 0;
  int **it = & first;
  while (*it < last) {
    if (*(*it) == *value) c ++;
    (*it) ++;
  }
  return c;
}

/*@ requires \valid_function(pred); */
difference_type count_if<int*,bool&,<abst>>(int *first, int *last,
                                            _Bool (*pred)(int ))
{
  difference_type c = 0;
  int **it = & first;
  while (*it < last) {
    _Bool tmp;
    tmp = (*pred)(*(*it));
    if (tmp) c ++;
    (*it) ++;
  }
  return c;
}

difference_type count_if<int*,std,iterator_traits<int*>>(int *first,
                                                         int *last,
                                                         struct UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE_ pred)
{
  difference_type c = 0;
  int **it = & first;
  while (*it < last) {
    _Bool tmp;
    tmp = (*(pred.__fc_lambda_apply))((struct UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE_ const *)(& pred),
                                      *(*it));
    if (tmp) c ++;
    (*it) ++;
  }
  return c;
}

struct pair<int*,int*> mismatch<int*,int*>(int *first1, int *last1,
                                           int *first2)
{
  struct pair<int*,int*> __retres;
  int **it1 = & first1;
  int **it2 = & first2;
  while (*it1 < last1) {
    if (*(*it1) != *(*it2)) {
      struct pair<int*,int*> __fc_tmp_7 = make_pair<int*&,int*&>(it1,it2);
      __retres = __fc_tmp_7;
      goto return_label;
    }
    (*it1) ++;
    (*it2) ++;
  }
  {
    struct pair<int*,int*> __fc_tmp_8 = make_pair<int*&,int*&>(it1,it2);
    __retres = __fc_tmp_8;
    return_label: return __retres;
  }
}

struct pair<int*,int*> mismatch<int*,int*,std::less<int>>(int *first1,
                                                          int *last1,
                                                          int *first2,
                                                          struct less<int> pred)
{
  struct pair<int*,int*> __retres;
  int **it1 = & first1;
  int **it2 = & first2;
  while (*it1 < last1) {
    _Bool tmp_0;
    tmp_0 = operator()((struct __bool_binop<int,std::__less> const *)(& pred._frama_c__ZN3stdE12__bool_binopIiN3stdE6__lessE),
                       (int const *)*it1,(int const *)*it2);
    if (! tmp_0) {
      struct pair<int*,int*> __fc_tmp_9 = make_pair<int*&,int*&>(it1,it2);
      __retres = __fc_tmp_9;
      goto return_label;
    }
    (*it1) ++;
    (*it2) ++;
  }
  {
    struct pair<int*,int*> __fc_tmp_10 = make_pair<int*&,int*&>(it1,it2);
    __retres = __fc_tmp_10;
    return_label: return __retres;
  }
}

_Bool equal<int*,int*>(int *first1, int *last1, int *first2)
{
  _Bool __retres;
  int **it1 = & first1;
  int **it2 = & first2;
  while (*it1 < last1) {
    if (*(*it1) != *(*it2)) {
      __retres = (_Bool)0;
      goto return_label;
    }
    (*it1) ++;
    (*it2) ++;
  }
  __retres = (_Bool)1;
  return_label: return __retres;
}

_Bool equal<int*,int*,std::equal_to<int>>(int *first1, int *last1,
                                          int *first2,
                                          struct equal_to<int> pred)
{
  _Bool __retres;
  int **it1 = & first1;
  int **it2 = & first2;
  while (*it1 < last1) {
    _Bool tmp;
    tmp = operator()((struct __bool_binop<int,std::__equal_to> const *)(& pred._frama_c__ZN3stdE12__bool_binopIiN3stdE10__equal_toE),
                     (int const *)*it1,(int const *)*it2);
    if (! tmp) {
      __retres = (_Bool)0;
      goto return_label;
    }
    (*it1) ++;
    (*it2) ++;
  }
  __retres = (_Bool)1;
  return_label: return __retres;
}

_Bool is_permutation<int*,int*>(int *first1, int *last1, int *first2)
{
  _Bool __retres;
  _Bool tmp;
  tmp = equal<int*,int*>(first1,last1,first2);
  if (tmp) {
    __retres = (_Bool)1;
    goto return_label;
  }
  int *last2 = first2 + (last1 - first1);
  {
    int *it1 = first1;
    while (it1 < last1) {
      {
        difference_type tmp_0;
        difference_type tmp_1;
        tmp_0 = count<int*,int>(first1,last1,(int const *)it1);
        tmp_1 = count<int*,int>(first2,last2,(int const *)it1);
        if (tmp_0 != tmp_1) {
          __retres = (_Bool)0;
          goto return_label;
        }
      }
      it1 ++;
    }
  }
  __retres = (_Bool)1;
  return_label: return __retres;
}

void UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE__cons
(struct UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE_ const *__fc_closure,
 _Bool (*__fc_func)(struct UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE_ const *,
                    value_type ),
 struct equal_to<int> pred, int *it1)
{
  __fc_closure->__fc_lambda_apply = __fc_func;
  equal_to<int>::Ctor(& __fc_closure->pred,
                      (struct equal_to<int> const *)(& pred));
  __fc_closure->it1 = it1;
  return;
}

_Bool __fc_lambda_def(struct UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE_ const *__fc_closure,
                      value_type x)
{
  _Bool tmp;
  tmp = operator()(& __fc_closure->pred._frama_c__ZN3stdE12__bool_binopIiN3stdE10__equal_toE,
                   (int const *)__fc_closure->it1,(int const *)(& x));
  return tmp;
}

_Bool is_permutation<int*,int*,std::equal_to<int>>(int *first1, int *last1,
                                                   int *first2,
                                                   struct equal_to<int> pred)
{
  _Bool __retres;
  int *last2 = first2 + (last1 - first1);
  {
    int *it1 = first1;
    while (it1 < last1) {
      {
        struct UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE_ upred;
        struct UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE_ const __fc_lam;
        difference_type tmp;
        difference_type tmp_0;
        UlN3std15iterator_traitsIPiEE10value_typeEUc4predN3stdE8equal_toIiE3it1PiE__cons
        (& __fc_lam,& __fc_lambda_def,pred,it1);
        upred = __fc_lam;
        tmp = count_if<int*,std,iterator_traits<int*>>(first1,last1,upred);
        tmp_0 = count_if<int*,std,iterator_traits<int*>>(first2,last2,upred);
        if (tmp != tmp_0) {
          __retres = (_Bool)0;
          goto return_label;
        }
      }
      it1 ++;
    }
  }
  __retres = (_Bool)1;
  return_label: return __retres;
}

int *copy<int*,int*>(int *first, int *last, int *result)
{
  {
    int *it = first;
    while (it < last) {
      *result = *it;
      result ++;
      it ++;
    }
  }
  return result;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this);
    requires \valid_read(l); */
void array<int,5>::Ctor(struct array<int,5> const *this,
                        struct initializer_list<int> const *l)
{
  size_type tmp_1;
  iterator it = begin(l);
  size_type i = (unsigned int)0;
  size_type len = size(l);
  if (len < 5U) tmp_1 = len; else tmp_1 = 5U;
  size_type end = tmp_1;
  while (i < end) {
    size_type tmp_2;
    iterator tmp_3;
    tmp_2 = i;
    i ++;
    tmp_3 = it;
    it ++;
    *((int *)(this->elems) + tmp_2) = *tmp_3;
  }
  return;
}

/*@ requires \valid(this);
    requires \valid_read(u); */
void fill(struct array<int,5> *this, int const *u);

/*@ requires \valid(this);
    requires \valid(a); */
void swap(struct array<int,5> *this, struct array<int,5> *a);

/*@ requires \valid(this); */
iterator begin(struct array<int,5> *this)
{
  iterator __retres;
  __retres = & this->elems[0];
  return __retres;
}

/*@ requires \valid_read(this); */
const_iterator begin(struct array<int,5> const *this);

/*@ requires \valid(this); */
iterator end(struct array<int,5> *this)
{
  iterator __retres;
  __retres = & this->elems[0] + 5U;
  return __retres;
}

/*@ requires \valid_read(this); */
const_iterator end(struct array<int,5> const *this);

/*@ requires \valid(this); */
reverse_iterator rbegin(struct array<int,5> *this);

/*@ requires \valid_read(this); */
const_reverse_iterator rbegin(struct array<int,5> const *this);

/*@ requires \valid(this); */
reverse_iterator rend(struct array<int,5> *this);

/*@ requires \valid_read(this); */
const_reverse_iterator rend(struct array<int,5> const *this);

/*@ requires \valid_read(this); */
const_iterator cbegin(struct array<int,5> const *this);

/*@ requires \valid_read(this); */
const_iterator cend(struct array<int,5> const *this);

/*@ requires \valid_read(this); */
const_reverse_iterator crbegin(struct array<int,5> const *this);

/*@ requires \valid_read(this); */
const_reverse_iterator crend(struct array<int,5> const *this);

/*@ requires \valid_read(this); */
size_type size(struct array<int,5> const *this);

/*@ requires \valid_read(this); */
size_type max_size(struct array<int,5> const *this);

/*@ requires \valid_read(this); */
_Bool empty(struct array<int,5> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference operator[](struct array<int,5> *this, size_type n);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference operator[](struct array<int,5> const *this, size_type n);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference at(struct array<int,5> const *this, size_type n);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference at(struct array<int,5> *this, size_type n);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference front(struct array<int,5> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference front(struct array<int,5> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference back(struct array<int,5> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference back(struct array<int,5> const *this);

/*@ requires \valid(this); */
int *data(struct array<int,5> *this);

/*@ requires \valid_read(this); */
int const *data(struct array<int,5> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "array",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this);
    requires \valid_read(l); */
void array<int,2>::Ctor(struct array<int,2> const *this,
                        struct initializer_list<int> const *l)
{
  size_type tmp_1;
  iterator it = begin(l);
  size_type i = (unsigned int)0;
  size_type len = size(l);
  if (len < 2U) tmp_1 = len; else tmp_1 = 2U;
  size_type end = tmp_1;
  while (i < end) {
    size_type tmp_2;
    iterator tmp_3;
    tmp_2 = i;
    i ++;
    tmp_3 = it;
    it ++;
    *((int *)(this->elems) + tmp_2) = *tmp_3;
  }
  return;
}

/*@ requires \valid(this);
    requires \valid_read(u); */
void fill(struct array<int,2> *this, int const *u);

/*@ requires \valid(this);
    requires \valid(a); */
void swap(struct array<int,2> *this, struct array<int,2> *a);

/*@ requires \valid(this); */
iterator begin(struct array<int,2> *this)
{
  iterator __retres;
  __retres = & this->elems[0];
  return __retres;
}

/*@ requires \valid_read(this); */
const_iterator begin(struct array<int,2> const *this);

/*@ requires \valid(this); */
iterator end(struct array<int,2> *this)
{
  iterator __retres;
  __retres = & this->elems[0] + 2U;
  return __retres;
}

/*@ requires \valid_read(this); */
const_iterator end(struct array<int,2> const *this);

/*@ requires \valid(this); */
reverse_iterator rbegin(struct array<int,2> *this);

/*@ requires \valid_read(this); */
const_reverse_iterator rbegin(struct array<int,2> const *this);

/*@ requires \valid(this); */
reverse_iterator rend(struct array<int,2> *this);

/*@ requires \valid_read(this); */
const_reverse_iterator rend(struct array<int,2> const *this);

/*@ requires \valid_read(this); */
const_iterator cbegin(struct array<int,2> const *this);

/*@ requires \valid_read(this); */
const_iterator cend(struct array<int,2> const *this);

/*@ requires \valid_read(this); */
const_reverse_iterator crbegin(struct array<int,2> const *this);

/*@ requires \valid_read(this); */
const_reverse_iterator crend(struct array<int,2> const *this);

/*@ requires \valid_read(this); */
size_type size(struct array<int,2> const *this);

/*@ requires \valid_read(this); */
size_type max_size(struct array<int,2> const *this);

/*@ requires \valid_read(this); */
_Bool empty(struct array<int,2> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference operator[](struct array<int,2> *this, size_type n);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference operator[](struct array<int,2> const *this, size_type n);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference at(struct array<int,2> const *this, size_type n);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference at(struct array<int,2> *this, size_type n);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference front(struct array<int,2> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference front(struct array<int,2> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference back(struct array<int,2> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference back(struct array<int,2> const *this);

/*@ requires \valid(this); */
int *data(struct array<int,2> *this);

/*@ requires \valid_read(this); */
int const *data(struct array<int,2> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "array",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct array<int,5> a;
void __fc_init_Z1a(void) __attribute__((__constructor__));
void __fc_init_Z1a(void)
{
  int const init_array[5UL] = {0, 1, 2, 3, 4};
  struct initializer_list<int> init_list;
  initializer_list<int>::Ctor(& init_list,init_array,(unsigned int)5);
  array<int,5>::Ctor((struct array<int,5> const *)(& a),
                     (struct initializer_list<int> const *)(& init_list));
  return;
}

struct array<int,2> search;
void __fc_init_Z6search(void) __attribute__((__constructor__));
void __fc_init_Z6search(void)
{
  int const init_array[2UL] = {2, 3};
  struct initializer_list<int> init_list;
  initializer_list<int>::Ctor(& init_list,init_array,(unsigned int)2);
  array<int,2>::Ctor((struct array<int,2> const *)(& search),
                     (struct initializer_list<int> const *)(& init_list));
  return;
}

struct array<int,5> b;
void __fc_init_Z1b(void) __attribute__((__constructor__));
void __fc_init_Z1b(void)
{
  int const init_array[5UL] = {5, 6, 7, 8, 9};
  struct initializer_list<int> init_list;
  initializer_list<int>::Ctor(& init_list,init_array,(unsigned int)5);
  array<int,5>::Ctor((struct array<int,5> const *)(& b),
                     (struct initializer_list<int> const *)(& init_list));
  return;
}

_Bool positive(int x)
{
  _Bool __retres;
  __retres = (_Bool)(x > 0);
  return __retres;
}

void ignore(int x)
{
  return;
}

int main(void)
{
  _Bool tmp_1;
  iterator tmp;
  iterator tmp_0;
  _Bool tmp_4;
  iterator tmp_2;
  iterator tmp_3;
  _Bool tmp_7;
  iterator tmp_5;
  iterator tmp_6;
  iterator tmp_8;
  iterator tmp_9;
  int *tmp_16;
  iterator tmp_14;
  iterator tmp_15;
  iterator tmp_17;
  int *tmp_20;
  iterator tmp_18;
  iterator tmp_19;
  iterator tmp_21;
  int *tmp_26;
  iterator tmp_22;
  iterator tmp_23;
  iterator tmp_24;
  iterator tmp_25;
  iterator tmp_27;
  int *tmp_38;
  iterator tmp_34;
  iterator tmp_35;
  iterator tmp_36;
  iterator tmp_37;
  iterator tmp_39;
  int *tmp_48;
  iterator tmp_46;
  iterator tmp_47;
  iterator tmp_49;
  difference_type tmp_59;
  iterator tmp_57;
  iterator tmp_58;
  _Bool tmp_73;
  iterator tmp_70;
  iterator tmp_71;
  iterator tmp_72;
  _Bool tmp_80;
  iterator tmp_77;
  iterator tmp_78;
  iterator tmp_79;
  iterator tmp_84;
  iterator tmp_85;
  iterator tmp_86;
  int res = 0;
  tmp = end(& a);
  tmp_0 = begin(& a);
  tmp_1 = all_of<int*,bool&,<abst>>(tmp_0,tmp,& positive);
  if (tmp_1) res ++;
  tmp_2 = end(& a);
  tmp_3 = begin(& a);
  tmp_4 = any_of<int*,bool&,<abst>>(tmp_3,tmp_2,& positive);
  if (tmp_4) res ++;
  tmp_5 = end(& a);
  tmp_6 = begin(& a);
  tmp_7 = none_of<int*,bool*,<abst>>(tmp_6,tmp_5,& positive);
  if (tmp_7) res ++;
  tmp_8 = end(& a);
  tmp_9 = begin(& a);
  for_each<int*,void*,<abst>>(tmp_9,tmp_8,& ignore);
  {
    _Bool __fc_tmp_11;
    int *tmp_12;
    iterator tmp_10;
    iterator tmp_11;
    iterator tmp_13;
    int const __clang_tmp_16 = 3;
    tmp_10 = end(& a);
    tmp_11 = begin(& a);
    tmp_12 = find<int*,int>(tmp_11,tmp_10,& __clang_tmp_16);
    tmp_13 = end(& a);
    __fc_tmp_11 = (_Bool)(tmp_12 != tmp_13);
    if (__fc_tmp_11) res ++;
  }
  tmp_14 = end(& a);
  tmp_15 = begin(& a);
  tmp_16 = find_if<int*,bool&,<abst>>(tmp_15,tmp_14,& positive);
  tmp_17 = end(& a);
  if (tmp_16 != tmp_17) res ++;
  tmp_18 = end(& a);
  tmp_19 = begin(& a);
  tmp_20 = find_if_not<int*,bool&,<abst>>(tmp_19,tmp_18,& positive);
  tmp_21 = end(& a);
  if (tmp_20 != tmp_21) res ++;
  tmp_22 = end(& search);
  tmp_23 = begin(& search);
  tmp_24 = end(& a);
  tmp_25 = begin(& a);
  tmp_26 = find_end<int*,int*>(tmp_25,tmp_24,tmp_23,tmp_22);
  tmp_27 = end(& a);
  if (tmp_26 != tmp_27) res ++;
  {
    _Bool __fc_tmp_13;
    int *tmp_32;
    iterator tmp_28;
    iterator tmp_29;
    iterator tmp_30;
    iterator tmp_31;
    iterator tmp_33;
    struct less<int> __fc_tmp_12;
    less<int>::Ctor(& __fc_tmp_12);
    ;
    tmp_28 = end(& search);
    tmp_29 = begin(& search);
    tmp_30 = end(& a);
    tmp_31 = begin(& a);
    tmp_32 = find_end<int*,int*,std::less<int>>(tmp_31,tmp_30,tmp_29,tmp_28,
                                                __fc_tmp_12);
    tmp_33 = end(& a);
    __fc_tmp_13 = (_Bool)(tmp_32 != tmp_33);
    if (__fc_tmp_13) res ++;
    less<int>::Dtor((struct less<int> const *)(& __fc_tmp_12));
  }
  tmp_34 = end(& search);
  tmp_35 = begin(& search);
  tmp_36 = end(& a);
  tmp_37 = begin(& a);
  tmp_38 = find_first_of<int*,int*>(tmp_37,tmp_36,tmp_35,tmp_34);
  tmp_39 = end(& a);
  if (tmp_38 != tmp_39) res ++;
  {
    _Bool __fc_tmp_15;
    int *tmp_44;
    iterator tmp_40;
    iterator tmp_41;
    iterator tmp_42;
    iterator tmp_43;
    iterator tmp_45;
    struct less<int> __fc_tmp_14;
    less<int>::Ctor(& __fc_tmp_14);
    ;
    tmp_40 = end(& search);
    tmp_41 = begin(& search);
    tmp_42 = end(& a);
    tmp_43 = begin(& a);
    tmp_44 = find_first_of<int*,int*,std::less<int>>(tmp_43,tmp_42,tmp_41,
                                                     tmp_40,__fc_tmp_14);
    tmp_45 = end(& a);
    __fc_tmp_15 = (_Bool)(tmp_44 != tmp_45);
    if (__fc_tmp_15) res ++;
    less<int>::Dtor((struct less<int> const *)(& __fc_tmp_14));
  }
  tmp_46 = end(& a);
  tmp_47 = begin(& a);
  tmp_48 = adjacent_find<int*>(tmp_47,tmp_46);
  tmp_49 = end(& a);
  if (tmp_48 == tmp_49) res ++;
  {
    _Bool __fc_tmp_17;
    int *tmp_52;
    iterator tmp_50;
    iterator tmp_51;
    iterator tmp_53;
    struct less<int> __fc_tmp_16;
    less<int>::Ctor(& __fc_tmp_16);
    ;
    tmp_50 = end(& a);
    tmp_51 = begin(& a);
    tmp_52 = adjacent_find<int*,std::less<int>>(tmp_51,tmp_50,__fc_tmp_16);
    tmp_53 = end(& a);
    __fc_tmp_17 = (_Bool)(tmp_52 != tmp_53);
    if (__fc_tmp_17) res ++;
    less<int>::Dtor((struct less<int> const *)(& __fc_tmp_16));
  }
  {
    _Bool __fc_tmp_18;
    difference_type tmp_56;
    iterator tmp_54;
    iterator tmp_55;
    int const __clang_tmp_20 = 3;
    tmp_54 = end(& a);
    tmp_55 = begin(& a);
    tmp_56 = count<int*,int>(tmp_55,tmp_54,& __clang_tmp_20);
    __fc_tmp_18 = (_Bool)(tmp_56 == 1);
    if (__fc_tmp_18) res ++;
  }
  tmp_57 = end(& a);
  tmp_58 = begin(& a);
  tmp_59 = count_if<int*,bool&,<abst>>(tmp_58,tmp_57,& positive);
  if (tmp_59 == 4) res ++;
  {
    struct pair<int*,int*> rm;
    struct pair<int*,int*> tmp_63;
    iterator tmp_62;
    int *sb = begin(& search);
    int *ab = begin(& a);
    ;
    tmp_62 = end(& search);
    ;
    tmp_63 = mismatch<int*,int*>(sb,tmp_62,ab);
    struct pair<int*,int*> __fc_tmp_19 = tmp_63;
    rm = __fc_tmp_19;
    if (rm.first == sb) 
      if (rm.second == ab) res ++;
    pair<int*,int*>::Dtor((struct pair<int*,int*> const *)(& __fc_tmp_19));
    pair<int*,int*>::Dtor((struct pair<int*,int*> const *)(& rm));
  }
  {
    struct pair<int*,int*> rm_0;
    struct pair<int*,int*> tmp_69;
    iterator tmp_66;
    iterator tmp_67;
    iterator tmp_68;
    int *sb_0 = begin(& search);
    int *ab_0 = begin(& a);
    struct less<int> __fc_tmp_20;
    less<int>::Ctor(& __fc_tmp_20);
    ;
    tmp_66 = begin(& a);
    tmp_67 = end(& search);
    tmp_68 = begin(& search);
    tmp_69 = mismatch<int*,int*,std::less<int>>(tmp_68,tmp_67,tmp_66,
                                                __fc_tmp_20);
    struct pair<int*,int*> __fc_tmp_21 = tmp_69;
    rm_0 = __fc_tmp_21;
    if (rm_0.first == sb_0) 
      if (rm_0.second == ab_0) res ++;
    pair<int*,int*>::Dtor((struct pair<int*,int*> const *)(& __fc_tmp_21));
    less<int>::Dtor((struct less<int> const *)(& __fc_tmp_20));
    pair<int*,int*>::Dtor((struct pair<int*,int*> const *)(& rm_0));
  }
  tmp_70 = begin(& a);
  tmp_71 = end(& a);
  tmp_72 = begin(& a);
  tmp_73 = equal<int*,int*>(tmp_72,tmp_71,tmp_70);
  if (tmp_73) res ++;
  {
    _Bool __fc_tmp_23;
    iterator tmp_74;
    iterator tmp_75;
    iterator tmp_76;
    struct equal_to<int> __fc_tmp_22;
    equal_to<int>::Ctor(& __fc_tmp_22);
    ;
    tmp_74 = begin(& a);
    tmp_75 = end(& a);
    tmp_76 = begin(& a);
    __fc_tmp_23 = equal<int*,int*,std::equal_to<int>>(tmp_76,tmp_75,tmp_74,
                                                      __fc_tmp_22);
    if (__fc_tmp_23) res ++;
    equal_to<int>::Dtor((struct equal_to<int> const *)(& __fc_tmp_22));
  }
  tmp_77 = begin(& a);
  tmp_78 = end(& a);
  tmp_79 = begin(& a);
  tmp_80 = is_permutation<int*,int*>(tmp_79,tmp_78,tmp_77);
  if (tmp_80) res ++;
  {
    _Bool __fc_tmp_25;
    iterator tmp_81;
    iterator tmp_82;
    iterator tmp_83;
    struct equal_to<int> __fc_tmp_24;
    equal_to<int>::Ctor(& __fc_tmp_24);
    ;
    tmp_81 = begin(& a);
    tmp_82 = end(& a);
    tmp_83 = begin(& a);
    __fc_tmp_25 = is_permutation<int*,int*,std::equal_to<int>>(tmp_83,tmp_82,
                                                               tmp_81,
                                                               __fc_tmp_24);
    if (__fc_tmp_25) res ++;
    equal_to<int>::Dtor((struct equal_to<int> const *)(& __fc_tmp_24));
  }
  struct initializer_list<int> const __clang_tmp_26;
  initializer_list<int>::Ctor(& __clang_tmp_26);
  struct array<int,5> dest;
  array<int,5>::Ctor(& dest,& __clang_tmp_26);
  tmp_84 = begin(& dest);
  tmp_85 = end(& a);
  tmp_86 = begin(& a);
  copy<int*,int*>(tmp_86,tmp_85,tmp_84);
  initializer_list<int>::Dtor(& __clang_tmp_26);
  return res;
}


