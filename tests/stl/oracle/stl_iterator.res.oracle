[kernel] Parsing tests/stl/stl_iterator.cpp (external front-end)
Now output intermediate result
[kernel] Warning: Assuming declared function initializer_list<int>::Ctor can't throw any exception
/* Generated by Frama-C */
struct _frama_c_vmt_content {
   void (*method_ptr)() ;
   int shift_this ;
};
struct _frama_c_rtti_name_info_node;
struct _frama_c_vmt {
   struct _frama_c_vmt_content *table ;
   int table_size ;
   struct _frama_c_rtti_name_info_node *rtti_info ;
};
struct _frama_c_rtti_name_info_content {
   struct _frama_c_rtti_name_info_node *value ;
   int shift_object ;
   int shift_vmt ;
};
struct _frama_c_rtti_name_info_node {
   char const *name ;
   struct _frama_c_rtti_name_info_content *base_classes ;
   int number_of_base_classes ;
   struct _frama_c_vmt *pvmt ;
};
typedef unsigned int size_t;
typedef size_t size_t;
typedef _Bool value_type;
struct integral_constant<bool,0>;
struct integral_constant<bool,0> {
   
};
typedef _Bool value_type;
struct integral_constant<bool,1>;
struct integral_constant<bool,1> {
   
};
typedef int const *iterator;
struct initializer_list<int> {
   int const *base ;
   size_t length ;
};
struct piecewise_construct_t;
struct piecewise_construct_t {
   
};
typedef int const *pointer;
typedef int const *reference;
struct iterator<std::random_access_iterator_tag,int,int,int*,int&> {
   
};
struct reverse_iterator<int*>;
typedef int const *iterator_type;
typedef reference reference;
typedef pointer pointer;
struct reverse_iterator<int*> {
   struct iterator<std::random_access_iterator_tag,int,int,int*,int&> _frama_c__ZN3stdE8iteratorIN3stdE26random_access_iterator_tagiiPKiRKiE ;
   iterator_type current ;
   iterator_type deref_tmp ;
};
typedef int *reference;
typedef int const *const_reference;
typedef int *iterator;
typedef int const *const_iterator;
typedef size_t size_type;
typedef struct reverse_iterator<int*> reverse_iterator;
typedef struct reverse_iterator<int*> const_reverse_iterator;
struct array<int,4> {
   int elems[4] ;
};
typedef int *reference;
typedef int const *const_reference;
typedef int *iterator;
typedef int const *const_iterator;
typedef size_t size_type;
typedef struct reverse_iterator<int*> reverse_iterator;
typedef struct reverse_iterator<int*> const_reverse_iterator;
struct array<int,2> {
   int elems[2] ;
};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
_Bool const value;
/*@ requires \valid_read(this); */
value_type value_type)(struct integral_constant<bool,0> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "integral_constant",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
_Bool const value;
/*@ requires \valid_read(this); */
value_type value_type)(struct integral_constant<bool,1> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "integral_constant",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];
struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__boolean",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];
struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__boolean",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];
struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "_is_void",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "ok_type",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "ko_type",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];
struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_convertible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "enable_if",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void initializer_list<int>::Dtor(struct initializer_list<int> const *this);

struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this); */
void initializer_list<int>::Ctor(struct initializer_list<int> const *this)
{
  this->base = (int const *)0;
  this->length = (unsigned int)0;
  return;
}

/*@ requires \valid_read(this); */
void initializer_list<int>::Ctor(struct initializer_list<int> const *this,
                                 int const *b, size_t s);

/*@ requires \valid_read(this); */
size_t size(struct initializer_list<int> const *this)
{
  size_t __retres;
  __retres = this->length;
  return __retres;
}

/*@ requires \valid_read(this); */
int const *begin(struct initializer_list<int> const *this)
{
  int const *__retres;
  __retres = this->base;
  return __retres;
}

/*@ requires \valid_read(this); */
int const *end(struct initializer_list<int> const *this);

/*@ requires \valid_read(this); */
void initializer_list<int>::Dtor(struct initializer_list<int> const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "initializer_list",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void piecewise_construct_t::Ctor(struct piecewise_construct_t const *this);

void piecewise_construct_t::Dtor(struct piecewise_construct_t const *this);

struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this); */
void piecewise_construct_t::Ctor(struct piecewise_construct_t const *this)
{
  return;
}

/*@ requires \valid_read(this); */
void piecewise_construct_t::Dtor(struct piecewise_construct_t const *this)
{
  return;
}

struct piecewise_construct_t piecewise_construct;
void __fc_init_ZN3stdE19piecewise_construct(void) __attribute__((__constructor__));
void __fc_init_ZN3stdE19piecewise_construct(void)
{
  struct piecewise_construct_t __fc_tmp_0;
  piecewise_construct_t::Ctor(& __fc_tmp_0);
  piecewise_construct = __fc_tmp_0;
  piecewise_construct_t::Dtor((struct piecewise_construct_t const *)(& __fc_tmp_0));
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "piecewise_construct_t",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];
struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];
struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];
struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "input_iterator_tag",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "output_iterator_tag",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "forward_iterator_tag",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "bidirectional_iterator_tag",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "random_access_iterator_tag",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "iterator_traits",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "iterator",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void iterator<std::random_access_iterator_tag,int,int,int*,int&>::Ctor
(struct iterator<std::random_access_iterator_tag,int,int,int*,int&> const *this);

void iterator<std::random_access_iterator_tag,int,int,int*,int&>::Ctor
(struct iterator<std::random_access_iterator_tag,int,int,int*,int&> const *this,
 struct iterator<std::random_access_iterator_tag,int,int,int*,int&> const *__frama_c_arg_0);

void iterator<std::random_access_iterator_tag,int,int,int*,int&>::Dtor
(struct iterator<std::random_access_iterator_tag,int,int,int*,int&> const *this);

struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this); */
void iterator<std::random_access_iterator_tag,int,int,int*,int&>::Dtor
(struct iterator<std::random_access_iterator_tag,int,int,int*,int&> const *this)
{
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void iterator<std::random_access_iterator_tag,int,int,int*,int&>::Ctor
(struct iterator<std::random_access_iterator_tag,int,int,int*,int&> const *this,
 struct iterator<std::random_access_iterator_tag,int,int,int*,int&> const *__frama_c_arg_0)
{
  return;
}

/*@ requires \valid_read(this); */
void iterator<std::random_access_iterator_tag,int,int,int*,int&>::Ctor
(struct iterator<std::random_access_iterator_tag,int,int,int*,int&> const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "iterator",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void reverse_iterator<int*>::Ctor(struct reverse_iterator<int*> const *this,
                                  struct reverse_iterator<int*> const *__frama_c_arg_0);

void reverse_iterator<int*>::Dtor(struct reverse_iterator<int*> const *this);

struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];
struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this); */
void reverse_iterator<int*>::Ctor(struct reverse_iterator<int*> const *this);

/*@ requires \valid_read(this); */
void reverse_iterator<int*>::Ctor(struct reverse_iterator<int*> const *this,
                                  int const *x)
{
  iterator<std::random_access_iterator_tag,int,int,int*,int&>::Ctor(& this->_frama_c__ZN3stdE8iteratorIN3stdE26random_access_iterator_tagiiPKiRKiE);
  this->current = x;
  this->deref_tmp = x;
  return;
}

/*@ requires \valid_read(this); */
int const *base(struct reverse_iterator<int*> const *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
reference operator*(struct reverse_iterator<int*> const *this)
{
  reference __retres;
  this->deref_tmp = this->current;
  (this->deref_tmp) --;
  __retres = this->deref_tmp;
  return __retres;
}

/*@ requires \valid_read(this); */
pointer std::reverse_iterator<int*>::operator->(struct reverse_iterator<int*> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
struct reverse_iterator<int*> *operator++(struct reverse_iterator<int*> *this);

struct reverse_iterator<int*> operator++(struct reverse_iterator<int*> *this,
                                         int __frama_c_arg_0);

/*@ requires \valid(this);
    ensures \valid(\result); */
struct reverse_iterator<int*> *operator--(struct reverse_iterator<int*> *this);

/*@ requires \valid(this); */
struct reverse_iterator<int*> operator--(struct reverse_iterator<int*> *this,
                                         int __frama_c_arg_0);

/*@ requires \valid(this);
    requires \valid_read(y); */
_Bool operator<<int*,void>(struct reverse_iterator<int*> *this,
                           struct reverse_iterator<int*> const *y)
{
  _Bool __retres;
  __retres = (_Bool)(this->current < y->current);
  return __retres;
}

/*@ requires \valid_read(this); */
void reverse_iterator<int*>::Dtor(struct reverse_iterator<int*> const *this)
{
  iterator<std::random_access_iterator_tag,int,int,int*,int&>::Dtor(& this->_frama_c__ZN3stdE8iteratorIN3stdE26random_access_iterator_tagiiPKiRKiE);
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void reverse_iterator<int*>::Ctor(struct reverse_iterator<int*> const *this,
                                  struct reverse_iterator<int*> const *__frama_c_arg_0)
{
  iterator<std::random_access_iterator_tag,int,int,int*,int&>::Ctor(& this->_frama_c__ZN3stdE8iteratorIN3stdE26random_access_iterator_tagiiPKiRKiE,
                                                                    & __frama_c_arg_0->_frama_c__ZN3stdE8iteratorIN3stdE26random_access_iterator_tagiiPKiRKiE);
  this->current = __frama_c_arg_0->current;
  this->deref_tmp = __frama_c_arg_0->deref_tmp;
  return;
}

/*@ requires \valid(this); */
struct reverse_iterator<int*> operator++(struct reverse_iterator<int*> *this,
                                         int __frama_c_arg_0)
{
  struct reverse_iterator<int*> tmp;
  reverse_iterator<int*>::Ctor(& tmp,
                               (struct reverse_iterator<int*> const *)this);
  (this->current) --;
  reverse_iterator<int*>::Dtor((struct reverse_iterator<int*> const *)(& tmp));
  return tmp;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "reverse_iterator",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@ requires \valid_read(y);
    requires \valid_read(x); */
_Bool operator<<int*,int*>(struct reverse_iterator<int*> const *x,
                           struct reverse_iterator<int*> const *y);

struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this);
    requires \valid_read(l); */
void array<int,4>::Ctor(struct array<int,4> const *this,
                        struct initializer_list<int> const *l)
{
  size_type tmp_1;
  iterator it = begin(l);
  size_type i = (unsigned int)0;
  size_type len = size(l);
  if (len < 4U) tmp_1 = len; else tmp_1 = 4U;
  size_type end = tmp_1;
  while (i < end) {
    size_type tmp_2;
    iterator tmp_3;
    tmp_2 = i;
    i ++;
    tmp_3 = it;
    it ++;
    *((int *)(this->elems) + tmp_2) = *tmp_3;
  }
  return;
}

/*@ requires \valid(this);
    requires \valid_read(u); */
void fill(struct array<int,4> *this, int const *u);

/*@ requires \valid(this);
    requires \valid(a); */
void swap(struct array<int,4> *this, struct array<int,4> *a);

/*@ requires \valid(this); */
iterator begin(struct array<int,4> *this)
{
  iterator __retres;
  __retres = & this->elems[0];
  return __retres;
}

/*@ requires \valid_read(this); */
const_iterator begin(struct array<int,4> const *this);

/*@ requires \valid(this); */
iterator end(struct array<int,4> *this)
{
  iterator __retres;
  __retres = & this->elems[0] + 4U;
  return __retres;
}

/*@ requires \valid_read(this); */
const_iterator end(struct array<int,4> const *this);

/*@ requires \valid(this); */
reverse_iterator rbegin(struct array<int,4> *this);

/*@ requires \valid_read(this); */
const_reverse_iterator rbegin(struct array<int,4> const *this);

/*@ requires \valid(this); */
reverse_iterator rend(struct array<int,4> *this);

/*@ requires \valid_read(this); */
const_reverse_iterator rend(struct array<int,4> const *this);

/*@ requires \valid_read(this); */
const_iterator cbegin(struct array<int,4> const *this);

/*@ requires \valid_read(this); */
const_iterator cend(struct array<int,4> const *this);

/*@ requires \valid_read(this); */
const_reverse_iterator crbegin(struct array<int,4> const *this);

/*@ requires \valid_read(this); */
const_reverse_iterator crend(struct array<int,4> const *this);

/*@ requires \valid_read(this); */
size_type size(struct array<int,4> const *this);

/*@ requires \valid_read(this); */
size_type max_size(struct array<int,4> const *this);

/*@ requires \valid_read(this); */
_Bool empty(struct array<int,4> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference operator[](struct array<int,4> *this, size_type n)
{
  reference __retres;
  __retres = & this->elems[n];
  return __retres;
}

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference operator[](struct array<int,4> const *this, size_type n);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference at(struct array<int,4> const *this, size_type n);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference at(struct array<int,4> *this, size_type n);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference front(struct array<int,4> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference front(struct array<int,4> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference back(struct array<int,4> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference back(struct array<int,4> const *this);

/*@ requires \valid(this); */
int *data(struct array<int,4> *this);

/*@ requires \valid_read(this); */
int const *data(struct array<int,4> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "array",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this);
    requires \valid_read(l); */
void array<int,2>::Ctor(struct array<int,2> const *this,
                        struct initializer_list<int> const *l)
{
  size_type tmp_1;
  iterator it = begin(l);
  size_type i = (unsigned int)0;
  size_type len = size(l);
  if (len < 2U) tmp_1 = len; else tmp_1 = 2U;
  size_type end = tmp_1;
  while (i < end) {
    size_type tmp_2;
    iterator tmp_3;
    tmp_2 = i;
    i ++;
    tmp_3 = it;
    it ++;
    *((int *)(this->elems) + tmp_2) = *tmp_3;
  }
  return;
}

/*@ requires \valid(this);
    requires \valid_read(u); */
void fill(struct array<int,2> *this, int const *u);

/*@ requires \valid(this);
    requires \valid(a); */
void swap(struct array<int,2> *this, struct array<int,2> *a);

/*@ requires \valid(this); */
iterator begin(struct array<int,2> *this);

/*@ requires \valid_read(this); */
const_iterator begin(struct array<int,2> const *this);

/*@ requires \valid(this); */
iterator end(struct array<int,2> *this);

/*@ requires \valid_read(this); */
const_iterator end(struct array<int,2> const *this);

/*@ requires \valid(this); */
reverse_iterator rbegin(struct array<int,2> *this);

/*@ requires \valid_read(this); */
const_reverse_iterator rbegin(struct array<int,2> const *this);

/*@ requires \valid(this); */
reverse_iterator rend(struct array<int,2> *this);

/*@ requires \valid_read(this); */
const_reverse_iterator rend(struct array<int,2> const *this);

/*@ requires \valid_read(this); */
const_iterator cbegin(struct array<int,2> const *this)
{
  const_iterator __retres;
  __retres = & this->elems[0];
  return __retres;
}

/*@ requires \valid_read(this); */
const_iterator cend(struct array<int,2> const *this)
{
  const_iterator __retres;
  __retres = & this->elems[0] + 2U;
  return __retres;
}

/*@ requires \valid_read(this); */
const_reverse_iterator crbegin(struct array<int,2> const *this)
{
  const_iterator tmp;
  tmp = cend(this);
  const_reverse_iterator __fc_tmp_1;
  reverse_iterator<int*>::Ctor(& __fc_tmp_1,tmp);
  return __fc_tmp_1;
}

/*@ requires \valid_read(this); */
const_reverse_iterator crend(struct array<int,2> const *this)
{
  const_iterator tmp;
  tmp = cbegin(this);
  const_reverse_iterator __fc_tmp_2;
  reverse_iterator<int*>::Ctor(& __fc_tmp_2,tmp);
  return __fc_tmp_2;
}

/*@ requires \valid_read(this); */
size_type size(struct array<int,2> const *this);

/*@ requires \valid_read(this); */
size_type max_size(struct array<int,2> const *this);

/*@ requires \valid_read(this); */
_Bool empty(struct array<int,2> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference operator[](struct array<int,2> *this, size_type n)
{
  reference __retres;
  __retres = & this->elems[n];
  return __retres;
}

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference operator[](struct array<int,2> const *this, size_type n);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference at(struct array<int,2> const *this, size_type n);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference at(struct array<int,2> *this, size_type n)
{
  reference __retres;
  __retres = & this->elems[n];
  return __retres;
}

/*@ requires \valid(this);
    ensures \valid(\result); */
reference front(struct array<int,2> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference front(struct array<int,2> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
reference back(struct array<int,2> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
const_reference back(struct array<int,2> const *this);

/*@ requires \valid(this); */
int *data(struct array<int,2> *this);

/*@ requires \valid_read(this); */
int const *data(struct array<int,2> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "array",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@ requires \valid(a);
    ensures \valid(\result); */
int *get<3,int,4>(struct array<int,4> *a)
{
  int *tmp;
  tmp = operator[](a,3U);
  return tmp;
}

/*@ requires \valid_read(a);
    ensures \valid_read(\result); */
int const *get<3,int,4>(struct array<int,4> const *a);

int main(void)
{
  int __retres;
  int *tmp;
  reference tmp_0;
  reference tmp_1;
  int const init_array[4UL] = {0, 1, 2, 3};
  struct initializer_list<int> init_list;
  initializer_list<int>::Ctor(& init_list,init_array,(unsigned int)4);
  struct array<int,4> A;
  array<int,4>::Ctor(& A,(struct initializer_list<int> const *)(& init_list));
  struct initializer_list<int> const __clang_tmp_4;
  initializer_list<int>::Ctor(& __clang_tmp_4);
  struct array<int,2> B;
  array<int,2>::Ctor(& B,& __clang_tmp_4);
  tmp = get<3,int,4>(& A);
  int x = *tmp;
  tmp_0 = operator[](& B,(unsigned int)1);
  *tmp_0 = 42;
  tmp_1 = at(& B,(unsigned int)0);
  *tmp_1 = 36;
  {
    iterator it = begin(& A);
    iterator end = end(& A);
    while (it < end) {
      (*it) ++;
      it ++;
    }
  }
  {
    const_reverse_iterator it_0;
    const_reverse_iterator end_0;
    const_reverse_iterator __fc_tmp_3 =
      crbegin((struct array<int,2> const *)(& B));
    it_0 = __fc_tmp_3;
    const_reverse_iterator __fc_tmp_4 =
      crend((struct array<int,2> const *)(& B));
    end_0 = __fc_tmp_4;
    int res = 0;
    while (1) {
      _Bool tmp_8;
      reference tmp_7;
      tmp_8 = operator<<int*,void>(& it_0,
                                   (struct reverse_iterator<int*> const *)(& end_0));
      if (! tmp_8) break;
      tmp_7 = operator*((struct reverse_iterator<int*> const *)(& it_0));
      res += *tmp_7;
      {
        struct reverse_iterator<int*> __fc_tmp_5 = operator++(& it_0,0);
        reverse_iterator<int*>::Dtor((struct reverse_iterator<int*> const *)(& __fc_tmp_5));
      }
    }
    ;
    reverse_iterator<int*>::Dtor((struct reverse_iterator<int*> const *)(& __fc_tmp_4));
    reverse_iterator<int*>::Dtor((struct reverse_iterator<int*> const *)(& end_0));
    reverse_iterator<int*>::Dtor((struct reverse_iterator<int*> const *)(& __fc_tmp_3));
    reverse_iterator<int*>::Dtor((struct reverse_iterator<int*> const *)(& it_0));
  }
  __retres = 0;
  initializer_list<int>::Dtor(& __clang_tmp_4);
  return __retres;
}


