[kernel] Parsing tests/stl/stl_unique_ptr.cpp (external front-end)
Now output intermediate result
[kernel:typing:implicit-conv-void-ptr] tests/stl/stl_unique_ptr.cpp:9: Warning: 
  implicit conversion from void * to int *
[kernel:typing:implicit-conv-void-ptr] tests/stl/stl_unique_ptr.cpp:15: Warning: 
  implicit conversion from void * to int *
[kernel] Warning: Assuming declared function exception::Dtor can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function exception::Ctor can't throw any exception
[kernel] Warning: Assuming declared function exception::Dtor can't throw any exception
[kernel] Warning: Assuming declared function malloc can't throw any exception
[kernel] Warning: Assuming declared function malloc can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function malloc can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function malloc can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel:annot:missing-spec] tests/stl/stl_unique_ptr.cpp:105: Warning: 
  Neither code nor specification for function malloc, generating default assigns from the prototype
[kernel:annot:missing-spec] tests/stl/stl_unique_ptr.cpp:105: Warning: 
  Neither code nor specification for function free, generating default assigns from the prototype
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  _frama_c_rtti_name_info.name ∈ {{ "integral_constant" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "integral_constant" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "__boolean" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "__boolean" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "_is_void" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "ok_type" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "ko_type" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "is_convertible" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "is_convertible" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "is_convertible" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "is_convertible" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "is_convertible" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "is_convertible" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "remove_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "add_lvalue_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "add_lvalue_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "add_lvalue_reference" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "enable_if" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "piecewise_construct_t" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  __fc_heap_status ∈ {0}
  __fc_strtok_ptr ∈ {0}
  __fc_strerror[0..63] ∈ {0}
  __fc_p_strerror ∈ {{ &__fc_strerror[0] }}
  __fc_strsignal[0..63] ∈ {0}
  __fc_p_strsignal ∈ {{ &__fc_strsignal[0] }}
  _frama_c_vmt_header.table ∈ {{ &_frama_c_vmt[0] }}
                     .table_size ∈ {2}
                     .rtti_info ∈ {{ &_frama_c_rtti_name_info }}
  _frama_c_rtti_name_info.name ∈ {{ "exception" }}
                         {.base_classes; .number_of_base_classes} ∈ {0}
                         .pvmt ∈ {{ &_frama_c_vmt_header }}
  _frama_c_vmt[0].method_ptr ∈ {{ &exception::Dtor }}
              [0].shift_this ∈ {0}
              [1].method_ptr ∈ {{ (void (*)())&what }}
              [1].shift_this ∈ {0}
  _frama_c_vmt_header.table ∈ {{ &_frama_c_vmt[0] }}
                     .table_size ∈ {2}
                     .rtti_info ∈ {{ &_frama_c_rtti_name_info }}
  _frama_c_rtti_name_info.name ∈ {{ "bad_exception" }}
                         .base_classes ∈ {{ &_frama_c_base_classes[0] }}
                         .number_of_base_classes ∈ {1}
                         .pvmt ∈ {{ &_frama_c_vmt_header }}
  _frama_c_base_classes[0].value ∈ {{ &_frama_c_rtti_name_info }}
                       [0]{.shift_object; .shift_vmt} ∈ {0}
  _frama_c_vmt[0].method_ptr ∈ {{ &bad_exception::Dtor }}
              [0].shift_this ∈ {0}
              [1].method_ptr ∈ {{ (void (*)())&what }}
              [1].shift_this ∈ {0}
  _frama_c_vmt_header.table ∈ {{ &_frama_c_vmt[0] }}
                     .table_size ∈ {1}
                     .rtti_info ∈ {{ &_frama_c_rtti_name_info }}
  _frama_c_rtti_name_info.name ∈ {{ "nested_exception" }}
                         {.base_classes; .number_of_base_classes} ∈ {0}
                         .pvmt ∈ {{ &_frama_c_vmt_header }}
  _frama_c_vmt[0].method_ptr ∈ {{ &nested_exception::Dtor }}
              [0].shift_this ∈ {0}
  _frama_c_rtti_name_info.name ∈ {{ "allocator" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "default_delete" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "default_delete" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "default_delete" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "default_delete" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_vmt_header.table ∈ {{ &_frama_c_vmt[0] }}
                     .table_size ∈ {7}
                     .rtti_info ∈ {{ &_frama_c_rtti_name_info }}
  _frama_c_rtti_name_info.name ∈ {{ "__shared_ref_base" }}
                         {.base_classes; .number_of_base_classes} ∈ {0}
                         .pvmt ∈ {{ &_frama_c_vmt_header }}
  _frama_c_vmt[0].method_ptr ∈ {{ &unlink }}
              [0].shift_this ∈ {0}
              [1].method_ptr ∈ {{ &link }}
              [1].shift_this ∈ {0}
              [2].method_ptr ∈ {{ (void (*)())&count }}
              [2].shift_this ∈ {0}
              [3].method_ptr ∈ {{ &weak_unlink }}
              [3].shift_this ∈ {0}
              [4].method_ptr ∈ {{ &weak_link }}
              [4].shift_this ∈ {0}
              [5].method_ptr ∈ {{ (void (*)())&ref }}
              [5].shift_this ∈ {0}
              [6].method_ptr ∈ {{ (void (*)())&get_deleter }}
              [6].shift_this ∈ {0}
  _frama_c_vmt_header.table ∈ {{ &_frama_c_vmt[0] }}
                     .table_size ∈ {7}
                     .rtti_info ∈ {{ &_frama_c_rtti_name_info }}
  _frama_c_rtti_name_info.name ∈ {{ "__shared_ref" }}
                         .base_classes ∈ {{ &_frama_c_base_classes[0] }}
                         .number_of_base_classes ∈ {1}
                         .pvmt ∈ {{ &_frama_c_vmt_header }}
  _frama_c_base_classes[0].value ∈ {{ &_frama_c_rtti_name_info }}
                       [0]{.shift_object; .shift_vmt} ∈ {0}
  _frama_c_vmt[0].method_ptr ∈ {{ &unlink }}
              [0].shift_this ∈ {0}
              [1].method_ptr ∈ {{ &link }}
              [1].shift_this ∈ {0}
              [2].method_ptr ∈ {{ (void (*)())&count }}
              [2].shift_this ∈ {0}
              [3].method_ptr ∈ {{ &weak_unlink }}
              [3].shift_this ∈ {0}
              [4].method_ptr ∈ {{ &weak_link }}
              [4].shift_this ∈ {0}
              [5].method_ptr ∈ {{ (void (*)())&ref }}
              [5].shift_this ∈ {0}
              [6].method_ptr ∈ {{ (void (*)())&get_deleter }}
              [6].shift_this ∈ {0}
  _frama_c_rtti_name_info.name ∈ {{ "unique_ptr" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "unique_ptr" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "unique_ptr" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "unique_ptr" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "auto_ptr" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_vmt_header.table ∈ {{ &_frama_c_vmt[0] }}
                     .table_size ∈ {2}
                     .rtti_info ∈ {{ &_frama_c_rtti_name_info }}
  _frama_c_rtti_name_info.name ∈ {{ "bad_weak_ptr" }}
                         .base_classes ∈ {{ &_frama_c_base_classes[0] }}
                         .number_of_base_classes ∈ {1}
                         .pvmt ∈ {{ &_frama_c_vmt_header }}
  _frama_c_base_classes[0].value ∈ {{ &_frama_c_rtti_name_info }}
                       [0]{.shift_object; .shift_vmt} ∈ {0}
  _frama_c_vmt[0].method_ptr ∈ {{ &bad_weak_ptr::Dtor }}
              [0].shift_this ∈ {0}
              [1].method_ptr ∈ {{ (void (*)())&what }}
              [1].shift_this ∈ {0}
  _frama_c_rtti_name_info.name ∈ {{ "shared_ptr" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "PlainOldStruct" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
  _frama_c_rtti_name_info.name ∈ {{ "ClassTemplate" }}
                         {.base_classes; .number_of_base_classes; .pvmt} ∈
                         {0}
[eva] tests/stl/stl_unique_ptr.cpp:9: 
  allocating variable __malloc_test_primitive_payload_l9
[eva:alarm] FRAMAC_SHARE/frama-clang/libc++/memory:477: Warning: 
  function operator*: postcondition got status unknown.
[eva] tests/stl/stl_unique_ptr.cpp:15: 
  allocating variable __malloc_test_primitive_payload_l15
[eva:alarm] FRAMAC_SHARE/frama-clang/libc++/memory:577: Warning: 
  function operator[]: postcondition got status unknown.
[eva:alarm] tests/stl/stl_unique_ptr.cpp:17: Warning: 
  signed overflow.
  assert *tmp_6 + 1 ≤ 2147483647;
  (tmp_6 from
  _ZNK3std10unique_ptrIA_iN3stdE14default_deleteIA_iEEEixRij((struct _ZN3stdE10unique_ptrIA_iN3stdE14default_deleteIA_iEE const *)(& up3), (unsigned int)0))
[eva:alarm] tests/stl/stl_unique_ptr.cpp:29: Warning: 
  out of bounds read. assert \valid_read(up5_raw + 0);
[eva] tests/stl/stl_unique_ptr.cpp:44: 
  allocating variable __malloc_test_struct_payload_l44
[eva:alarm] tests/stl/stl_unique_ptr.cpp:44: Warning: 
  function PlainOldStruct::Ctor: precondition got status unknown.
[eva] tests/stl/stl_unique_ptr.cpp:78: 
  allocating variable __malloc_test_template_payload_l78
[eva:alarm] tests/stl/stl_unique_ptr.cpp:78: Warning: 
  function ClassTemplate<int,0>::Ctor: precondition got status unknown.
[eva] done for function main
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  71 functions analyzed (out of 109): 65% coverage.
  In these functions, 256 statements reached (out of 287): 89% coverage.
  ----------------------------------------------------------------------------
  Some errors and warnings have been raised during the analysis:
    by the Eva analyzer:      0 errors    0 warnings
    by the Frama-C kernel:    0 errors   21 warnings
  ----------------------------------------------------------------------------
  2 alarms generated by the analysis:
       1 invalid memory access
       1 integer overflow
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions   139 valid     2 unknown     0 invalid    141 total
  98% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[from] Computing for function pull
[from] Done for function pull
[from] Computing for function push
[from] Done for function push
[from] Computing for function ClassTemplate<int,0>::Ctor
[from] Done for function ClassTemplate<int,0>::Ctor
[from] Computing for function ClassTemplate<int,0>::Dtor
[from] Done for function ClassTemplate<int,0>::Dtor
[from] Computing for function pull
[from] Done for function pull
[from] Computing for function push
[from] Done for function push
[from] Computing for function PlainOldStruct::Ctor
[from] Done for function PlainOldStruct::Ctor
[from] Computing for function PlainOldStruct::Dtor
[from] Done for function PlainOldStruct::Dtor
[from] Computing for function release
[from] Done for function release
[from] Computing for function unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
[from] Done for function unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
[from] Computing for function release
[from] Done for function release
[from] Computing for function unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
[from] Done for function unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
[from] Computing for function release
[from] Done for function release
[from] Computing for function unique_ptr<int[],std::default_delete<int[]>>::Dtor
[from] Done for function unique_ptr<int[],std::default_delete<int[]>>::Dtor
[from] Computing for function release
[from] Done for function release
[from] Computing for function unique_ptr<int,std::default_delete<int>>::Dtor
[from] Done for function unique_ptr<int,std::default_delete<int>>::Dtor
[from] Computing for function default_delete<ClassTemplate<int,0>>::Ctor
[from] Done for function default_delete<ClassTemplate<int,0>>::Ctor
[from] Computing for function unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
[from] Done for function unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
[from] Computing for function default_delete<ClassTemplate<int,0>>::Ctor
[from] Done for function default_delete<ClassTemplate<int,0>>::Ctor
[from] Computing for function default_delete<ClassTemplate<int,0>>::Ctor
[from] Done for function default_delete<ClassTemplate<int,0>>::Ctor
[from] Computing for function operator=
[from] Done for function operator=
[from] Computing for function default_delete<PlainOldStruct>::Ctor
[from] Done for function default_delete<PlainOldStruct>::Ctor
[from] Computing for function unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
[from] Done for function unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
[from] Computing for function default_delete<PlainOldStruct>::Ctor
[from] Done for function default_delete<PlainOldStruct>::Ctor
[from] Computing for function default_delete<PlainOldStruct>::Ctor
[from] Done for function default_delete<PlainOldStruct>::Ctor
[from] Computing for function operator=
[from] Done for function operator=
[from] Computing for function default_delete<int[]>::Ctor
[from] Done for function default_delete<int[]>::Ctor
[from] Computing for function unique_ptr<int[],std::default_delete<int[]>>::Ctor
[from] Done for function unique_ptr<int[],std::default_delete<int[]>>::Ctor
[from] Computing for function default_delete<int[]>::Ctor
[from] Done for function default_delete<int[]>::Ctor
[from] Computing for function default_delete<int>::Ctor
[from] Done for function default_delete<int>::Ctor
[from] Computing for function unique_ptr<int,std::default_delete<int>>::Ctor
[from] Done for function unique_ptr<int,std::default_delete<int>>::Ctor
[from] Computing for function default_delete<int>::Ctor
[from] Done for function default_delete<int>::Ctor
[from] Computing for function operator=
[from] Done for function operator=
[from] Computing for function move<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>&>
[from] Done for function move<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>&>
[from] Computing for function move<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>&>
[from] Done for function move<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>&>
[from] Computing for function move<std::unique_ptr<int[],std::default_delete<int[]>>&>
[from] Done for function move<std::unique_ptr<int[],std::default_delete<int[]>>&>
[from] Computing for function swap<std::default_delete<ClassTemplate<int,0>>>
[from] Done for function swap<std::default_delete<ClassTemplate<int,0>>>
[from] Computing for function swap<std::default_delete<PlainOldStruct>>
[from] Done for function swap<std::default_delete<PlainOldStruct>>
[from] Computing for function swap<std::default_delete<int>>
[from] Done for function swap<std::default_delete<int>>
[from] Computing for function swap<ClassTemplate<int,0>*>
[from] Done for function swap<ClassTemplate<int,0>*>
[from] Computing for function swap
[from] Done for function swap
[from] Computing for function swap<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>
[from] Done for function swap<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>
[from] Computing for function swap<PlainOldStruct*>
[from] Done for function swap<PlainOldStruct*>
[from] Computing for function swap
[from] Done for function swap
[from] Computing for function swap<PlainOldStruct,std::default_delete<PlainOldStruct>>
[from] Done for function swap<PlainOldStruct,std::default_delete<PlainOldStruct>>
[from] Computing for function swap<int*>
[from] Done for function swap<int*>
[from] Computing for function swap
[from] Done for function swap
[from] Computing for function swap<int,std::default_delete<int>>
[from] Done for function swap<int,std::default_delete<int>>
[from] Computing for function forward<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>>
[from] Done for function forward<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>>
[from] Computing for function forward<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>>
[from] Done for function forward<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>>
[from] Computing for function forward<std::unique_ptr<int[],std::default_delete<int[]>>>
[from] Done for function forward<std::unique_ptr<int[],std::default_delete<int[]>>>
[from] Computing for function forward<std::default_delete<ClassTemplate<int,0>>>
[from] Done for function forward<std::default_delete<ClassTemplate<int,0>>>
[from] Computing for function unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
[from] Done for function unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
[from] Computing for function forward<std::default_delete<PlainOldStruct>>
[from] Done for function forward<std::default_delete<PlainOldStruct>>
[from] Computing for function unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
[from] Done for function unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
[from] Computing for function forward<std::default_delete<int[]>>
[from] Done for function forward<std::default_delete<int[]>>
[from] Computing for function unique_ptr<int[],std::default_delete<int[]>>::Ctor
[from] Done for function unique_ptr<int[],std::default_delete<int[]>>::Ctor
[from] Computing for function std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::operator->
[from] Done for function std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::operator->
[from] Computing for function std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::operator->
[from] Done for function std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::operator->
[from] Computing for function operator[]
[from] Done for function operator[]
[from] Computing for function operator*
[from] Done for function operator*
[from] Computing for function operator()
[from] Computing for function free <-operator()
[from] Done for function free
[from] Done for function operator()
[from] Computing for function reset
[from] Done for function reset
[from] Computing for function operator()
[from] Done for function operator()
[from] Computing for function reset
[from] Done for function reset
[from] Computing for function operator()
[from] Done for function operator()
[from] Computing for function reset
[from] Done for function reset
[from] Computing for function test_struct_payload
[from] Computing for function malloc <-test_struct_payload
[from] Done for function malloc
[from] Done for function test_struct_payload
[from] Computing for function test_template_payload
[from] Done for function test_template_payload
[from] Computing for function test_primitive_payload
[from] Done for function test_primitive_payload
[from] Computing for function main
[from] Done for function main
[from] ====== DEPENDENCIES COMPUTED ======
  These dependencies hold at termination for the executions that terminate:
[from] Function pull:
  \result FROM this
[from] Function push:
  ct FROM this; x; var
[from] Function ClassTemplate<int,0>::Ctor:
  NO EFFECTS
[from] Function ClassTemplate<int,0>::Dtor:
  NO EFFECTS
[from] Function pull:
  \result FROM this; pos
[from] Function push:
  pos FROM this; x (and SELF)
  __malloc_test_struct_payload_l44 FROM this; x (and SELF)
[from] Function PlainOldStruct::Ctor:
  NO EFFECTS
[from] Function PlainOldStruct::Dtor:
  NO EFFECTS
[from] Function release:
  up4 FROM this
  \result FROM this; up4
[from] Function unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor:
  NO EFFECTS
[from] Function release:
  up4 FROM this
  \result FROM this; up4
[from] Function unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor:
  NO EFFECTS
[from] Function release:
  up5 FROM this
  \result FROM this; up5
[from] Function unique_ptr<int[],std::default_delete<int[]>>::Dtor:
  NO EFFECTS
[from] Function release:
  up2 FROM this
  \result FROM this; up2
[from] Function unique_ptr<int,std::default_delete<int>>::Dtor:
  NO EFFECTS
[from] Function default_delete<ClassTemplate<int,0>>::Ctor:
  NO EFFECTS
[from] Function unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor:
  up1 FROM this; p (and SELF)
  up2 FROM this; p (and SELF)
[from] Function default_delete<ClassTemplate<int,0>>::Ctor:
  NO EFFECTS
[from] Function default_delete<ClassTemplate<int,0>>::Ctor:
  NO EFFECTS
[from] Function operator=:
  \result FROM this
[from] Function default_delete<PlainOldStruct>::Ctor:
  NO EFFECTS
[from] Function unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor:
  up1 FROM this; p (and SELF)
  up2 FROM this; p (and SELF)
[from] Function default_delete<PlainOldStruct>::Ctor:
  NO EFFECTS
[from] Function default_delete<PlainOldStruct>::Ctor:
  NO EFFECTS
[from] Function operator=:
  \result FROM this
[from] Function default_delete<int[]>::Ctor:
  NO EFFECTS
[from] Function unique_ptr<int[],std::default_delete<int[]>>::Ctor:
  up3 FROM this; p
[from] Function default_delete<int[]>::Ctor:
  NO EFFECTS
[from] Function default_delete<int>::Ctor:
  NO EFFECTS
[from] Function unique_ptr<int,std::default_delete<int>>::Ctor:
  up1 FROM this; p (and SELF)
  up2 FROM this; p (and SELF)
[from] Function default_delete<int>::Ctor:
  NO EFFECTS
[from] Function operator=:
  \result FROM this
[from] Function move<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>&>:
  \result FROM t
[from] Function move<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>&>:
  \result FROM t
[from] Function move<std::unique_ptr<int[],std::default_delete<int[]>>&>:
  \result FROM t
[from] Function swap<std::default_delete<ClassTemplate<int,0>>>:
  NO EFFECTS
[from] Function swap<std::default_delete<PlainOldStruct>>:
  NO EFFECTS
[from] Function swap<std::default_delete<int>>:
  NO EFFECTS
[from] Function swap<ClassTemplate<int,0>*>:
  up1 FROM a; b; up2
  up2 FROM a; b; up1
[from] Function swap:
  up1 FROM this; u; up2
  up2 FROM this; u; up1
[from] Function swap<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>:
  up1 FROM x; y; up2
  up2 FROM x; y; up1
[from] Function swap<PlainOldStruct*>:
  up1 FROM a; b; up2
  up2 FROM a; b; up1
[from] Function swap:
  up1 FROM this; u; up2
  up2 FROM this; u; up1
[from] Function swap<PlainOldStruct,std::default_delete<PlainOldStruct>>:
  up1 FROM x; y; up2
  up2 FROM x; y; up1
[from] Function swap<int*>:
  up1 FROM a; b; up2
  up2 FROM a; b; up1
[from] Function swap:
  up1 FROM this; u; up2
  up2 FROM this; u; up1
[from] Function swap<int,std::default_delete<int>>:
  up1 FROM x; y; up2
  up2 FROM x; y; up1
[from] Function forward<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>>:
  \result FROM t
[from] Function forward<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>>:
  \result FROM t
[from] Function forward<std::unique_ptr<int[],std::default_delete<int[]>>>:
  \result FROM t
[from] Function forward<std::default_delete<ClassTemplate<int,0>>>:
  \result FROM t
[from] Function unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor:
  up2 FROM u (and SELF)
  up3 FROM this; u; up2; up3 (and SELF)
  up4 FROM this; u; up2; up3 (and SELF)
[from] Function forward<std::default_delete<PlainOldStruct>>:
  \result FROM t
[from] Function unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor:
  up2 FROM u (and SELF)
  up3 FROM this; u; up2; up3 (and SELF)
  up4 FROM this; u; up2; up3 (and SELF)
[from] Function forward<std::default_delete<int[]>>:
  \result FROM t
[from] Function unique_ptr<int[],std::default_delete<int[]>>::Ctor:
  up3 FROM u (and SELF)
  up4 FROM this; u; up3; up4 (and SELF)
  up5 FROM this; u; up3; up4 (and SELF)
[from] Function std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::operator->:
  \result FROM this; up1; up4
[from] Function std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::operator->:
  \result FROM this; up1; up2; up4
[from] Function operator[]:
  \result FROM this; i; up3
[from] Function operator*:
  \result FROM this; up1; up2
[from] Function free:
  __malloc_test_primitive_payload_l9[0..3] FROM __malloc_test_primitive_payload_l9[0..3];
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_primitive_payload_l15[0..7] FROM __malloc_test_primitive_payload_l9[0..3];
                                                  __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_struct_payload_l44 FROM __malloc_test_primitive_payload_l9[0..3];
                                         __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM __malloc_test_primitive_payload_l9[0..3];
                                           __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
[from] Function operator():
  __malloc_test_primitive_payload_l9[0..3] FROM __malloc_test_primitive_payload_l9[0..3];
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_primitive_payload_l15[0..7] FROM __malloc_test_primitive_payload_l9[0..3];
                                                  __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_struct_payload_l44 FROM __malloc_test_primitive_payload_l9[0..3];
                                         __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM __malloc_test_primitive_payload_l9[0..3];
                                           __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
[from] Function reset:
  up1 FROM this; p
  __malloc_test_primitive_payload_l9[0..3] FROM __malloc_test_primitive_payload_l9[0..3];
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_primitive_payload_l15[0..7] FROM __malloc_test_primitive_payload_l9[0..3];
                                                  __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_struct_payload_l44 FROM __malloc_test_primitive_payload_l9[0..3];
                                         __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM __malloc_test_primitive_payload_l9[0..3];
                                           __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
[from] Function operator():
  __malloc_test_primitive_payload_l9[0..3] FROM __malloc_test_primitive_payload_l9[0..3];
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_primitive_payload_l15[0..7] FROM __malloc_test_primitive_payload_l9[0..3];
                                                  __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_struct_payload_l44 FROM __malloc_test_primitive_payload_l9[0..3];
                                         __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM __malloc_test_primitive_payload_l9[0..3];
                                           __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
[from] Function reset:
  up1 FROM this; p
  __malloc_test_primitive_payload_l9[0..3] FROM __malloc_test_primitive_payload_l9[0..3];
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_primitive_payload_l15[0..7] FROM __malloc_test_primitive_payload_l9[0..3];
                                                  __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_struct_payload_l44 FROM __malloc_test_primitive_payload_l9[0..3];
                                         __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM __malloc_test_primitive_payload_l9[0..3];
                                           __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
[from] Function operator():
  __malloc_test_primitive_payload_l9[0..3] FROM __malloc_test_primitive_payload_l9[0..3];
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_primitive_payload_l15[0..7] FROM __malloc_test_primitive_payload_l9[0..3];
                                                  __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_struct_payload_l44 FROM __malloc_test_primitive_payload_l9[0..3];
                                         __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM __malloc_test_primitive_payload_l9[0..3];
                                           __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
[from] Function reset:
  up1 FROM this; p
  __malloc_test_primitive_payload_l9[0..3] FROM __malloc_test_primitive_payload_l9[0..3];
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_primitive_payload_l15[0..7] FROM __malloc_test_primitive_payload_l9[0..3];
                                                  __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_struct_payload_l44 FROM __malloc_test_primitive_payload_l9[0..3];
                                         __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM __malloc_test_primitive_payload_l9[0..3];
                                           __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
[from] Function malloc:
  \result FROM size
[from] Function test_struct_payload:
  __malloc_test_primitive_payload_l9[0..3] FROM var;
                                                __malloc_test_primitive_payload_l9[0..3];
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_primitive_payload_l15[0..7] FROM var;
                                                 __malloc_test_primitive_payload_l9[0..3];
                                                  __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_struct_payload_l44 FROM var;
                                        __malloc_test_primitive_payload_l9[0..3];
                                         __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM var;
                                          __malloc_test_primitive_payload_l9[0..3];
                                           __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
  \result FROM var
[from] Function test_template_payload:
  __malloc_test_primitive_payload_l9[0..3] FROM __malloc_test_primitive_payload_l9[0..3];
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_primitive_payload_l15[0..7] FROM __malloc_test_primitive_payload_l9[0..3];
                                                  __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_struct_payload_l44 FROM __malloc_test_primitive_payload_l9[0..3];
                                         __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM __malloc_test_primitive_payload_l9[0..3];
                                           __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
  \result FROM var
[from] Function test_primitive_payload:
  __malloc_test_primitive_payload_l9[0..3] FROM var;
                                                __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78
  __malloc_test_primitive_payload_l15[0..7] FROM var;
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78
  __malloc_test_struct_payload_l44 FROM var;
                                        __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM var;
                                          __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
  \result FROM var
[from] Function main:
  __malloc_test_primitive_payload_l9[0..3] FROM argc;
                                                __malloc_test_primitive_payload_l15[0..7];
                                                 __malloc_test_struct_payload_l44;
                                                 __malloc_test_template_payload_l78
  __malloc_test_primitive_payload_l15[0..7] FROM argc;
                                                 __malloc_test_primitive_payload_l15[0..7];
                                                  __malloc_test_struct_payload_l44;
                                                  __malloc_test_template_payload_l78
  __malloc_test_struct_payload_l44 FROM argc;
                                        __malloc_test_primitive_payload_l15[0..7];
                                         __malloc_test_struct_payload_l44;
                                        __malloc_test_template_payload_l78 (and SELF)
  __malloc_test_template_payload_l78 FROM argc;
                                          __malloc_test_primitive_payload_l15[0..7];
                                           __malloc_test_struct_payload_l44;
                                          __malloc_test_template_payload_l78 (and SELF)
  \result FROM argc
[from] ====== END OF DEPENDENCIES ======
/* Generated by Frama-C */
struct _frama_c_vmt_content {
   void (*method_ptr)() ;
   int shift_this ;
};
struct _frama_c_rtti_name_info_node;
struct _frama_c_vmt {
   struct _frama_c_vmt_content *table ;
   int table_size ;
   struct _frama_c_rtti_name_info_node *rtti_info ;
};
struct _frama_c_rtti_name_info_content {
   struct _frama_c_rtti_name_info_node *value ;
   int shift_object ;
   int shift_vmt ;
};
struct _frama_c_rtti_name_info_node {
   char const *name ;
   struct _frama_c_rtti_name_info_content *base_classes ;
   int number_of_base_classes ;
   struct _frama_c_vmt *pvmt ;
};
typedef unsigned int size_t;
typedef size_t size_t;
typedef void *nullptr_t;
typedef _Bool value_type;
struct integral_constant<bool,0>;
struct integral_constant<bool,0> {
   
};
typedef _Bool value_type;
struct integral_constant<bool,1>;
struct integral_constant<bool,1> {
   
};
struct default_delete<int>;
typedef struct default_delete<int> type;
typedef int type;
struct default_delete<int[]>;
typedef struct default_delete<int[]> type;
struct unique_ptr<int[],std::default_delete<int[]>>;
typedef struct unique_ptr<int[],std::default_delete<int[]>> type;
typedef struct unique_ptr<int[],std::default_delete<int[]>> type;
struct default_delete<PlainOldStruct>;
typedef struct default_delete<PlainOldStruct> type;
struct PlainOldStruct;
typedef struct PlainOldStruct type;
struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>;
typedef struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> type;
typedef struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> type;
struct default_delete<ClassTemplate<int,0>>;
typedef struct default_delete<ClassTemplate<int,0>> type;
struct ClassTemplate<int,0>;
typedef struct ClassTemplate<int,0> type;
struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>;
typedef struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> type;
typedef struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> type;
typedef type *type;
typedef type *type;
typedef type *type;
struct __shared_ref_base;
struct unique_ptr<int,std::default_delete<int>>;
struct piecewise_construct_t;
struct piecewise_construct_t {
   
};
struct exception;
struct bad_exception;
struct nested_exception;
struct exception {
   struct _frama_c_vmt *pvmt ;
};
struct bad_exception {
   struct exception _frama_c__ZN3stdE9exception ;
};
typedef void *exception_ptr;
struct nested_exception {
   struct _frama_c_vmt *pvmt ;
};
struct default_delete<int> {
   
};
struct default_delete<int[]> {
   
};
struct default_delete<PlainOldStruct> {
   
};
struct default_delete<ClassTemplate<int,0>> {
   
};
struct __shared_ref_base {
   struct _frama_c_vmt *pvmt ;
};
struct __shared_ref<void> {
   struct __shared_ref_base _frama_c__ZN3stdE17__shared_ref_base ;
   void *__ptr ;
   long _n ;
   long _w ;
};
typedef int *pointer;
typedef struct default_delete<int> deleter_type;
struct unique_ptr<int,std::default_delete<int>> {
   int *__ptr ;
   struct default_delete<int> __dlt ;
};
typedef int *pointer;
typedef struct default_delete<int[]> deleter_type;
struct unique_ptr<int[],std::default_delete<int[]>> {
   int *__ptr ;
   struct default_delete<int[]> __dlt ;
};
typedef struct PlainOldStruct *pointer;
typedef struct default_delete<PlainOldStruct> deleter_type;
struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> {
   struct PlainOldStruct *__ptr ;
   struct default_delete<PlainOldStruct> __dlt ;
};
typedef struct ClassTemplate<int,0> *pointer;
typedef struct default_delete<ClassTemplate<int,0>> deleter_type;
struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> {
   struct ClassTemplate<int,0> *__ptr ;
   struct default_delete<ClassTemplate<int,0>> __dlt ;
};
struct bad_weak_ptr;
struct shared_ptr<void>;
struct bad_weak_ptr {
   struct exception _frama_c__ZN3stdE9exception ;
};
struct shared_ptr<void> {
   void *__ptr ;
   struct __shared_ref_base *_ref ;
};
struct PlainOldStruct {
   int val ;
};
struct ClassTemplate<int,0> {
   int val ;
};
/*@ assigns \result;
    assigns \result \from size; */
void *malloc(unsigned int size);

/*@ assigns *((char *)ptr + (0 ..));
    assigns *((char *)ptr + (0 ..)) \from *((char *)ptr + (0 ..));
 */
void free(void *ptr);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
value_type value_type)(struct integral_constant<bool,0> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "integral_constant",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
value_type value_type)(struct integral_constant<bool,1> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "integral_constant",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__boolean",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__boolean",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "_is_void",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "ok_type",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "ko_type",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_convertible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_convertible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_convertible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_convertible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_convertible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "is_convertible",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "remove_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "add_lvalue_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "add_lvalue_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "add_lvalue_reference",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "enable_if",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@ requires \valid(b);
    requires \valid(a); */
void swap<void*>(void **a, void **b)
{
  void *tmp = *a;
  *a = *b;
  *b = tmp;
  return;
}

/*@ requires \valid(b);
    requires \valid(a); */
void swap<std::__shared_ref_base*>(struct __shared_ref_base **a,
                                   struct __shared_ref_base **b)
{
  struct __shared_ref_base *tmp = *a;
  *a = *b;
  *b = tmp;
  return;
}

/*@ requires \valid(b);
    requires \valid(a); */
void swap<std::unique_ptr<int,std::default_delete<int>>>(struct unique_ptr<int,std::default_delete<int>> *a,
                                                         struct unique_ptr<int,std::default_delete<int>> *b);

/*@ requires \valid(b);
    requires \valid(a); */
void swap<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>>
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *a,
 struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *b);

/*@ requires \valid(b);
    requires \valid(a); */
void swap<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>>
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *a,
 struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *b);

/*@ requires \valid(b);
    requires \valid(a); */
void swap<int*>(int **a, int **b)
{
  int *tmp = *a;
  *a = *b;
  *b = tmp;
  return;
}

struct default_delete<int> *operator=(struct default_delete<int> *this,
                                      struct default_delete<int> const *__frama_c_arg_0);

void default_delete<int>::Ctor(struct default_delete<int> const *this,
                               struct default_delete<int> const *__frama_c_arg_0);

/*@ requires \valid(b);
    requires \valid(a); */
void swap<std::default_delete<int>>(struct default_delete<int> *a,
                                    struct default_delete<int> *b)
{
  struct default_delete<int> *tmp_0;
  struct default_delete<int> *tmp_1;
  struct default_delete<int> tmp;
  default_delete<int>::Ctor(& tmp,(struct default_delete<int> const *)a);
  tmp_0 = operator=(a,(struct default_delete<int> const *)b);
  tmp_1 = operator=(b,(struct default_delete<int> const *)(& tmp));
  return;
}

/*@ requires \valid(b);
    requires \valid(a); */
void swap<PlainOldStruct*>(struct PlainOldStruct **a,
                           struct PlainOldStruct **b)
{
  struct PlainOldStruct *tmp = *a;
  *a = *b;
  *b = tmp;
  return;
}

struct default_delete<PlainOldStruct> *operator=(struct default_delete<PlainOldStruct> *this,
                                                 struct default_delete<PlainOldStruct> const *__frama_c_arg_0);

void default_delete<PlainOldStruct>::Ctor(struct default_delete<PlainOldStruct> const *this,
                                          struct default_delete<PlainOldStruct> const *__frama_c_arg_0);

/*@ requires \valid(b);
    requires \valid(a); */
void swap<std::default_delete<PlainOldStruct>>(struct default_delete<PlainOldStruct> *a,
                                               struct default_delete<PlainOldStruct> *b)
{
  struct default_delete<PlainOldStruct> *tmp_0;
  struct default_delete<PlainOldStruct> *tmp_1;
  struct default_delete<PlainOldStruct> tmp;
  default_delete<PlainOldStruct>::Ctor(& tmp,
                                       (struct default_delete<PlainOldStruct> const *)a);
  tmp_0 = operator=(a,(struct default_delete<PlainOldStruct> const *)b);
  tmp_1 = operator=(b,(struct default_delete<PlainOldStruct> const *)(& tmp));
  return;
}

/*@ requires \valid(b);
    requires \valid(a); */
void swap<ClassTemplate<int,0>*>(struct ClassTemplate<int,0> **a,
                                 struct ClassTemplate<int,0> **b)
{
  struct ClassTemplate<int,0> *tmp = *a;
  *a = *b;
  *b = tmp;
  return;
}

void default_delete<ClassTemplate<int,0>>::Ctor(struct default_delete<ClassTemplate<int,0>> const *this,
                                                struct default_delete<ClassTemplate<int,0>> const *__frama_c_arg_0);

struct default_delete<ClassTemplate<int,0>> *operator=(struct default_delete<ClassTemplate<int,0>> *this,
                                                       struct default_delete<ClassTemplate<int,0>> const *__frama_c_arg_0);

/*@ requires \valid(b);
    requires \valid(a); */
void swap<std::default_delete<ClassTemplate<int,0>>>(struct default_delete<ClassTemplate<int,0>> *a,
                                                     struct default_delete<ClassTemplate<int,0>> *b)
{
  struct default_delete<ClassTemplate<int,0>> *tmp_0;
  struct default_delete<ClassTemplate<int,0>> *tmp_1;
  struct default_delete<ClassTemplate<int,0>> tmp;
  default_delete<ClassTemplate<int,0>>::Ctor(& tmp,
                                             (struct default_delete<ClassTemplate<int,0>> const *)a);
  tmp_0 = operator=(a,(struct default_delete<ClassTemplate<int,0>> const *)b);
  tmp_1 = operator=(b,
                    (struct default_delete<ClassTemplate<int,0>> const *)(& tmp));
  return;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct unique_ptr<int[],std::default_delete<int[]>> *forward<std::unique_ptr<int[],std::default_delete<int[]>>>
(type *t)
{
  return t;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *forward<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>>
(type *t)
{
  return t;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *forward<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>>
(type *t)
{
  return t;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct default_delete<int[]> *forward<std::default_delete<int[]>>(type *t)
{
  return t;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct default_delete<PlainOldStruct> *forward<std::default_delete<PlainOldStruct>>
(type *t)
{
  return t;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct default_delete<ClassTemplate<int,0>> *forward<std::default_delete<ClassTemplate<int,0>>>
(type *t)
{
  return t;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
type *move<std::unique_ptr<int[],std::default_delete<int[]>>&>(struct unique_ptr<int[],std::default_delete<int[]>> *t)
{
  return t;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
type *move<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>&>
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *t)
{
  return t;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
type *move<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>&>
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *t)
{
  return t;
}

void piecewise_construct_t::Ctor(struct piecewise_construct_t const *this);

void piecewise_construct_t::Dtor(struct piecewise_construct_t const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void piecewise_construct_t::Ctor(struct piecewise_construct_t const *this)
{
  return;
}

/*@ requires \valid_read(this); */
void piecewise_construct_t::Dtor(struct piecewise_construct_t const *this)
{
  return;
}

struct piecewise_construct_t piecewise_construct;
void __fc_init_ZN3stdE19piecewise_construct(void) __attribute__((__constructor__));
void __fc_init_ZN3stdE19piecewise_construct(void)
{
  struct piecewise_construct_t __fc_tmp_0;
  piecewise_construct_t::Ctor(& __fc_tmp_0);
  piecewise_construct = __fc_tmp_0;
  piecewise_construct_t::Dtor((struct piecewise_construct_t const *)(& __fc_tmp_0));
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "piecewise_construct_t",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@
axiomatic MemCmp {
  logic ℤ memcmp{L1, L2}(char *s1, char *s2, ℤ n) 
    reads \at(*(s1 + (0 .. n - 1)),L1), \at(*(s2 + (0 .. n - 1)),L2);
  
  axiom memcmp_zero{L1, L2}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L1, L2}(s1, s2, n) ≡ 0 ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ \at(*(s1 + i),L1) ≡ \at(*(s2 + i),L2));
  
  }
 */
/*@
axiomatic MemChr {
  logic 𝔹 memchr{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  logic ℤ memchr_off{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memchr(s, c, n) ≢ (0 ≢ 0) ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic MemSet {
  logic 𝔹 memset{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memset_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memset(s, c, n) ≢ (0 ≢ 0) ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic StrLen {
  logic ℤ strlen{L}(char *s) 
    reads *(s + (0 ..));
  
  axiom strlen_pos_or_null{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ (char)0) ∧
      *(s + i) ≡ (char)0 ⇒ strlen(s) ≡ i;
  
  axiom strlen_neg{L}:
    ∀ char *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ (char)0) ⇒ strlen(s) < 0;
  
  axiom strlen_before_null{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i < strlen(s) ⇒ *(s + i) ≢ (char)0;
  
  axiom strlen_at_null{L}:
    ∀ char *s; 0 ≤ strlen(s) ⇒ *(s + strlen(s)) ≡ (char)0;
  
  axiom strlen_not_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≢ (char)0 ⇒ i < strlen(s);
  
  axiom strlen_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ (char)0 ⇒ i ≡ strlen(s);
  
  axiom strlen_sup{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ (char)0 ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_shift{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ≤ strlen(s) ⇒ strlen(s + i) ≡ strlen(s) - i;
  
  axiom strlen_create{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ (char)0 ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_create_shift{L}:
    ∀ char *s;
    ∀ ℤ i;
    ∀ ℤ k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ (char)0 ⇒
      0 ≤ strlen(s + k) ≤ i - k;
  
  axiom memcmp_strlen_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s1) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s2) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_shift_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1, s2 + k, n) ≡ 0 ≤ k ∧ strlen(s1) < n ⇒
      0 ≤ strlen(s2) ≤ k + strlen(s1);
  
  axiom memcmp_strlen_shift_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1 + k, s2, n) ≡ 0 ≤ k ∧ strlen(s2) < n ⇒
      0 ≤ strlen(s1) ≤ k + strlen(s2);
  
  }
 */
/*@
axiomatic StrCmp {
  logic ℤ strcmp{L}(char *s1, char *s2) 
    reads *(s1 + (0 .. strlen(s1))), *(s2 + (0 .. strlen(s2)));
  
  axiom strcmp_zero{L}:
    ∀ char *s1, char *s2;
      strcmp(s1, s2) ≡ 0 ⇔
      strlen(s1) ≡ strlen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ strlen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrNCmp {
  logic ℤ strncmp{L}(char *s1, char *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom strncmp_zero{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      strncmp(s1, s2, n) ≡ 0 ⇔
      (strlen(s1) < n ∧ strcmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrChr {
  logic 𝔹 strchr{L}(char *s, ℤ c) 
    reads *(s + (0 .. strlen(s)));
  
  axiom strchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
      strchr(s, c) ≢ (0 ≢ 0) ⇔
      (∃ ℤ i; 0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ (char)((int)c));
  
  }
 */
/*@
axiomatic WMemChr {
  logic 𝔹 wmemchr{L}(int *s, int c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  logic ℤ wmemchr_off{L}(int *s, int c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom wmemchr_def{L}:
    ∀ int *s;
    ∀ int c;
    ∀ ℤ n;
      wmemchr(s, c, n) ≢ (0 ≢ 0) ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic WcsLen {
  logic ℤ wcslen{L}(int *s) 
    reads *(s + (0 ..));
  
  axiom wcslen_pos_or_null{L}:
    ∀ int *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ (int)0) ∧
      *(s + i) ≡ (int)0 ⇒ wcslen(s) ≡ i;
  
  axiom wcslen_neg{L}:
    ∀ int *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ (int)0) ⇒ wcslen(s) < 0;
  
  axiom wcslen_before_null{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i < wcslen(s) ⇒ *(s + i) ≢ (int)0;
  
  axiom wcslen_at_null{L}:
    ∀ int *s; 0 ≤ wcslen(s) ⇒ *(s + wcslen(s)) ≡ (int)0;
  
  axiom wcslen_not_zero{L}:
    ∀ int *s;
    ∀ int i;
      0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≢ (int)0 ⇒ i < wcslen(s);
  
  axiom wcslen_zero{L}:
    ∀ int *s;
    ∀ int i;
      0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≡ (int)0 ⇒ i ≡ wcslen(s);
  
  axiom wcslen_sup{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ (int)0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_shift{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ⇒ wcslen(s + i) ≡ wcslen(s) - i;
  
  axiom wcslen_create{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ (int)0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_create_shift{L}:
    ∀ int *s;
    ∀ int i;
    ∀ int k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ (int)0 ⇒ 0 ≤ wcslen(s + k) ≤ i - k;
  
  }
 */
/*@
axiomatic WcsCmp {
  logic ℤ wcscmp{L}(int *s1, int *s2) 
    reads *(s1 + (0 .. wcslen(s1))), *(s2 + (0 .. wcslen(s2)));
  
  axiom wcscmp_zero{L}:
    ∀ int *s1, int *s2;
      wcscmp(s1, s2) ≡ 0 ⇔
      wcslen(s1) ≡ wcslen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ wcslen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsNCmp {
  logic ℤ wcsncmp{L}(int *s1, int *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom wcsncmp_zero{L}:
    ∀ int *s1, int *s2;
    ∀ ℤ n;
      wcsncmp(s1, s2, n) ≡ 0 ⇔
      (wcslen(s1) < n ∧ wcscmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsChr {
  logic 𝔹 wcschr{L}(int *wcs, ℤ wc) 
    reads *(wcs + (0 .. wcslen(wcs)));
  
  axiom wcschr_def{L}:
    ∀ int *wcs;
    ∀ ℤ wc;
      wcschr(wcs, wc) ≢ (0 ≢ 0) ⇔
      (∃ ℤ i; 0 ≤ i ≤ wcslen(wcs) ∧ *(wcs + i) ≡ (int)((int)wc));
  
  }
 */
/*@ logic ℤ minimum(ℤ i, ℤ j) = i < j? i: j;
 */
/*@ logic ℤ maximum(ℤ i, ℤ j) = i < j? j: i;
 */
/*@
predicate valid_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid_read(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_nstring{L}(char *s, ℤ n) =
  (\valid_read(s + (0 .. n - 1)) ∧ \initialized(s + (0 .. n - 1))) ∨
  valid_read_string(s);
 */
/*@
predicate valid_string_or_null{L}(char *s) = s ≡ \null ∨ valid_string(s);
 */
/*@
predicate valid_wstring{L}(int *s) =
  0 ≤ wcslen(s) ∧ \valid(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_read_wstring{L}(int *s) =
  0 ≤ wcslen(s) ∧ \valid_read(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_read_nwstring{L}(int *s, ℤ n) =
  (\valid_read(s + (0 .. n - 1)) ∧ \initialized(s + (0 .. n - 1))) ∨
  valid_read_wstring(s);
 */
/*@
predicate valid_wstring_or_null{L}(int *s) =
  s ≡ \null ∨ valid_wstring(s);
 */
/*@ ghost int __fc_heap_status; */
/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(ℤ n) 
    reads __fc_heap_status;
  
  axiom never_allocable{L}:
    ∀ ℤ i; i < 0 ∨ i > 4294967295U ⇒ ¬is_allocable(i);
  
  }
 */
/*@
predicate non_escaping{L}(void *s, ℤ n) =
  ∀ ℤ i; 0 ≤ i < n ⇒ ¬\initialized((char *)s + i);
 */
/*@
predicate empty_block{L}(void *s) =
  \block_length((char *)s) ≡ 0 ∧ \offset((char *)s) ≡ 0;
 */
/*@
predicate valid_or_empty{L}(void *s, size_t n) =
  (empty_block(s) ∨ \valid_read((char *)s)) ∧
  \valid((char *)s + (0 .. n - 1));
 */
/*@
predicate valid_read_or_empty{L}(void *s, size_t n) =
  (empty_block(s) ∨ \valid_read((char *)s)) ∧
  \valid_read((char *)s + (1 .. n - 1));

*/
/*@ requires valid_s1: valid_read_or_empty(s1, n);
    requires valid_s2: valid_read_or_empty(s2, n);
    requires s1: initialization: \initialized((char *)s1 + (0 .. n - 1));
    requires s2: initialization: \initialized((char *)s2 + (0 .. n - 1));
    requires s1: danglingness: non_escaping(s1, n);
    requires s2: danglingness: non_escaping(s2, n);
    ensures
      logic_spec:
        \result ≡
        memcmp{Pre, Pre}((char *)\old(s1), (char *)\old(s2), \old(n));
    assigns \result;
    assigns \result
      \from (indirect: *((char *)s1 + (0 .. n - 1))),
            (indirect: *((char *)s2 + (0 .. n - 1)));
 */
int memcmp(void const *s1, void const *s2, size_t n);

/*@ requires
      valid:
        valid_read_or_empty(s, n) ∨
        \valid_read((unsigned char *)s + (0 .. memchr_off((char *)s, c, n)));
    requires
      initialization:
        \initialized((unsigned char *)s + (0 .. n - 1)) ∨
        \initialized((unsigned char *)s + (0 .. memchr_off((char *)s, c, n)));
    requires
      danglingness:
        non_escaping(s, n) ∨
        non_escaping(s, (size_t)((int)(memchr_off((char *)s, c, n) + 1)));
    assigns \result;
    assigns \result \from s, c, *((unsigned char *)s + (0 .. n - 1));
    
    behavior found:
      assumes char_found: memchr((char *)s, c, n) ≢ (0 ≢ 0);
      ensures result_same_base: \base_addr(\result) ≡ \base_addr(\old(s));
      ensures result_char: (int)*((char *)\result) ≡ \old(c);
      ensures
        result_in_str:
          ∀ ℤ i;
            (0 ≤ i < \old(n) ⇒
             *((unsigned char *)\old(s) + i) ≡ \old(c)) ⇒
            (unsigned char *)\result ≤ (unsigned char *)\old(s) + i;
    
    behavior not_found:
      assumes char_not_found: memchr((char *)s, c, n) ≡ (0 ≢ 0);
      ensures result_null: \result ≡ \null;
 */
void *memchr(void const *s, int c, size_t n);

/*@ requires valid_dest: valid_or_empty(dest, n);
    requires valid_src: valid_read_or_empty(src, n);
    requires
      separation:
        \separated((char *)dest + (0 .. n - 1), (char *)src + (0 .. n - 1));
    ensures
      copied_contents:
        memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡
        0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
void *memcpy(void * restrict dest, void const * restrict src, size_t n);

/*@ requires valid_dest: valid_or_empty(dest, n);
    requires valid_src: valid_read_or_empty(src, n);
    ensures
      copied_contents:
        memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡
        0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
void *memmove(void *dest, void const *src, size_t n);

/*@ requires valid_s: valid_or_empty(s, n);
    ensures
      acsl_c_equiv: memset((char *)\old(s), \old(c), \old(n)) ≢ (0 ≢ 0);
    ensures result_ptr: \result ≡ \old(s);
    assigns *((char *)s + (0 .. n - 1)), \result;
    assigns *((char *)s + (0 .. n - 1)) \from c;
    assigns \result \from s;
 */
void *memset(void *s, int c, size_t n);

/*@ requires valid_string_s: valid_read_string(s);
    ensures acsl_c_equiv: \result ≡ strlen(\old(s));
    assigns \result;
    assigns \result \from (indirect: *(s + (0 ..)));
 */
size_t strlen(char const *s);

/*@ requires valid_string_s: valid_read_nstring(s, n);
    ensures
      result_bounded: \result ≡ strlen(\old(s)) ∨ \result ≡ \old(n);
    assigns \result;
    assigns \result \from (indirect: *(s + (0 .. n - 1))), (indirect: n);
 */
size_t strnlen(char const *s, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    ensures acsl_c_equiv: \result ≡ strcmp(\old(s1), \old(s2));
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
int strcmp(char const *s1, char const *s2);

/*@ requires valid_string_s1: valid_read_nstring(s1, n);
    requires valid_string_s2: valid_read_nstring(s2, n);
    ensures acsl_c_equiv: \result ≡ strncmp(\old(s1), \old(s2), \old(n));
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
int strncmp(char const *s1, char const *s2, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
int strcoll(char const *s1, char const *s2);

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result
      \from s, (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: c);
    
    behavior found:
      assumes char_found: strchr(s, c) ≢ (0 ≢ 0);
      ensures result_char: *\result ≡ (char)\old(c);
      ensures result_same_base: \base_addr(\result) ≡ \base_addr(\old(s));
      ensures
        result_in_length: \old(s) ≤ \result ≤ \old(s) + strlen(\old(s));
      ensures result_valid_string: valid_read_string(\result);
      ensures
        result_first_occur:
          ∀ char *p; \old(s) ≤ p < \result ⇒ *p ≢ (char)\old(c);
    
    behavior not_found:
      assumes char_not_found: strchr(s, c) ≡ (0 ≢ 0);
      ensures result_null: \result ≡ \null;
    
    behavior default:
      ensures
        result_null_or_same_base:
          \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
char *strchr(char const *s, int c);

/*@ requires valid_string_s: valid_read_string(s);
    ensures
      result_same_base: \subset(\result, \old(s) + (0 .. strlen(\old(s))));
    assigns \result;
    assigns \result
      \from s, (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: c);
 */
char *strchrnul(char const *s, int c);

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), c;
    
    behavior found:
      assumes char_found: strchr(s, c) ≢ (0 ≢ 0);
      ensures result_char: (int)*\result ≡ \old(c);
      ensures result_same_base: \base_addr(\result) ≡ \base_addr(\old(s));
      ensures result_valid_string: valid_read_string(\result);
    
    behavior not_found:
      assumes char_not_found: strchr(s, c) ≡ (0 ≢ 0);
      ensures result_null: \result ≡ \null;
    
    behavior default:
      ensures
        result_null_or_same_base:
          \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
char *strrchr(char const *s, int c);

/*@ requires valid_string_s: valid_read_string(s);
    requires valid_string_reject: valid_read_string(reject);
    ensures result_bounded: 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(reject + (0 ..)));
 */
size_t strcspn(char const *s, char const *reject);

/*@ requires valid_string_s: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures result_bounded: 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..)), *(accept + (0 ..));
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(accept + (0 ..)));
 */
size_t strspn(char const *s, char const *accept);

/*@ requires valid_string_s: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures
      result_null_or_same_base:
        \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), *(accept + (0 ..));
 */
char *strpbrk(char const *s, char const *accept);

/*@ requires valid_string_haystack: valid_read_string(haystack);
    requires valid_string_needle: valid_read_string(needle);
    ensures
      result_null_or_in_haystack:
        \result ≡ \null ∨
        (\subset(\result, \old(haystack) + (0 ..)) ∧
         \valid_read(\result) ∧
         memcmp{Pre, Pre}(\result, \old(needle), strlen(\old(needle))) ≡ 0);
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
char *strstr(char const *haystack, char const *needle);

/*@ requires valid_string_haystack: valid_read_string(haystack);
    requires valid_string_needle: valid_read_string(needle);
    ensures
      result_null_or_in_haystack:
        \result ≡ \null ∨
        (\subset(\result, \old(haystack) + (0 ..)) ∧ \valid_read(\result));
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
char *strcasestr(char const *haystack, char const *needle);

char *__fc_strtok_ptr;
/*@ requires valid_string_delim: valid_read_string(delim);
    assigns *(s + (0 ..)), *(__fc_strtok_ptr + (0 ..)), \result,
            __fc_strtok_ptr;
    assigns *(s + (0 ..))
      \from *(s + (0 ..)), (indirect: s), (indirect: __fc_strtok_ptr),
            (indirect: *(delim + (0 ..)));
    assigns *(__fc_strtok_ptr + (0 ..))
      \from *(__fc_strtok_ptr + (0 ..)), (indirect: s),
            (indirect: __fc_strtok_ptr), (indirect: *(delim + (0 ..)));
    assigns \result
      \from s, __fc_strtok_ptr, (indirect: *(s + (0 ..))),
            (indirect: *(__fc_strtok_ptr + (0 ..))),
            (indirect: *(delim + (0 ..)));
    assigns __fc_strtok_ptr
      \from \old(__fc_strtok_ptr), s,
            (indirect: *(__fc_strtok_ptr + (0 ..))),
            (indirect: *(delim + (0 ..)));
    
    behavior new_str:
      assumes s_not_null: s ≢ \null;
      requires
        valid_string_s_or_delim_not_found:
          valid_string(s) ∨
          (valid_read_string(s) ∧
           (∀ int i;
              0 ≤ i < strlen(delim) ⇒
              strchr(s, *(delim + i)) ≡ (0 ≢ 0)));
      ensures
        result_subset:
          \result ≡ \null ∨ \subset(\result, \old(s) + (0 ..));
      ensures ptr_subset: \subset(__fc_strtok_ptr, \old(s) + (0 ..));
      assigns __fc_strtok_ptr, *(s + (0 ..)), \result;
      assigns __fc_strtok_ptr
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
      assigns *(s + (0 ..))
        \from *(s + (0 ..)), (indirect: s), (indirect: *(delim + (0 ..)));
      assigns \result
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
    
    behavior resume_str:
      assumes s_null: s ≡ \null;
      requires not_first_call: __fc_strtok_ptr ≢ \null;
      ensures
        result_subset:
          \result ≡ \null ∨
          \subset(\result, \old(__fc_strtok_ptr) + (0 ..));
      ensures
        ptr_subset: \subset(__fc_strtok_ptr, \old(__fc_strtok_ptr) + (0 ..));
      assigns *(__fc_strtok_ptr + (0 ..)), __fc_strtok_ptr, \result;
      assigns *(__fc_strtok_ptr + (0 ..))
        \from *(__fc_strtok_ptr + (0 ..)), (indirect: __fc_strtok_ptr),
              (indirect: *(delim + (0 ..)));
      assigns __fc_strtok_ptr
        \from \old(__fc_strtok_ptr), (indirect: *(__fc_strtok_ptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
      assigns \result
        \from __fc_strtok_ptr, (indirect: *(__fc_strtok_ptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
    
    complete behaviors resume_str, new_str;
    disjoint behaviors resume_str, new_str;
 */
char *strtok(char * restrict s, char const * restrict delim);

/*@ requires valid_string_delim: valid_read_string(delim);
    requires valid_saveptr: \valid(saveptr);
    assigns *(s + (0 ..)), *(*saveptr + (0 ..)), \result, *saveptr;
    assigns *(s + (0 ..))
      \from *(s + (0 ..)), (indirect: s), (indirect: *saveptr),
            (indirect: *(delim + (0 ..)));
    assigns *(*saveptr + (0 ..))
      \from *(*saveptr + (0 ..)), (indirect: s), (indirect: *saveptr),
            (indirect: *(delim + (0 ..)));
    assigns \result
      \from s, *saveptr, (indirect: *(s + (0 ..))),
            (indirect: *(*saveptr + (0 ..))), (indirect: *(delim + (0 ..)));
    assigns *saveptr
      \from \old(*saveptr), s, (indirect: *(*saveptr + (0 ..))),
            (indirect: *(delim + (0 ..)));
    
    behavior new_str:
      assumes s_not_null: s ≢ \null;
      requires
        valid_string_s_or_delim_not_found:
          valid_string(s) ∨
          (valid_read_string(s) ∧
           (∀ int i;
              0 ≤ i < strlen(delim) ⇒
              strchr(s, *(delim + i)) ≡ (0 ≢ 0)));
      ensures
        result_subset:
          \result ≡ \null ∨ \subset(\result, \old(s) + (0 ..));
      ensures initialization: \initialized(\old(saveptr));
      ensures saveptr_subset: \subset(*\old(saveptr), \old(s) + (0 ..));
      assigns *saveptr, *(s + (0 ..)), \result;
      assigns *saveptr
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
      assigns *(s + (0 ..))
        \from *(s + (0 ..)), (indirect: s), (indirect: *(delim + (0 ..)));
      assigns \result
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
    
    behavior resume_str:
      assumes s_null: s ≡ \null;
      requires not_first_call: *saveptr ≢ \null;
      requires saveptr: initialization: \initialized(saveptr);
      ensures
        result_subset:
          \result ≡ \null ∨ \subset(\result, \old(*saveptr) + (0 ..));
      ensures
        saveptr_subset: \subset(*\old(saveptr), \old(*saveptr) + (0 ..));
      assigns *(*saveptr + (0 ..)), *saveptr, \result;
      assigns *(*saveptr + (0 ..))
        \from *(*saveptr + (0 ..)), (indirect: *saveptr),
              (indirect: *(delim + (0 ..)));
      assigns *saveptr
        \from \old(*saveptr), (indirect: *(*saveptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
      assigns \result
        \from *saveptr, (indirect: *(*saveptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
    
    complete behaviors resume_str, new_str;
    disjoint behaviors resume_str, new_str;
 */
char *strtok_r(char * restrict s, char const * restrict delim,
               char ** restrict saveptr);

/*@ requires
      valid_string_stringp: \valid(stringp) ∧ valid_string(*stringp);
    requires valid_string_delim: valid_read_string(delim);
    assigns *stringp, \result;
    assigns *stringp \from *(delim + (..)), *(*(stringp + (..)));
    assigns \result \from *(delim + (..)), *(*(stringp + (..)));
 */
char *strsep(char **stringp, char const *delim);

char __fc_strerror[64];
char * const __fc_p_strerror = __fc_strerror;
/*@ ensures result_internal_str: \result ≡ __fc_p_strerror;
    ensures result_nul_terminated: *(\result + 63) ≡ 0;
    ensures result_valid_string: valid_read_string(\result);
    assigns \result;
    assigns \result \from __fc_p_strerror, (indirect: errnum);
 */
char *strerror(int errnum);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_string: \valid(dest + (0 .. strlen(src)));
    requires
      separation:
        \separated(dest + (0 .. strlen(src)), src + (0 .. strlen(src)));
    ensures equal_contents: strcmp(\old(dest), \old(src)) ≡ 0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (0 .. strlen{Old}(src))), \result;
    assigns *(dest + (0 .. strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *strcpy(char * restrict dest, char const * restrict src);

/*@ requires valid_nstring_src: valid_read_nstring(src, n);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    requires separation: \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    ensures result_ptr: \result ≡ \old(dest);
    ensures initialization: \initialized(\old(dest) + (0 .. \old(n) - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 .. n - 1));
    assigns \result \from dest;
    
    behavior complete:
      assumes src_fits: strlen(src) < n;
      ensures equal_after_copy: strcmp(\old(dest), \old(src)) ≡ 0;
    
    behavior partial:
      assumes src_too_long: n ≤ strlen(src);
      ensures
        equal_prefix:
          memcmp{Post, Post}(\old(dest), \old(src), \old(n)) ≡ 0;
 */
char *strncpy(char * restrict dest, char const * restrict src, size_t n);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    requires
      separation:
        \separated(
          dest + (0 .. n - 1), src + (0 .. \max(n - 1, strlen(src)))
          );
    ensures
      initialization:
        \initialized(\old(dest) + (0 .. \min(strlen(\old(src)), \old(n) - 1)));
    ensures bounded_result: \result ≡ strlen(\old(src));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 .. n - 1));
    assigns \result
      \from (indirect: src), (indirect: *(src + (0 .. n - 1))), (indirect: n);
 */
size_t strlcpy(char * restrict dest, char const * restrict src, size_t n);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_string: \valid(dest + (0 .. strlen(src)));
    requires
      separation:
        \separated(dest + (0 .. strlen(src)), src + (0 .. strlen(src)));
    ensures equal_contents: strcmp(\old(dest), \old(src)) ≡ 0;
    ensures points_to_end: \result ≡ \old(dest) + strlen(\old(dest));
    assigns *(dest + (0 .. strlen{Old}(src))), \result;
    assigns *(dest + (0 .. strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *stpcpy(char * restrict dest, char const * restrict src);

/*@ requires valid_string_src: valid_read_string(src);
    requires valid_string_dest: valid_string(dest);
    requires room_string: \valid(dest + (0 .. strlen(dest) + strlen(src)));
    ensures
      sum_of_lengths: strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
    ensures
      dest: initialization:
        \initialized(\old(dest) + (0 .. \old(strlen(dest) + strlen(src))));
    ensures
      dest_null_terminated:
        *(\old(dest) + \old(strlen(dest) + strlen(src))) ≡ 0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest +
              (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
            \result;
    assigns
    *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *strcat(char * restrict dest, char const * restrict src);

/*@ requires valid_nstring_src: valid_read_nstring(src, n);
    requires valid_string_dest: valid_string(dest);
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)), \result;
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
      \from *(src + (0 .. n));
    assigns \result \from dest;
    
    behavior complete:
      assumes
        valid_string_src_fits: valid_read_string(src) ∧ strlen(src) ≤ n;
      requires
        room_string: \valid((dest + strlen(dest)) + (0 .. strlen(src)));
      ensures
        sum_of_lengths:
          strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
      assigns *(dest +
                (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
              \result;
      assigns
      *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
    
    behavior partial:
      assumes
        valid_string_src_too_large:
          ¬(valid_read_string(src) ∧ strlen(src) ≤ n);
      requires room_string: \valid((dest + strlen(dest)) + (0 .. n));
      ensures
        sum_of_bounded_lengths:
          strlen(\old(dest)) ≡ \old(strlen(dest)) + \old(n);
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)),
              \result;
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
 */
char *strncat(char * restrict dest, char const * restrict src, size_t n);

/*@ requires valid_string_src: valid_read_string(src);
    requires valid_string_dest: valid_string(dest);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    ensures
      bounded_result: \result ≡ strlen(\old(dest)) + strlen(\old(src));
    assigns *(dest + (strlen{Old}(dest) .. n)), \result;
    assigns *(dest + (strlen{Old}(dest) .. n))
      \from (indirect: n), *(src + (0 .. strlen{Old}(src)));
    assigns \result
      \from (indirect: src), (indirect: *(src + (0 .. n - 1))), (indirect: n);
 */
size_t strlcat(char * restrict dest, char const * restrict src, size_t n);

/*@ requires valid_dest: \valid(dest + (0 .. n - 1));
    requires valid_string_src: valid_read_string(src);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from (indirect: *(src + (0 ..))), (indirect: n);
    assigns \result \from dest;
 */
size_t strxfrm(char * restrict dest, char const * restrict src, size_t n);

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result
      \from (indirect: *(s + (0 .. strlen{Old}(s)))),
            (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(strlen(s));
      ensures allocation: \fresh{Old, Here}(\result,strlen(\old(s)));
      ensures
        result_valid_string_and_same_contents:
          valid_string(\result) ∧ strcmp(\result, \old(s)) ≡ 0;
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status \from (indirect: s), __fc_heap_status;
      assigns \result
        \from (indirect: *(s + (0 .. strlen{Old}(s)))),
              (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(strlen(s));
      ensures result_null: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
 */
char *strdup(char const *s);

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result
      \from (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: n),
            (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(\min(strlen(s), n + 1));
      ensures
        allocation:
          \fresh{Old, Here}(\result,\min(strlen(\old(s)), \old(n) + 1));
      ensures
        result_valid_string_bounded_and_same_prefix:
          \valid(\result + (0 .. \min(strlen(\old(s)), \old(n)))) ∧
          valid_string(\result) ∧ strlen(\result) ≤ \old(n) ∧
          strncmp(\result, \old(s), \old(n)) ≡ 0;
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status
        \from (indirect: s), (indirect: n), __fc_heap_status;
      assigns \result
        \from (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: n),
              (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(\min(strlen(s), n + 1));
      ensures result_null: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
 */
char *strndup(char const *s, size_t n);

char __fc_strsignal[64];
char * const __fc_p_strsignal = __fc_strsignal;
/*@ ensures result_internal_str: \result ≡ __fc_p_strsignal;
    ensures result_nul_terminated: *(\result + 63) ≡ 0;
    ensures result_valid_string: valid_read_string(\result);
    assigns \result;
    assigns \result \from __fc_p_strsignal, (indirect: signum);
 */
char *strsignal(int signum);

/*@ requires valid_memory_area: \valid((char *)s + (0 .. n - 1));
    ensures
      initialization: s_initialized:
        \initialized((char *)\old(s) + (0 .. \old(n) - 1));
    ensures
      zero_initialized: \subset(*((char *)\old(s) + (0 .. \old(n) - 1)), {0});
    assigns *((char *)s + (0 .. n - 1));
    assigns *((char *)s + (0 .. n - 1)) \from \nothing;
 */
void bzero(void *s, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
int strcasecmp(char const *s1, char const *s2);

/*@ requires valid_string_s1: valid_read_nstring(s1, n);
    requires valid_string_s2: valid_read_nstring(s2, n);
    assigns \result;
    assigns \result
      \from (indirect: n), (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1)));
 */
int strncasecmp(char const *s1, char const *s2, size_t n);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[2];

/*@ requires \valid_read(this); */
void exception::Ctor(struct exception const *this);

/*@ requires \separated(this, exn);
    requires \valid_read(this);
    requires \valid_read(exn);
 */
void exception::Ctor(struct exception const *this,
                     struct exception const *exn);

/*@ requires \valid(this);
    requires \valid_read(exn);
    ensures \valid(\result);
 */
struct exception *operator=(struct exception *this,
                            struct exception const *exn);

/*@ requires \valid_read(this); */
void exception::Dtor(struct exception const *this);

/*@ requires \valid_read(this); */
char const *what(struct exception const *this);

void bad_exception::Dtor(struct bad_exception const *this);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];

struct _frama_c_vmt_content _frama_c_vmt[2];

/*@ requires \valid_read(this); */
void bad_exception::Ctor(struct bad_exception const *this);

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void bad_exception::Ctor(struct bad_exception const *this,
                         struct bad_exception const *__frama_c_arg_0);

/*@ requires \valid(this);
    requires \valid_read(__frama_c_arg_0);
    ensures \valid(\result);
 */
struct bad_exception *operator=(struct bad_exception *this,
                                struct bad_exception const *__frama_c_arg_0);

/*@ requires \valid_read(this); */
char const *what(struct bad_exception const *this);

/*@ requires \valid_read(this); */
void bad_exception::Dtor(struct bad_exception const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  exception::Dtor(& this->_frama_c__ZN3stdE9exception);
  return;
}

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];

/*@ requires \valid_read(this); */
void nested_exception::Ctor(struct nested_exception const *this);

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void nested_exception::Ctor(struct nested_exception const *this,
                            struct nested_exception const *__frama_c_arg_0);

/*@ requires \valid(this);
    requires \valid_read(__frama_c_arg_0);
    ensures \valid(\result);
 */
struct nested_exception *operator=(struct nested_exception *this,
                                   struct nested_exception const *__frama_c_arg_0);

/*@ requires \valid_read(this); */
void nested_exception::Dtor(struct nested_exception const *this);

/*@ requires \valid_read(this); */
void rethrow_nested(struct nested_exception const *this);

/*@ requires \valid_read(this); */
exception_ptr nested_ptr(struct nested_exception const *this);

int _frama_c_find_dynamic_cast_aux(struct _frama_c_rtti_name_info_node *target_info,
                                   struct _frama_c_rtti_name_info_content *concrete_base,
                                   int number_of_bases,
                                   int found_shift_object,
                                   int found_shift_vmt, int last_shift_vmt,
                                   int *shift_object, int *distance)
{
  int result = 0;
  struct _frama_c_rtti_name_info_content *cursor = concrete_base;
  int is_over = 0;
  int base_index = 0;
  while (base_index < number_of_bases) {
    if (cursor->value == target_info) {
      if (*distance < 0) goto _LOR;
      else 
        if (*distance >= 1) {
          _LOR:
          {
            if (found_shift_vmt == cursor->shift_vmt) *distance = 0;
            else *distance = 1;
            *shift_object = found_shift_object - cursor->shift_object;
            result = 1;
          }
        }
    }
    else 
      if (cursor->shift_vmt <= found_shift_vmt) {
        int tmp_5;
        if (base_index < number_of_bases - 1) tmp_5 = (cursor + 1)->shift_vmt > found_shift_vmt;
        else {
          int tmp_4;
          if (last_shift_vmt == -1) tmp_4 = 1;
          else 
            if (found_shift_vmt < last_shift_vmt) tmp_4 = 1; else tmp_4 = 0;
          tmp_5 = tmp_4;
        }
        if (tmp_5) {
          int tmp_0;
          int tmp;
          int local_distance = 0;
          int local_shift_object = 0;
          if (base_index < number_of_bases - 1) tmp = (cursor + 1)->shift_vmt;
          else tmp = last_shift_vmt;
          ;
          ;
          ;
          ;
          ;
          tmp_0 = _frama_c_find_dynamic_cast_aux(target_info,
                                                 (cursor->value)->base_classes,
                                                 (cursor->value)->number_of_base_classes,
                                                 found_shift_object - cursor->shift_object,
                                                 found_shift_vmt - cursor->shift_vmt,
                                                 tmp,& local_shift_object,
                                                 & local_distance);
          int local_result = tmp_0;
          if (local_result != 0) 
            if (local_distance >= 0) 
              if (*distance < 0) goto _LOR_0;
              else 
                if (*distance >= local_distance) {
                  _LOR_0:
                  {
                    result = local_result;
                    *shift_object = local_shift_object - cursor->shift_object;
                    *distance = local_distance;
                  }
                }
          is_over = 1;
        }
        else goto _LAND;
      }
      else {
        _LAND: ;
        if (*distance < 0) goto _LOR_2;
        else 
          if (*distance >= 1) {
            _LOR_2:
            {
              int tmp_2;
              int tmp_1;
              int local_distance_0 = 0;
              int local_shift_object_0 = 0;
              if (base_index < number_of_bases + 1) tmp_1 = (cursor + 1)->shift_vmt;
              else tmp_1 = last_shift_vmt;
              ;
              ;
              ;
              ;
              ;
              tmp_2 = _frama_c_find_dynamic_cast_aux(target_info,
                                                     (cursor->value)->base_classes,
                                                     (cursor->value)->number_of_base_classes,
                                                     found_shift_object - cursor->shift_object,
                                                     found_shift_vmt - cursor->shift_vmt,
                                                     tmp_1,
                                                     & local_shift_object_0,
                                                     & local_distance_0);
              int local_result_0 = tmp_2;
              if (local_result_0 != 0) 
                if (local_distance_0 >= 0) 
                  if (*distance < 0) goto _LOR_1;
                  else {
                    int tmp_3;
                    if (is_over == 0) tmp_3 = local_distance_0;
                    else tmp_3 = local_distance_0 + 1;
                    ;
                    if (*distance > tmp_3) {
                      _LOR_1:
                      {
                        result = local_result_0;
                        *shift_object = local_shift_object_0 - cursor->shift_object;
                        *distance = local_distance_0 + 1;
                      }
                    }
                  }
            }
          }
      }
    cursor ++;
    base_index ++;
  }
  return result;
}

int _frama_c_find_dynamic_cast(struct _frama_c_rtti_name_info_node *declared_info,
                               struct _frama_c_vmt *declared_vmt,
                               struct _frama_c_rtti_name_info_node *target_info,
                               int *shift_object)
{
  int __retres;
  int shift_vmt;
  int elaborated_shift_target;
  struct _frama_c_rtti_name_info_content *cursor;
  int number_of_bases;
  int tmp_0;
  struct _frama_c_rtti_name_info_node *concrete_info =
    declared_vmt->rtti_info;
  int elaborated_shift_vmt = 0;
  int elaborated_shift_object = 0;
  int cursor_index = 0;
  int distance = -1;
  if (concrete_info->pvmt > declared_vmt) {
    __retres = 0;
    goto return_label;
  }
  else 
    if (declared_vmt > concrete_info->pvmt + declared_vmt->table_size) {
      __retres = 0;
      goto return_label;
    }
  shift_vmt = declared_vmt - concrete_info->pvmt;
  if (concrete_info == declared_info) {
    *shift_object = 0;
    __retres = target_info == declared_info;
    goto return_label;
  }
  if (target_info == concrete_info) elaborated_shift_target = 0;
  else elaborated_shift_target = -1;
  cursor = concrete_info->base_classes;
  number_of_bases = concrete_info->number_of_base_classes;
  while (1) {
    while (1) {
      if (cursor_index < number_of_bases) {
        if (! (elaborated_shift_vmt + cursor->shift_vmt < shift_vmt)) 
          break;
      }
      else break;
      {
        struct _frama_c_rtti_name_info_content *tmp;
        if (cursor_index < number_of_bases - 1) tmp = cursor + 1;
        else tmp = (struct _frama_c_rtti_name_info_content *)0;
        struct _frama_c_rtti_name_info_content *next_cursor = tmp;
        if (next_cursor != (struct _frama_c_rtti_name_info_content *)0) 
          if (elaborated_shift_vmt + next_cursor->shift_vmt <= shift_vmt) {
            cursor = next_cursor;
            cursor_index ++;
          }
          else break;
        else break;
      }
    }
    if (cursor_index < number_of_bases) {
      elaborated_shift_vmt += cursor->shift_vmt;
      elaborated_shift_object += cursor->shift_object;
      if (cursor->value == target_info) elaborated_shift_target = elaborated_shift_object;
      if (elaborated_shift_vmt == shift_vmt) 
        if (cursor->value == declared_info) {
          if (elaborated_shift_target >= 0) {
            *shift_object = elaborated_shift_target - elaborated_shift_object;
            __retres = 1;
            goto return_label;
          }
          break;
        }
      cursor = (cursor->value)->base_classes;
      number_of_bases = (cursor->value)->number_of_base_classes;
      cursor_index = 0;
    }
    if (! (cursor_index < number_of_bases)) break;
  }
  if (cursor_index >= number_of_bases) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = _frama_c_find_dynamic_cast_aux(target_info,
                                         concrete_info->base_classes,
                                         concrete_info->number_of_base_classes,
                                         elaborated_shift_object,shift_vmt,
                                         -1,shift_object,& distance);
  __retres = tmp_0;
  return_label: return __retres;
}

struct _frama_c_vmt_content _frama_c_vmt[2] =
  {{.method_ptr = (void (*)())(& exception::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& what), .shift_this = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "exception",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 2,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_vmt_content _frama_c_vmt[2] =
  {{.method_ptr = (void (*)())(& bad_exception::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& what), .shift_this = 0}};
struct _frama_c_rtti_name_info_content _frama_c_base_classes[1] =
  {{.value = & _frama_c_rtti_name_info,
    .shift_object = (char *)0 - (char *)(& ((struct bad_exception *)0)->_frama_c__ZN3stdE9exception),
    .shift_vmt = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "bad_exception",
   .base_classes = _frama_c_base_classes,
   .number_of_base_classes = 1,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 2,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_vmt_content _frama_c_vmt[1] =
  {{.method_ptr = (void (*)())(& nested_exception::Dtor), .shift_this = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "nested_exception",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 1,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "allocator",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void default_delete<int>::Ctor(struct default_delete<int> const *this);

void default_delete<int>::Dtor(struct default_delete<int> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void operator()(struct default_delete<int> const *this, int * const o)
{
  free((void *)o);
  return;
}

/*@ requires \valid_read(this); */
void default_delete<int>::Ctor(struct default_delete<int> const *this)
{
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void default_delete<int>::Ctor(struct default_delete<int> const *this,
                               struct default_delete<int> const *__frama_c_arg_0)
{
  return;
}

/*@ requires \valid(this);
    requires \valid_read(__frama_c_arg_0);
    ensures \valid(\result);
 */
struct default_delete<int> *operator=(struct default_delete<int> *this,
                                      struct default_delete<int> const *__frama_c_arg_0)
{
  return this;
}

/*@ requires \valid_read(this); */
void default_delete<int>::Dtor(struct default_delete<int> const *this)
{
  return;
}

/*@ requires \valid(b);
    requires \valid(a); */
void swap<std::default_delete<int>>(struct default_delete<int> *a,
                                    struct default_delete<int> *b)
{
  struct default_delete<int> *tmp_0;
  struct default_delete<int> *tmp_1;
  struct default_delete<int> tmp;
  default_delete<int>::Ctor(& tmp,(struct default_delete<int> const *)a);
  tmp_0 = operator=(a,(struct default_delete<int> const *)b);
  tmp_1 = operator=(b,(struct default_delete<int> const *)(& tmp));
  default_delete<int>::Dtor((struct default_delete<int> const *)(& tmp));
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "default_delete",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void default_delete<int[]>::Ctor(struct default_delete<int[]> const *this);

void default_delete<int[]>::Ctor(struct default_delete<int[]> const *this,
                                 struct default_delete<int[]> *__frama_c_arg_0);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void operator()(struct default_delete<int[]> const *this, int *ptr)
{
  free((void *)ptr);
  return;
}

/*@ requires \valid_read(this); */
void default_delete<int[]>::Ctor(struct default_delete<int[]> const *this)
{
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid(__frama_c_arg_0);
 */
void default_delete<int[]>::Ctor(struct default_delete<int[]> const *this,
                                 struct default_delete<int[]> *__frama_c_arg_0)
{
  return;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct default_delete<int[]> *forward<std::default_delete<int[]>>(type *t)
{
  return t;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "default_delete",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void default_delete<PlainOldStruct>::Ctor(struct default_delete<PlainOldStruct> const *this);

void default_delete<PlainOldStruct>::Ctor(struct default_delete<PlainOldStruct> const *this,
                                          struct default_delete<PlainOldStruct> *__frama_c_arg_0);

void default_delete<PlainOldStruct>::Dtor(struct default_delete<PlainOldStruct> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

void operator()(struct default_delete<PlainOldStruct> const *this,
                struct PlainOldStruct * const o);

/*@ requires \valid_read(this); */
void default_delete<PlainOldStruct>::Ctor(struct default_delete<PlainOldStruct> const *this)
{
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void default_delete<PlainOldStruct>::Ctor(struct default_delete<PlainOldStruct> const *this,
                                          struct default_delete<PlainOldStruct> const *__frama_c_arg_0)
{
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid(__frama_c_arg_0);
 */
void default_delete<PlainOldStruct>::Ctor(struct default_delete<PlainOldStruct> const *this,
                                          struct default_delete<PlainOldStruct> *__frama_c_arg_0)
{
  return;
}

/*@ requires \valid(this);
    requires \valid_read(__frama_c_arg_0);
    ensures \valid(\result);
 */
struct default_delete<PlainOldStruct> *operator=(struct default_delete<PlainOldStruct> *this,
                                                 struct default_delete<PlainOldStruct> const *__frama_c_arg_0)
{
  return this;
}

/*@ requires \valid_read(this); */
void default_delete<PlainOldStruct>::Dtor(struct default_delete<PlainOldStruct> const *this)
{
  return;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct default_delete<PlainOldStruct> *forward<std::default_delete<PlainOldStruct>>
(type *t)
{
  return t;
}

/*@ requires \valid(b);
    requires \valid(a); */
void swap<std::default_delete<PlainOldStruct>>(struct default_delete<PlainOldStruct> *a,
                                               struct default_delete<PlainOldStruct> *b)
{
  struct default_delete<PlainOldStruct> *tmp_0;
  struct default_delete<PlainOldStruct> *tmp_1;
  struct default_delete<PlainOldStruct> tmp;
  default_delete<PlainOldStruct>::Ctor(& tmp,
                                       (struct default_delete<PlainOldStruct> const *)a);
  tmp_0 = operator=(a,(struct default_delete<PlainOldStruct> const *)b);
  tmp_1 = operator=(b,(struct default_delete<PlainOldStruct> const *)(& tmp));
  default_delete<PlainOldStruct>::Dtor((struct default_delete<PlainOldStruct> const *)(& tmp));
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "default_delete",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void default_delete<ClassTemplate<int,0>>::Ctor(struct default_delete<ClassTemplate<int,0>> const *this);

void default_delete<ClassTemplate<int,0>>::Ctor(struct default_delete<ClassTemplate<int,0>> const *this,
                                                struct default_delete<ClassTemplate<int,0>> *__frama_c_arg_0);

void default_delete<ClassTemplate<int,0>>::Dtor(struct default_delete<ClassTemplate<int,0>> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

void operator()(struct default_delete<ClassTemplate<int,0>> const *this,
                struct ClassTemplate<int,0> * const o);

/*@ requires \valid_read(this); */
void default_delete<ClassTemplate<int,0>>::Ctor(struct default_delete<ClassTemplate<int,0>> const *this)
{
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void default_delete<ClassTemplate<int,0>>::Ctor(struct default_delete<ClassTemplate<int,0>> const *this,
                                                struct default_delete<ClassTemplate<int,0>> const *__frama_c_arg_0)
{
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid(__frama_c_arg_0);
 */
void default_delete<ClassTemplate<int,0>>::Ctor(struct default_delete<ClassTemplate<int,0>> const *this,
                                                struct default_delete<ClassTemplate<int,0>> *__frama_c_arg_0)
{
  return;
}

/*@ requires \valid(this);
    requires \valid_read(__frama_c_arg_0);
    ensures \valid(\result);
 */
struct default_delete<ClassTemplate<int,0>> *operator=(struct default_delete<ClassTemplate<int,0>> *this,
                                                       struct default_delete<ClassTemplate<int,0>> const *__frama_c_arg_0)
{
  return this;
}

/*@ requires \valid_read(this); */
void default_delete<ClassTemplate<int,0>>::Dtor(struct default_delete<ClassTemplate<int,0>> const *this)
{
  return;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct default_delete<ClassTemplate<int,0>> *forward<std::default_delete<ClassTemplate<int,0>>>
(type *t)
{
  return t;
}

/*@ requires \valid(b);
    requires \valid(a); */
void swap<std::default_delete<ClassTemplate<int,0>>>(struct default_delete<ClassTemplate<int,0>> *a,
                                                     struct default_delete<ClassTemplate<int,0>> *b)
{
  struct default_delete<ClassTemplate<int,0>> *tmp_0;
  struct default_delete<ClassTemplate<int,0>> *tmp_1;
  struct default_delete<ClassTemplate<int,0>> tmp;
  default_delete<ClassTemplate<int,0>>::Ctor(& tmp,
                                             (struct default_delete<ClassTemplate<int,0>> const *)a);
  tmp_0 = operator=(a,(struct default_delete<ClassTemplate<int,0>> const *)b);
  tmp_1 = operator=(b,
                    (struct default_delete<ClassTemplate<int,0>> const *)(& tmp));
  default_delete<ClassTemplate<int,0>>::Dtor((struct default_delete<ClassTemplate<int,0>> const *)(& tmp));
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "default_delete",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[7];

/*@ requires \valid(this); */
void unlink(struct __shared_ref_base *this);

/*@ requires \valid(this); */
void link(struct __shared_ref_base *this);

/*@ requires \valid(this); */
long count(struct __shared_ref_base *this);

/*@ requires \valid(this); */
void weak_unlink(struct __shared_ref_base *this);

/*@ requires \valid(this); */
void weak_link(struct __shared_ref_base *this);

/*@ requires \valid(this); */
struct __shared_ref_base *ref(struct __shared_ref_base *this);

/*@ requires \valid(this); */
void *get_deleter(struct __shared_ref_base *this)
{
  void *__retres;
  __retres = (void *)0;
  return __retres;
}

struct _frama_c_vmt_content _frama_c_vmt[7] =
  {{.method_ptr = (void (*)())(& unlink), .shift_this = 0},
   {.method_ptr = (void (*)())(& link), .shift_this = 0},
   {.method_ptr = (void (*)())(& count), .shift_this = 0},
   {.method_ptr = (void (*)())(& weak_unlink), .shift_this = 0},
   {.method_ptr = (void (*)())(& weak_link), .shift_this = 0},
   {.method_ptr = (void (*)())(& ref), .shift_this = 0},
   {.method_ptr = (void (*)())(& get_deleter), .shift_this = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__shared_ref_base",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 7,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];

struct _frama_c_vmt_content _frama_c_vmt[7];

/*@ requires \valid_read(this); */
void __shared_ref<void>::Ctor(struct __shared_ref<void> const *this, void *p);

/*@ requires \valid(this); */
void unlink(struct __shared_ref<void> *this);

/*@ requires \valid(this); */
void link(struct __shared_ref<void> *this);

/*@ requires \valid(this); */
long count(struct __shared_ref<void> *this);

/*@ requires \valid(this); */
void weak_unlink(struct __shared_ref<void> *this);

/*@ requires \valid(this); */
void weak_link(struct __shared_ref<void> *this);

/*@ requires \valid(this); */
struct __shared_ref_base *ref(struct __shared_ref<void> *this);

struct _frama_c_vmt_content _frama_c_vmt[7] =
  {{.method_ptr = (void (*)())(& unlink), .shift_this = 0},
   {.method_ptr = (void (*)())(& link), .shift_this = 0},
   {.method_ptr = (void (*)())(& count), .shift_this = 0},
   {.method_ptr = (void (*)())(& weak_unlink), .shift_this = 0},
   {.method_ptr = (void (*)())(& weak_link), .shift_this = 0},
   {.method_ptr = (void (*)())(& ref), .shift_this = 0},
   {.method_ptr = (void (*)())(& get_deleter),
    .shift_this = (char *)(& ((struct __shared_ref<void> *)0)->_frama_c__ZN3stdE17__shared_ref_base) - (char *)(& ((struct __shared_ref<void> *)0)->_frama_c__ZN3stdE17__shared_ref_base)}};
struct _frama_c_rtti_name_info_content _frama_c_base_classes[1] =
  {{.value = & _frama_c_rtti_name_info,
    .shift_object = (char *)0 - (char *)(& ((struct __shared_ref<void> *)0)->_frama_c__ZN3stdE17__shared_ref_base),
    .shift_vmt = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "__shared_ref",
   .base_classes = _frama_c_base_classes,
   .number_of_base_classes = 1,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 7,
   .rtti_info = & _frama_c_rtti_name_info};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void unique_ptr<int,std::default_delete<int>>::Ctor(struct unique_ptr<int,std::default_delete<int>> const *this);

/*@ requires \valid_read(this); */
void unique_ptr<int,std::default_delete<int>>::Ctor(struct unique_ptr<int,std::default_delete<int>> const *this,
                                                    pointer p)
{
  this->__ptr = p;
  default_delete<int>::Ctor(& this->__dlt);
  return;
}

/*@ requires \valid_read(this);
    requires \valid(d); */
void unique_ptr<int,std::default_delete<int>>::Ctor(struct unique_ptr<int,std::default_delete<int>> const *this,
                                                    pointer p, type *d);

/*@ requires \valid_read(this);
    requires \valid(d); */
void unique_ptr<int,std::default_delete<int>>::Ctor(struct unique_ptr<int,std::default_delete<int>> const *this,
                                                    pointer p, type *d);

/*@ requires \separated(this, u);
    requires \valid_read(this);
    requires \valid(u);
 */
void unique_ptr<int,std::default_delete<int>>::Ctor(struct unique_ptr<int,std::default_delete<int>> const *this,
                                                    struct unique_ptr<int,std::default_delete<int>> *u);

/*@ requires \valid_read(this); */
void unique_ptr<int,std::default_delete<int>>::Ctor(struct unique_ptr<int,std::default_delete<int>> const *this,
                                                    nullptr_t __frama_c_arg_0);

/*@ requires \valid_read(this); */
void unique_ptr<int,std::default_delete<int>>::Dtor(struct unique_ptr<int,std::default_delete<int>> const *this)
{
  if (this->__ptr != (int *)0) operator()(& this->__dlt,this->__ptr);
  return;
}

/*@ requires \valid(this);
    requires \valid(u);
    ensures \valid(\result); */
struct unique_ptr<int,std::default_delete<int>> *operator=(struct unique_ptr<int,std::default_delete<int>> *this,
                                                           struct unique_ptr<int,std::default_delete<int>> *u);

/*@ requires \valid(this);
    ensures \valid(\result); */
struct unique_ptr<int,std::default_delete<int>> *operator=(struct unique_ptr<int,std::default_delete<int>> *this,
                                                           nullptr_t __frama_c_arg_0);

/*@ requires \valid_read(this);
    ensures \valid(\result); */
type operator*(struct unique_ptr<int,std::default_delete<int>> const *this)
{
  type __retres;
  __retres = this->__ptr;
  return __retres;
}

/*@ requires \valid_read(this); */
pointer std::unique_ptr<int,std::default_delete<int>>::operator->(struct unique_ptr<int,std::default_delete<int>> const *this);

/*@ requires \valid_read(this); */
pointer get(struct unique_ptr<int,std::default_delete<int>> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
deleter_type *get_deleter(struct unique_ptr<int,std::default_delete<int>> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
deleter_type const *get_deleter(struct unique_ptr<int,std::default_delete<int>> const *this);

/*@ requires \valid_read(this); */
_Bool conversion(bool)(struct unique_ptr<int,std::default_delete<int>> const *this);

/*@ requires \valid(this); */
pointer release(struct unique_ptr<int,std::default_delete<int>> *this)
{
  pointer res = this->__ptr;
  this->__ptr = (int *)0;
  return res;
}

/*@ requires \valid(this); */
void reset(struct unique_ptr<int,std::default_delete<int>> *this, pointer p)
{
  pointer old = this->__ptr;
  this->__ptr = p;
  operator()((struct default_delete<int> const *)(& this->__dlt),old);
  return;
}

/*@ requires \valid(this);
    requires \valid(u); */
void swap(struct unique_ptr<int,std::default_delete<int>> *this,
          struct unique_ptr<int,std::default_delete<int>> *u)
{
  swap<int*>(& this->__ptr,& u->__ptr);
  swap<std::default_delete<int>>(& this->__dlt,& u->__dlt);
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "unique_ptr",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void unique_ptr<int[],std::default_delete<int[]>>::Ctor(struct unique_ptr<int[],std::default_delete<int[]>> const *this);

/*@ requires \valid_read(this); */
void unique_ptr<int[],std::default_delete<int[]>>::Ctor(struct unique_ptr<int[],std::default_delete<int[]>> const *this,
                                                        pointer p)
{
  this->__ptr = p;
  default_delete<int[]>::Ctor(& this->__dlt);
  return;
}

/*@ requires \valid_read(this);
    requires \valid(d); */
void unique_ptr<int[],std::default_delete<int[]>>::Ctor(struct unique_ptr<int[],std::default_delete<int[]>> const *this,
                                                        pointer p, type *d);

/*@ requires \valid_read(this);
    requires \valid(d); */
void unique_ptr<int[],std::default_delete<int[]>>::Ctor(struct unique_ptr<int[],std::default_delete<int[]>> const *this,
                                                        pointer p, type *d);

/*@ requires \separated(this, u);
    requires \valid_read(this);
    requires \valid(u);
 */
void unique_ptr<int[],std::default_delete<int[]>>::Ctor(struct unique_ptr<int[],std::default_delete<int[]>> const *this,
                                                        struct unique_ptr<int[],std::default_delete<int[]>> *u)
{
  struct default_delete<int[]> *tmp;
  this->__ptr = u->__ptr;
  tmp = forward<std::default_delete<int[]>>(& u->__dlt);
  ;
  default_delete<int[]>::Ctor(& this->__dlt,tmp);
  u->__ptr = (int *)0;
  return;
}

/*@ requires \valid_read(this); */
void unique_ptr<int[],std::default_delete<int[]>>::Dtor(struct unique_ptr<int[],std::default_delete<int[]>> const *this)
{
  if (this->__ptr != (int *)0) operator()(& this->__dlt,this->__ptr);
  return;
}

/*@ requires \valid(this);
    requires \valid(u);
    ensures \valid(\result); */
struct unique_ptr<int[],std::default_delete<int[]>> *operator=(struct unique_ptr<int[],std::default_delete<int[]>> *this,
                                                               struct unique_ptr<int[],std::default_delete<int[]>> *u);

/*@ requires \valid(this);
    ensures \valid(\result); */
struct unique_ptr<int[],std::default_delete<int[]>> *operator=(struct unique_ptr<int[],std::default_delete<int[]>> *this,
                                                               nullptr_t __frama_c_arg_0);

/*@ requires \valid_read(this);
    ensures \valid(\result); */
int *operator[](struct unique_ptr<int[],std::default_delete<int[]>> const *this,
                size_t i)
{
  int *__retres;
  __retres = this->__ptr + i;
  return __retres;
}

/*@ requires \valid_read(this); */
pointer get(struct unique_ptr<int[],std::default_delete<int[]>> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
deleter_type *get_deleter(struct unique_ptr<int[],std::default_delete<int[]>> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
deleter_type const *get_deleter(struct unique_ptr<int[],std::default_delete<int[]>> const *this);

/*@ requires \valid_read(this); */
_Bool conversion(bool)(struct unique_ptr<int[],std::default_delete<int[]>> const *this);

/*@ requires \valid(this); */
pointer release(struct unique_ptr<int[],std::default_delete<int[]>> *this)
{
  pointer res = this->__ptr;
  this->__ptr = (int *)0;
  return res;
}

/*@ requires \valid(this); */
void reset(struct unique_ptr<int[],std::default_delete<int[]>> *this,
           pointer p);

/*@ requires \valid(this); */
void reset(struct unique_ptr<int[],std::default_delete<int[]>> *this,
           nullptr_t __frama_c_arg_0);

/*@ requires \valid(this);
    requires \valid(u); */
void swap(struct unique_ptr<int[],std::default_delete<int[]>> *this,
          struct unique_ptr<int[],std::default_delete<int[]>> *u);

/*@ requires \valid(t);
    ensures \valid(\result); */
struct unique_ptr<int[],std::default_delete<int[]>> *forward<std::unique_ptr<int[],std::default_delete<int[]>>>
(type *t)
{
  return t;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "unique_ptr",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this);

/*@ requires \valid_read(this); */
void unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this,
 pointer p)
{
  this->__ptr = p;
  default_delete<PlainOldStruct>::Ctor(& this->__dlt);
  return;
}

/*@ requires \valid_read(this);
    requires \valid(d); */
void unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this,
 pointer p, type *d);

/*@ requires \valid_read(this);
    requires \valid(d); */
void unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this,
 pointer p, type *d);

/*@ requires \separated(this, u);
    requires \valid_read(this);
    requires \valid(u);
 */
void unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this,
 struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *u)
{
  struct default_delete<PlainOldStruct> *tmp;
  this->__ptr = u->__ptr;
  tmp = forward<std::default_delete<PlainOldStruct>>(& u->__dlt);
  ;
  default_delete<PlainOldStruct>::Ctor(& this->__dlt,tmp);
  u->__ptr = (struct PlainOldStruct *)0;
  return;
}

/*@ requires \valid_read(this); */
void unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this,
 nullptr_t __frama_c_arg_0);

/*@ requires \valid_read(this); */
void unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this)
{
  if (this->__ptr != (struct PlainOldStruct *)0) operator()(& this->__dlt,
                                                            this->__ptr);
  return;
}

/*@ requires \valid(this);
    requires \valid(u);
    ensures \valid(\result); */
struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *operator=
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *this,
 struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *u);

/*@ requires \valid(this);
    ensures \valid(\result); */
struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *operator=
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *this,
 nullptr_t __frama_c_arg_0);

/*@ requires \valid_read(this);
    ensures \valid(\result); */
type operator*(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this);

/*@ requires \valid_read(this); */
pointer std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::operator->
(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this)
{
  pointer __retres;
  __retres = this->__ptr;
  return __retres;
}

/*@ requires \valid_read(this); */
pointer get(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
deleter_type *get_deleter(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
deleter_type const *get_deleter(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this);

/*@ requires \valid_read(this); */
_Bool conversion(bool)(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *this);

/*@ requires \valid(this); */
pointer release(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *this)
{
  pointer res = this->__ptr;
  this->__ptr = (struct PlainOldStruct *)0;
  return res;
}

/*@ requires \valid(this); */
void reset(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *this,
           pointer p)
{
  pointer old = this->__ptr;
  this->__ptr = p;
  operator()((struct default_delete<PlainOldStruct> const *)(& this->__dlt),
             old);
  return;
}

/*@ requires \valid(this);
    requires \valid(u); */
void swap(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *this,
          struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *u)
{
  swap<PlainOldStruct*>(& this->__ptr,& u->__ptr);
  swap<std::default_delete<PlainOldStruct>>(& this->__dlt,& u->__dlt);
  return;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *forward<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>>
(type *t)
{
  return t;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "unique_ptr",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this);

/*@ requires \valid_read(this); */
void unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this,
 pointer p)
{
  this->__ptr = p;
  default_delete<ClassTemplate<int,0>>::Ctor(& this->__dlt);
  return;
}

/*@ requires \valid_read(this);
    requires \valid(d); */
void unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this,
 pointer p, type *d);

/*@ requires \valid_read(this);
    requires \valid(d); */
void unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this,
 pointer p, type *d);

/*@ requires \separated(this, u);
    requires \valid_read(this);
    requires \valid(u);
 */
void unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this,
 struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *u)
{
  struct default_delete<ClassTemplate<int,0>> *tmp;
  this->__ptr = u->__ptr;
  tmp = forward<std::default_delete<ClassTemplate<int,0>>>(& u->__dlt);
  ;
  default_delete<ClassTemplate<int,0>>::Ctor(& this->__dlt,tmp);
  u->__ptr = (struct ClassTemplate<int,0> *)0;
  return;
}

/*@ requires \valid_read(this); */
void unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this,
 nullptr_t __frama_c_arg_0);

/*@ requires \valid_read(this); */
void unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this)
{
  if (this->__ptr != (struct ClassTemplate<int,0> *)0) operator()(& this->__dlt,
                                                                  this->__ptr);
  return;
}

/*@ requires \valid(this);
    requires \valid(u);
    ensures \valid(\result); */
struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *operator=
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *this,
 struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *u);

/*@ requires \valid(this);
    ensures \valid(\result); */
struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *operator=
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *this,
 nullptr_t __frama_c_arg_0);

/*@ requires \valid_read(this);
    ensures \valid(\result); */
type operator*(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this);

/*@ requires \valid_read(this); */
pointer std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::operator->
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this)
{
  pointer __retres;
  __retres = this->__ptr;
  return __retres;
}

/*@ requires \valid_read(this); */
pointer get(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this);

/*@ requires \valid(this);
    ensures \valid(\result); */
deleter_type *get_deleter(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *this);

/*@ requires \valid_read(this);
    ensures \valid_read(\result); */
deleter_type const *get_deleter(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this);

/*@ requires \valid_read(this); */
_Bool conversion(bool)(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *this);

/*@ requires \valid(this); */
pointer release(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *this)
{
  pointer res = this->__ptr;
  this->__ptr = (struct ClassTemplate<int,0> *)0;
  return res;
}

/*@ requires \valid(this); */
void reset(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *this,
           pointer p)
{
  pointer old = this->__ptr;
  this->__ptr = p;
  operator()((struct default_delete<ClassTemplate<int,0>> const *)(& this->__dlt),
             old);
  return;
}

/*@ requires \valid(this);
    requires \valid(u); */
void swap(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *this,
          struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *u)
{
  swap<ClassTemplate<int,0>*>(& this->__ptr,& u->__ptr);
  swap<std::default_delete<ClassTemplate<int,0>>>(& this->__dlt,& u->__dlt);
  return;
}

/*@ requires \valid(t);
    ensures \valid(\result); */
struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *forward<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>>
(type *t)
{
  return t;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "unique_ptr",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
/*@ requires \valid(y);
    requires \valid(x); */
void swap<int,std::default_delete<int>>(struct unique_ptr<int,std::default_delete<int>> *x,
                                        struct unique_ptr<int,std::default_delete<int>> *y)
{
  swap(x,y);
  return;
}

/*@ requires \valid(y);
    requires \valid(x); */
void swap<PlainOldStruct,std::default_delete<PlainOldStruct>>(struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *x,
                                                              struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *y)
{
  swap(x,y);
  return;
}

/*@ requires \valid(y);
    requires \valid(x); */
void swap<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>
(struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *x,
 struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *y)
{
  swap(x,y);
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

void bad_weak_ptr::Dtor(struct bad_weak_ptr const *this);

struct _frama_c_vmt _frama_c_vmt_header;

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];

struct _frama_c_vmt_content _frama_c_vmt[2];

/*@ requires \valid_read(this); */
void bad_weak_ptr::Ctor(struct bad_weak_ptr const *this)
{
  exception::Ctor(& this->_frama_c__ZN3stdE9exception);
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  return;
}

/*@ requires \valid_read(this); */
void bad_weak_ptr::Dtor(struct bad_weak_ptr const *this)
{
  *((struct _frama_c_vmt **)this) = & _frama_c_vmt_header;
  exception::Dtor(& this->_frama_c__ZN3stdE9exception);
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void shared_ptr<void>::Ctor(struct shared_ptr<void> const *this)
{
  this->_ref = (struct __shared_ref_base *)0;
  return;
}

void shared_ptr<void>::Ctor(struct shared_ptr<void> const *this,
                            struct shared_ptr<void> const *r);

/*@ requires \separated(this, r);
    requires \valid_read(this);
    requires \valid(r);
 */
void shared_ptr<void>::Ctor(struct shared_ptr<void> const *this,
                            struct shared_ptr<void> *r)
{
  this->__ptr = r->__ptr;
  this->_ref = r->_ref;
  r->__ptr = (void *)0;
  r->_ref = (struct __shared_ref_base *)0;
  return;
}

/*@ requires \valid_read(this); */
void shared_ptr<void>::Ctor(struct shared_ptr<void> const *this,
                            nullptr_t __frama_c_arg_0)
{
  this->_ref = (struct __shared_ref_base *)0;
  return;
}

/*@ requires \valid_read(this); */
void shared_ptr<void>::Dtor(struct shared_ptr<void> const *this)
{
  if (this->_ref != (struct __shared_ref_base *)0) {
    struct _frama_c_vmt_content *__virtual_tmp_0 =
      (*((struct _frama_c_vmt **)this->_ref))->table + 0;
    (*((void (*)(struct __shared_ref_base *))__virtual_tmp_0->method_ptr))
    ((struct __shared_ref_base *)((char *)this->_ref - __virtual_tmp_0->shift_this));
  }
  return;
}

/*@ requires \valid(this);
    requires \valid_read(r);
    ensures \valid(\result); */
struct shared_ptr<void> *operator=(struct shared_ptr<void> *this,
                                   struct shared_ptr<void> const *r)
{
  if (this->_ref != r->_ref) {
    this->__ptr = r->__ptr;
    if (this->_ref != (struct __shared_ref_base *)0) {
      struct _frama_c_vmt_content *__virtual_tmp_1 =
        (*((struct _frama_c_vmt **)this->_ref))->table + 0;
      (*((void (*)(struct __shared_ref_base *))__virtual_tmp_1->method_ptr))
      ((struct __shared_ref_base *)((char *)this->_ref - __virtual_tmp_1->shift_this));
    }
    this->_ref = r->_ref;
    if (this->_ref != (struct __shared_ref_base *)0) {
      struct _frama_c_vmt_content *__virtual_tmp_2 =
        (*((struct _frama_c_vmt **)this->_ref))->table + 1;
      (*((void (*)(struct __shared_ref_base *))__virtual_tmp_2->method_ptr))
      ((struct __shared_ref_base *)((char *)this->_ref - __virtual_tmp_2->shift_this));
    }
  }
  return this;
}

/*@ requires \valid(this);
    requires \valid(r);
    ensures \valid(\result); */
struct shared_ptr<void> *operator=(struct shared_ptr<void> *this,
                                   struct shared_ptr<void> *r)
{
  if (this->_ref != (struct __shared_ref_base *)0) {
    struct _frama_c_vmt_content *__virtual_tmp_3 =
      (*((struct _frama_c_vmt **)this->_ref))->table + 0;
    (*((void (*)(struct __shared_ref_base *))__virtual_tmp_3->method_ptr))
    ((struct __shared_ref_base *)((char *)this->_ref - __virtual_tmp_3->shift_this));
  }
  if (this->_ref != r->_ref) {
    this->__ptr = r->__ptr;
    this->_ref = r->_ref;
  }
  r->_ref = (struct __shared_ref_base *)0;
  return this;
}

/*@ requires \valid(this);
    requires \valid(r); */
void swap(struct shared_ptr<void> *this, struct shared_ptr<void> *r)
{
  if (this->_ref != r->_ref) {
    swap<void*>(& this->__ptr,& r->__ptr);
    swap<std::__shared_ref_base*>(& this->_ref,& r->_ref);
  }
  return;
}

/*@ requires \valid(this); */
void reset(struct shared_ptr<void> *this)
{
  if (this->_ref != (struct __shared_ref_base *)0) {
    struct _frama_c_vmt_content *__virtual_tmp_4 =
      (*((struct _frama_c_vmt **)this->_ref))->table + 0;
    (*((void (*)(struct __shared_ref_base *))__virtual_tmp_4->method_ptr))
    ((struct __shared_ref_base *)((char *)this->_ref - __virtual_tmp_4->shift_this));
    this->_ref = (struct __shared_ref_base *)0;
  }
  return;
}

/*@ requires \valid_read(this); */
void *get(struct shared_ptr<void> const *this)
{
  void *__retres;
  __retres = this->__ptr;
  return __retres;
}

/*@ requires \valid_read(this); */
void *std::shared_ptr<void>::operator->(struct shared_ptr<void> const *this)
{
  void *tmp;
  tmp = get(this);
  return tmp;
}

/*@ requires \valid_read(this); */
long use_count(struct shared_ptr<void> const *this)
{
  long tmp_0;
  struct _frama_c_vmt_content *__virtual_tmp_5 =
    (*((struct _frama_c_vmt **)this->_ref))->table + 2;
  if (this->_ref == (struct __shared_ref_base *)0) tmp_0 = 0L;
  else tmp_0 = (*((long (*)(struct __shared_ref_base *))__virtual_tmp_5->method_ptr))
       ((struct __shared_ref_base *)((char *)this->_ref - __virtual_tmp_5->shift_this));
  return tmp_0;
}

/*@ requires \valid_read(this); */
_Bool unique(struct shared_ptr<void> const *this)
{
  _Bool __retres;
  int tmp_0;
  struct _frama_c_vmt_content *__virtual_tmp_6 =
    (*((struct _frama_c_vmt **)this->_ref))->table + 2;
  if (this->_ref == (struct __shared_ref_base *)0) tmp_0 = 0;
  else {
    long tmp;
    tmp = (*((long (*)(struct __shared_ref_base *))__virtual_tmp_6->method_ptr))
    ((struct __shared_ref_base *)((char *)this->_ref - __virtual_tmp_6->shift_this));
    tmp_0 = tmp == 1L;
  }
  __retres = (_Bool)(tmp_0 != 0);
  return __retres;
}

/*@ requires \valid_read(this); */
_Bool conversion(bool)(struct shared_ptr<void> const *this)
{
  _Bool __retres;
  __retres = (_Bool)(this->__ptr != (void *)0);
  return __retres;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "auto_ptr",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt_content _frama_c_vmt[2] =
  {{.method_ptr = (void (*)())(& bad_weak_ptr::Dtor), .shift_this = 0},
   {.method_ptr = (void (*)())(& what),
    .shift_this = (char *)(& ((struct bad_weak_ptr *)0)->_frama_c__ZN3stdE9exception) - (char *)(& ((struct bad_weak_ptr *)0)->_frama_c__ZN3stdE9exception)}};
struct _frama_c_rtti_name_info_content _frama_c_base_classes[1] =
  {{.value = & _frama_c_rtti_name_info,
    .shift_object = (char *)0 - (char *)(& ((struct bad_weak_ptr *)0)->_frama_c__ZN3stdE9exception),
    .shift_vmt = 0}};
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "bad_weak_ptr",
   .base_classes = _frama_c_base_classes,
   .number_of_base_classes = 1,
   .pvmt = & _frama_c_vmt_header};
struct _frama_c_vmt _frama_c_vmt_header =
  {.table = _frama_c_vmt,
   .table_size = 2,
   .rtti_info = & _frama_c_rtti_name_info};
/*@ requires \separated(this, r);
    requires \valid_read(this);
    requires \valid_read(r);
 */
void shared_ptr<void>::Ctor(struct shared_ptr<void> const *this,
                            struct shared_ptr<void> const *r)
{
  struct _frama_c_vmt_content *__virtual_tmp_7 =
    (*((struct _frama_c_vmt **)r->_ref))->table + 5;
  if (r->_ref == (struct __shared_ref_base *)0) this->_ref = (struct __shared_ref_base *)0;
  else this->_ref = (*((struct __shared_ref_base *(*)(struct __shared_ref_base *))__virtual_tmp_7->method_ptr))
       ((struct __shared_ref_base *)((char *)r->_ref - __virtual_tmp_7->shift_this));
  if (this->_ref != (struct __shared_ref_base *)0) {
    this->__ptr = get(r);
    struct _frama_c_vmt_content *__virtual_tmp_8 =
      (*((struct _frama_c_vmt **)this->_ref))->table + 1;
    (*((void (*)(struct __shared_ref_base *))__virtual_tmp_8->method_ptr))
    ((struct __shared_ref_base *)((char *)this->_ref - __virtual_tmp_8->shift_this));
  }
  else this->__ptr = (void *)0;
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "shared_ptr",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
int test_primitive_payload(int var)
{
  int __retres;
  {
    void *tmp;
    type tmp_0;
    type tmp_1;
    void *tmp_2;
    int *tmp_3;
    type tmp_4;
    int *tmp_5;
    int *tmp_6;
    type *tmp_8;
    struct unique_ptr<int[],std::default_delete<int[]>> *tmp_9;
    struct unique_ptr<int,std::default_delete<int>> up1;
    unique_ptr<int,std::default_delete<int>>::Ctor(& up1,& var);
    tmp = malloc(sizeof(int));
    struct unique_ptr<int,std::default_delete<int>> up2;
    unique_ptr<int,std::default_delete<int>>::Ctor(& up2,(int *)tmp);
    tmp_0 = operator*((struct unique_ptr<int,std::default_delete<int>> const *)(& up1));
    *tmp_0 = var;
    tmp_1 = operator*((struct unique_ptr<int,std::default_delete<int>> const *)(& up2));
    *tmp_1 = 2;
    swap<int,std::default_delete<int>>(& up1,& up2);
    reset(& up1,(int *)0);
    tmp_2 = malloc(sizeof(int) * (unsigned int)2);
    struct unique_ptr<int[],std::default_delete<int[]>> up3;
    unique_ptr<int[],std::default_delete<int[]>>::Ctor(& up3,(int *)tmp_2);
    tmp_3 = operator[]((struct unique_ptr<int[],std::default_delete<int[]>> const *)(& up3),
                       (unsigned int)0);
    tmp_4 = operator*((struct unique_ptr<int,std::default_delete<int>> const *)(& up2));
    *tmp_3 = *tmp_4;
    tmp_5 = operator[]((struct unique_ptr<int[],std::default_delete<int[]>> const *)(& up3),
                       (unsigned int)1);
    tmp_6 = operator[]((struct unique_ptr<int[],std::default_delete<int[]>> const *)(& up3),
                       (unsigned int)0);
    /*@ assert Eva: signed_overflow: *tmp_6 + 1 ≤ 2147483647; */
    *tmp_5 = *tmp_6 + 1;
    int *up2_raw = release(& up2);
    if (up2_raw != & var) {
      free((void *)up2_raw);
      __retres = 0;
      unique_ptr<int[],std::default_delete<int[]>>::Dtor((struct unique_ptr<int[],std::default_delete<int[]>> const *)(& up3));
      unique_ptr<int,std::default_delete<int>>::Dtor((struct unique_ptr<int,std::default_delete<int>> const *)(& up2));
      unique_ptr<int,std::default_delete<int>>::Dtor((struct unique_ptr<int,std::default_delete<int>> const *)(& up1));
      goto return_label;
    }
    tmp_8 = move<std::unique_ptr<int[],std::default_delete<int[]>>&>(& up3);
    struct unique_ptr<int[],std::default_delete<int[]>> up4;
    unique_ptr<int[],std::default_delete<int[]>>::Ctor(& up4,tmp_8);
    tmp_9 = forward<std::unique_ptr<int[],std::default_delete<int[]>>>
    (& up4);
    struct unique_ptr<int[],std::default_delete<int[]>> up5;
    unique_ptr<int[],std::default_delete<int[]>>::Ctor(& up5,tmp_9);
    int *up5_raw = release(& up5);
    /*@ assert Eva: mem_access: \valid_read(up5_raw + 0); */
    int result = *(up5_raw + 0);
    free((void *)up5_raw);
    __retres = result;
    unique_ptr<int[],std::default_delete<int[]>>::Dtor((struct unique_ptr<int[],std::default_delete<int[]>> const *)(& up5));
    unique_ptr<int[],std::default_delete<int[]>>::Dtor((struct unique_ptr<int[],std::default_delete<int[]>> const *)(& up4));
    unique_ptr<int[],std::default_delete<int[]>>::Dtor((struct unique_ptr<int[],std::default_delete<int[]>> const *)(& up3));
    unique_ptr<int,std::default_delete<int>>::Dtor((struct unique_ptr<int,std::default_delete<int>> const *)(& up2));
    unique_ptr<int,std::default_delete<int>>::Dtor((struct unique_ptr<int,std::default_delete<int>> const *)(& up1));
  }
  return_label: return __retres;
}

void PlainOldStruct::Ctor(struct PlainOldStruct const *this);

void PlainOldStruct::Dtor(struct PlainOldStruct const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid(this); */
int pull(struct PlainOldStruct *this)
{
  int __retres;
  __retres = this->val;
  return __retres;
}

/*@ requires \valid(this); */
void push(struct PlainOldStruct *this, int x)
{
  this->val = x;
  return;
}

/*@ requires \valid_read(this); */
void PlainOldStruct::Ctor(struct PlainOldStruct const *this)
{
  return;
}

/*@ requires \valid_read(this); */
void PlainOldStruct::Dtor(struct PlainOldStruct const *this)
{
  return;
}

/*@ requires \valid_read(this); */
void operator()(struct default_delete<PlainOldStruct> const *this,
                struct PlainOldStruct * const o)
{
  PlainOldStruct::Dtor((struct PlainOldStruct const *)o);
  free((void *)o);
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "PlainOldStruct",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
int test_struct_payload(int var)
{
  int __retres;
  {
    struct PlainOldStruct *__fc_tmp_1;
    pointer tmp;
    int tmp_1;
    pointer tmp_0;
    pointer tmp_2;
    type *tmp_3;
    struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> *tmp_4;
    int tmp_6;
    pointer tmp_5;
    struct PlainOldStruct pos;
    PlainOldStruct::Ctor(& pos);
    struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> up1;
    unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
    (& up1,& pos);
    __fc_tmp_1 = (struct PlainOldStruct *)malloc(sizeof(struct PlainOldStruct));
    PlainOldStruct::Ctor((struct PlainOldStruct const *)__fc_tmp_1);
    struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> up2;
    unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
    (& up2,__fc_tmp_1);
    ;
    tmp = std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::operator->
    ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up1));
    push(tmp,var);
    tmp_0 = std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::operator->
    ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up1));
    tmp_1 = pull(tmp_0);
    tmp_2 = std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::operator->
    ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up2));
    push(tmp_2,tmp_1 + 1);
    swap<PlainOldStruct,std::default_delete<PlainOldStruct>>(& up1,& up2);
    reset(& up1,(struct PlainOldStruct *)0);
    tmp_3 = move<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>&>
    (& up2);
    struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> up3;
    unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
    (& up3,tmp_3);
    tmp_4 = forward<std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>>
    (& up3);
    struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> up4;
    unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Ctor
    (& up4,tmp_4);
    tmp_5 = std::unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::operator->
    ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up4));
    tmp_6 = pull(tmp_5);
    int result = tmp_6;
    struct PlainOldStruct *up4_raw = release(& up4);
    if (up4_raw != & pos) {
      PlainOldStruct::Dtor((struct PlainOldStruct const *)up4_raw);
      free((void *)up4_raw);
      __retres = 0;
      unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
      ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up4));
      unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
      ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up3));
      unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
      ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up2));
      unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
      ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up1));
      PlainOldStruct::Dtor((struct PlainOldStruct const *)(& pos));
      goto return_label;
    }
    __retres = result;
    unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
    ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up4));
    unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
    ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up3));
    unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
    ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up2));
    unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>>::Dtor
    ((struct unique_ptr<PlainOldStruct,std::default_delete<PlainOldStruct>> const *)(& up1));
    PlainOldStruct::Dtor((struct PlainOldStruct const *)(& pos));
  }
  return_label: return __retres;
}

void ClassTemplate<int,0>::Ctor(struct ClassTemplate<int,0> const *this);

void ClassTemplate<int,0>::Dtor(struct ClassTemplate<int,0> const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid(this); */
int *pull(struct ClassTemplate<int,0> *this)
{
  int *__retres;
  __retres = & this->val;
  return __retres;
}

/*@ requires \valid(this); */
void push(struct ClassTemplate<int,0> *this, int *x)
{
  this->val = *x;
  return;
}

/*@ requires \valid_read(this); */
void ClassTemplate<int,0>::Ctor(struct ClassTemplate<int,0> const *this)
{
  return;
}

/*@ requires \valid_read(this); */
void ClassTemplate<int,0>::Dtor(struct ClassTemplate<int,0> const *this)
{
  return;
}

/*@ requires \valid_read(this); */
void operator()(struct default_delete<ClassTemplate<int,0>> const *this,
                struct ClassTemplate<int,0> * const o)
{
  ClassTemplate<int,0>::Dtor((struct ClassTemplate<int,0> const *)o);
  free((void *)o);
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "ClassTemplate",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
int test_template_payload(int var)
{
  int __retres;
  {
    struct ClassTemplate<int,0> *__fc_tmp_2;
    pointer tmp;
    type *tmp_0;
    struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> *tmp_1;
    int *tmp_3;
    pointer tmp_2;
    struct ClassTemplate<int,0> ct;
    ClassTemplate<int,0>::Ctor(& ct);
    struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> up1;
    unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
    (& up1,& ct);
    __fc_tmp_2 = (struct ClassTemplate<int,0> *)malloc(sizeof(struct ClassTemplate<int,0>));
    ClassTemplate<int,0>::Ctor((struct ClassTemplate<int,0> const *)__fc_tmp_2);
    struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> up2;
    unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
    (& up2,__fc_tmp_2);
    tmp = std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::operator->
    ((struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *)(& up1));
    push(tmp,& var);
    swap<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>
    (& up1,& up2);
    reset(& up1,(struct ClassTemplate<int,0> *)0);
    tmp_0 = move<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>&>
    (& up2);
    struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> up3;
    unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
    (& up3,tmp_0);
    tmp_1 = forward<std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>>
    (& up3);
    struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> up4;
    unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Ctor
    (& up4,tmp_1);
    tmp_2 = std::unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::operator->
    ((struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *)(& up4));
    tmp_3 = pull(tmp_2);
    int result = *tmp_3;
    struct ClassTemplate<int,0> *up4_raw = release(& up4);
    if (up4_raw != & ct) {
      ClassTemplate<int,0>::Dtor((struct ClassTemplate<int,0> const *)up4_raw);
      free((void *)up4_raw);
      __retres = 0;
      unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
      ((struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *)(& up4));
      unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
      ((struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *)(& up3));
      unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
      ((struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *)(& up2));
      unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
      ((struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *)(& up1));
      ClassTemplate<int,0>::Dtor((struct ClassTemplate<int,0> const *)(& ct));
      goto return_label;
    }
    __retres = result;
    unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
    ((struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *)(& up4));
    unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
    ((struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *)(& up3));
    unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
    ((struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *)(& up2));
    unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>>::Dtor
    ((struct unique_ptr<ClassTemplate<int,0>,std::default_delete<ClassTemplate<int,0>>> const *)(& up1));
    ClassTemplate<int,0>::Dtor((struct ClassTemplate<int,0> const *)(& ct));
  }
  return_label: return __retres;
}

int main(int argc, char **argv)
{
  int t1 = test_primitive_payload(argc);
  int t2 = test_struct_payload(t1);
  int t3 = test_template_payload(t2);
  return t3;
}


