Parsing
Cleaning unused parts
Symbolic link
Starting semantical analysis
[values] computing for function main
====== INITIAL STATE ======
Computing globals values
====== INITIAL STATE COMPUTED ======
Values of globals at initialization 

[values] computing for function A::Ctor <-main
[values] Recording results for A::Ctor
[values] done for function A::Ctor
[values] computing for function f <-main
[values] Recording results for f
[values] done for function f
[values] Recording results for main
[values] done for function main

====== VALUES AND OUTS COMPUTED ======
Values for function _ZN1AC1E:
  a.x -> {0; }
   .y -> {1; }
  
Values for function _Z1fR1A:
  a.x -> {42; }
   .y -> {0; }
  
Values for function main:
  a.x -> {42; }
   .y -> {0; }
  __res -> {0; }
  

[pdg] in progress...

[slicing] in progress...
/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is false */

struct _Z1A;
struct A {
   int _ZN1A1xE ;
   int _ZN1A1yE ;
};
__inline void A::Ctor(struct A *this ) ;
__inline void A::Ctor(struct A *this , struct A *__other ) ;
__inline struct A *operator=(struct A *this , struct A *__other ) ;
__inline void A::Dtor(struct A *this ) ;
/*@ requires \valid(this)
*/
__inline void A::Ctor(struct A *this ) 
{ 
  
  {{this->x = 0;
   this->y = 1;}
  
  
  return;}

}
/*@ requires \valid(a)
*/
void f(struct A *a ) 
{ 
  
  {a->x = 42;
  {
  while (a->y) {(a->y) --;}
  
  }
  
  /*@ assert (a->x != 0)
  */
  
  
  return;}

}
/*@ requires \valid(a)
*/
void f(struct A *a ) 
{ 
  
  {a->x = 42;
  
  {
  
  }
  
  
  
  
  }
  

}
void main_slice_1(void) 
{ struct A a ;
  
  {A::Ctor(& a);
  a.y = 4;
  f(& a);
  
  
  }
  

}


====== SLICED CODE COMPUTED ======
