Now output intermediate result
tests/template/template.cc:37:[kernel] warning: Calling undeclared function free. Old style K&R code?
tests/template/template.cc:44:[kernel] warning: Calling undeclared function malloc. Old style K&R code?
/* Generated by Frama-C */
struct Noeud<_Bool>;
struct Liste<_Bool> {
   struct Noeud<_Bool> *top ;
};
struct Noeud<int>;
struct Liste<int> {
   struct Noeud<int> *top ;
};
struct Noeud<_Bool> {
   _Bool *val ;
   struct Liste<_Bool> *next ;
};
struct Noeud<int> {
   int *val ;
   struct Liste<int> *next ;
};
/*@ requires \valid(this); */
void Liste<_Bool>::Ctor(struct Liste<_Bool> *this, struct Noeud<_Bool> *_top)
{
  this->top = _top;
  return;
}

/*@ requires \separated(this, l);
    requires \valid(this);
    requires \valid(l); */
void Liste<_Bool>::Ctor(struct Liste<_Bool> *this,
                        struct Liste<_Bool> const *l)
{
  this->top = l->top;
  return;
}

/*@ requires \valid(this); */
extern _Bool isEmpty(struct Liste<_Bool> *this);

/*@ requires \valid(this); */
extern void cdr(struct Liste<_Bool> *this);

/*@ requires \valid(this); */
extern _Bool *head(struct Liste<_Bool> *this);

extern int ( /* missing proto */ free)(struct Noeud<_Bool> *x_0);

/*@ requires \valid(this); */
void Liste<_Bool>::Dtor(struct Liste<_Bool> *this)
{
  if ((_Bool)(this->top != 0)) free(this->top);
  return;
}

/*@ requires \valid(this); */
void Liste<int>::Ctor(struct Liste<int> *this, struct Noeud<int> *_top)
{
  this->top = _top;
  return;
}

/*@ requires \separated(this, l);
    requires \valid(this);
    requires \valid(l); */
void Liste<int>::Ctor(struct Liste<int> *this, struct Liste<int> const *l)
{
  this->top = l->top;
  return;
}

/*@ requires \valid(this); */
extern _Bool isEmpty(struct Liste<int> *this);

/*@ requires \valid(this); */
extern void cdr(struct Liste<int> *this);

/*@ requires \valid(this); */
extern int *head(struct Liste<int> *this);

/*@ requires \valid(this); */
void Liste<int>::Dtor(struct Liste<int> *this)
{
  if ((_Bool)(this->top != 0)) free((struct Noeud<_Bool> *)this->top);
  return;
}

void Noeud<_Bool>::Ctor(struct Noeud<_Bool> *this,
                        struct Noeud<_Bool> const *x);

/*@ requires \valid(this); */
void Noeud<_Bool>::Ctor(struct Noeud<_Bool> *this, _Bool *_data,
                        struct Liste<_Bool> *_next)
{
  this->val = _data;
  if ((_Bool)(_data != 0)) this->next = _next;
  else this->next = (struct Liste<_Bool> *)((void *)0);
  return;
}

/*@ requires \valid(this); */
extern _Bool *head(struct Noeud<_Bool> *this);

/*@ requires \valid(this); */
extern struct Liste<_Bool> *tail(struct Noeud<_Bool> *this);

/*@ requires \valid(this); */
void Noeud<_Bool>::Dtor(struct Noeud<_Bool> *this)
{
  if ((_Bool)(this->next != 0)) free((struct Noeud<_Bool> *)this->next);
  return;
}

/*@ requires \separated(this, x);
    requires \valid(this);
    requires \valid(x); */
void Noeud<_Bool>::Ctor(struct Noeud<_Bool> *this,
                        struct Noeud<_Bool> const *x)
{
  this->val = x->val;
  this->next = x->next;
  return;
}

extern int ( /* missing proto */ malloc)(int x_0);

/*@ requires \valid(this); */
void cons(struct Liste<_Bool> *this, _Bool *data)
{
  struct Liste<_Bool> *l;
  int tmp;
  struct Noeud<_Bool> *hd;
  int tmp_0;
  if (! ((_Bool)(data != 0))) goto return_label;
  {
    /*sequence*/
    ;
    tmp = malloc((int)sizeof(struct Liste<_Bool>));
  }
  Liste<_Bool>::Ctor((struct Liste<_Bool> *)tmp,
                     (struct Liste<_Bool> const *)this);
  {
    /*sequence*/
    ;
    ;
    tmp_0 = malloc((int)sizeof(struct Noeud<_Bool>));
  }
  Noeud<_Bool>::Ctor((struct Noeud<_Bool> *)tmp_0,data,l);
  this->top = hd;
  return_label: return;
}

void Noeud<int>::Ctor(struct Noeud<int> *this, struct Noeud<int> const *x);

/*@ requires \valid(this); */
void Noeud<int>::Ctor(struct Noeud<int> *this, int *_data,
                      struct Liste<int> *_next)
{
  this->val = _data;
  if ((_Bool)(_data != 0)) this->next = _next;
  else this->next = (struct Liste<int> *)((void *)0);
  return;
}

/*@ requires \valid(this); */
extern int *head(struct Noeud<int> *this);

/*@ requires \valid(this); */
extern struct Liste<int> *tail(struct Noeud<int> *this);

/*@ requires \valid(this); */
void Noeud<int>::Dtor(struct Noeud<int> *this)
{
  if ((_Bool)(this->next != 0)) free((struct Noeud<_Bool> *)this->next);
  return;
}

/*@ requires \separated(this, x);
    requires \valid(this);
    requires \valid(x); */
void Noeud<int>::Ctor(struct Noeud<int> *this, struct Noeud<int> const *x)
{
  this->val = x->val;
  this->next = x->next;
  return;
}

/*@ requires \valid(this); */
void cons(struct Liste<int> *this, int *data)
{
  struct Liste<int> *l;
  int tmp;
  struct Noeud<int> *hd;
  int tmp_0;
  if (! ((_Bool)(data != 0))) goto return_label;
  {
    /*sequence*/
    ;
    tmp = malloc((int)sizeof(struct Liste<int>));
  }
  Liste<int>::Ctor((struct Liste<int> *)tmp,(struct Liste<int> const *)this);
  {
    /*sequence*/
    ;
    ;
    tmp_0 = malloc((int)sizeof(struct Noeud<int>));
  }
  Noeud<int>::Ctor((struct Noeud<int> *)tmp_0,data,l);
  this->top = hd;
  return_label: return;
}

int main(void)
{
  int __retres;
  struct Liste<_Bool> lb;
  struct Liste<int> li;
  int x;
  _Bool b;
  Liste<_Bool>::Ctor(& lb,(struct Noeud<_Bool> *)((void *)0));
  Liste<int>::Ctor(& li,(struct Noeud<int> *)((void *)0));
  x = 3;
  b = (_Bool)0;
  cons(& lb,& b);
  cons(& li,& x);
  __retres = 0;
  return __retres;
}


