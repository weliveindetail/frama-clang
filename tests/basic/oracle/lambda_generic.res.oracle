[kernel] Parsing tests/basic/lambda_generic.cpp (external front-end)
Now output intermediate result
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  
[eva:alarm] tests/basic/lambda_generic.cpp:6: Warning: 
  signed overflow. assert -2147483648 ≤ __fc_closure->cap - val;
[eva:alarm] tests/basic/lambda_generic.cpp:6: Warning: 
  signed overflow. assert __fc_closure->cap - val ≤ 2147483647;
[eva:alarm] tests/basic/lambda_generic.cpp:11: Warning: 
  signed overflow. assert -2147483648 ≤ __fc_closure->cap - val;
[eva:alarm] tests/basic/lambda_generic.cpp:11: Warning: 
  signed overflow. assert __fc_closure->cap - val ≤ 2147483647;
[eva:alarm] tests/basic/lambda_generic.cpp:16: Warning: 
  signed overflow. assert -2147483648 ≤ __fc_closure->cap - val;
[eva:alarm] tests/basic/lambda_generic.cpp:16: Warning: 
  signed overflow. assert __fc_closure->cap - val ≤ 2147483647;
[eva:alarm] tests/basic/lambda_generic.cpp:20: Warning: 
  signed overflow.
  assert tmp_0 + addend ≤ 2147483647;
  (tmp_0 from
  *(lam3.__fc_lambda_overload_3)((struct __fc_lam2 const *)(& lam3), i))
[eva:alarm] tests/basic/lambda_generic.cpp:28: Warning: 
  signed overflow. assert -2147483648 ≤ res1 + res2;
[eva:alarm] tests/basic/lambda_generic.cpp:28: Warning: 
  signed overflow. assert res1 + res2 ≤ 2147483647;
[eva:alarm] tests/basic/lambda_generic.cpp:28: Warning: 
  signed overflow. assert -2147483648 ≤ (int)(res1 + res2) + res3;
[eva:alarm] tests/basic/lambda_generic.cpp:28: Warning: 
  signed overflow. assert (int)(res1 + res2) + res3 ≤ 2147483647;
[eva] done for function main
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  15 functions analyzed (out of 15): 100% coverage.
  In these functions, 50 statements reached (out of 50): 100% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  11 alarms generated by the analysis:
      11 integer overflows
  ----------------------------------------------------------------------------
  No logical properties have been reached by the analysis.
  ----------------------------------------------------------------------------
[from] Computing for function __fc_lam0_body_0
[from] Done for function __fc_lam0_body_0
[from] Computing for function __fc_lam0_init_0
[from] Done for function __fc_lam0_init_0
[from] Computing for function __fc_lam0_init_captures
[from] Done for function __fc_lam0_init_captures
[from] Computing for function test_cxx11_lambda
[from] Done for function test_cxx11_lambda
[from] Computing for function __fc_lam1_body_1
[from] Done for function __fc_lam1_body_1
[from] Computing for function __fc_lam1_init_1
[from] Done for function __fc_lam1_init_1
[from] Computing for function __fc_lam1_init_captures
[from] Done for function __fc_lam1_init_captures
[from] Computing for function test_cxx14_single_inst
[from] Done for function test_cxx14_single_inst
[from] Computing for function __fc_lam2_body_2
[from] Done for function __fc_lam2_body_2
[from] Computing for function __fc_lam2_body_3
[from] Done for function __fc_lam2_body_3
[from] Computing for function __fc_lam2_init_2
[from] Done for function __fc_lam2_init_2
[from] Computing for function __fc_lam2_init_3
[from] Done for function __fc_lam2_init_3
[from] Computing for function __fc_lam2_init_captures
[from] Done for function __fc_lam2_init_captures
[from] Computing for function test_cxx14_multi_inst
[from] Done for function test_cxx14_multi_inst
[from] Computing for function main
[from] Done for function main
[from] ====== DEPENDENCIES COMPUTED ======
  These dependencies hold at termination for the executions that terminate:
[from] Function __fc_lam0_body_0:
  \result FROM __fc_closure; val; lam1.cap
[from] Function __fc_lam0_init_0:
  __fc_lambda_tmp.__fc_lambda_overload_0 FROM __fc_closure; __fc_func
[from] Function __fc_lam0_init_captures:
  __fc_lambda_tmp.cap FROM __fc_closure; cap
[from] Function test_cxx11_lambda:
  \result FROM cap; i
[from] Function __fc_lam1_body_1:
  \result FROM __fc_closure; val; lam2.cap
[from] Function __fc_lam1_init_1:
  __fc_lambda_tmp_0.__fc_lambda_overload_1 FROM __fc_closure; __fc_func
[from] Function __fc_lam1_init_captures:
  __fc_lambda_tmp_0.cap FROM __fc_closure; cap
[from] Function test_cxx14_single_inst:
  \result FROM cap; i
[from] Function __fc_lam2_body_2:
  \result FROM __fc_closure; val; lam3.cap
[from] Function __fc_lam2_body_3:
  \result FROM __fc_closure; val; lam3.cap
[from] Function __fc_lam2_init_2:
  __fc_lambda_tmp_1.__fc_lambda_overload_2 FROM __fc_closure; __fc_func
[from] Function __fc_lam2_init_3:
  __fc_lambda_tmp_1.__fc_lambda_overload_3 FROM __fc_closure; __fc_func
[from] Function __fc_lam2_init_captures:
  __fc_lambda_tmp_1.cap FROM __fc_closure; cap
[from] Function test_cxx14_multi_inst:
  \result FROM cap; i; f
[from] Function main:
  \result FROM argc
[from] ====== END OF DEPENDENCIES ======
/* Generated by Frama-C */
struct __fc_lam0 {
   int (*__fc_lambda_overload_0)(struct __fc_lam0 const *, int ) ;
   int cap ;
};
struct __fc_lam1 {
   int (*__fc_lambda_overload_1)(struct __fc_lam1 const *, int ) ;
   int cap ;
};
struct __fc_lam2 {
   int (*__fc_lambda_overload_3)(struct __fc_lam2 const *, int ) ;
   float (*__fc_lambda_overload_2)(struct __fc_lam2 const *, float ) ;
   int cap ;
};
void __fc_lam0_init_captures(struct __fc_lam0 const *__fc_closure, int cap)
{
  __fc_closure->cap = cap;
  return;
}

void __fc_lam0_init_0(struct __fc_lam0 const *__fc_closure,
                      int (*__fc_func)(struct __fc_lam0 const *, int ))
{
  __fc_closure->__fc_lambda_overload_0 = __fc_func;
  return;
}

int __fc_lam0_body_0(struct __fc_lam0 const *__fc_closure, int val)
{
  int __retres;
  /*@ assert Eva: signed_overflow: -2147483648 ≤ __fc_closure->cap - val;
  */
  /*@ assert Eva: signed_overflow: __fc_closure->cap - val ≤ 2147483647; */
  __retres = __fc_closure->cap - val;
  return __retres;
}

int test_cxx11_lambda(int cap, int i)
{
  struct __fc_lam0 lam1;
  struct __fc_lam0 const __fc_lambda_tmp;
  int tmp;
  __fc_lam0_init_captures(& __fc_lambda_tmp,cap);
  __fc_lam0_init_0(& __fc_lambda_tmp,& __fc_lam0_body_0);
  lam1 = __fc_lambda_tmp;
  tmp = (*(lam1.__fc_lambda_overload_0))((struct __fc_lam0 const *)(& lam1),
                                         i);
  return tmp;
}

void __fc_lam1_init_captures(struct __fc_lam1 const *__fc_closure, int cap)
{
  __fc_closure->cap = cap;
  return;
}

void __fc_lam1_init_1(struct __fc_lam1 const *__fc_closure,
                      int (*__fc_func)(struct __fc_lam1 const *, int ))
{
  __fc_closure->__fc_lambda_overload_1 = __fc_func;
  return;
}

int __fc_lam1_body_1(struct __fc_lam1 const *__fc_closure, int val)
{
  int __retres;
  /*@ assert Eva: signed_overflow: -2147483648 ≤ __fc_closure->cap - val;
  */
  /*@ assert Eva: signed_overflow: __fc_closure->cap - val ≤ 2147483647; */
  __retres = __fc_closure->cap - val;
  return __retres;
}

int test_cxx14_single_inst(int cap, int i)
{
  struct __fc_lam1 lam2;
  struct __fc_lam1 const __fc_lambda_tmp_0;
  int tmp;
  __fc_lam1_init_captures(& __fc_lambda_tmp_0,cap);
  __fc_lam1_init_1(& __fc_lambda_tmp_0,& __fc_lam1_body_1);
  lam2 = __fc_lambda_tmp_0;
  tmp = (*(lam2.__fc_lambda_overload_1))((struct __fc_lam1 const *)(& lam2),
                                         i);
  return tmp;
}

void __fc_lam2_init_captures(struct __fc_lam2 const *__fc_closure, int cap)
{
  __fc_closure->cap = cap;
  return;
}

void __fc_lam2_init_3(struct __fc_lam2 const *__fc_closure,
                      int (*__fc_func)(struct __fc_lam2 const *, int ))
{
  __fc_closure->__fc_lambda_overload_3 = __fc_func;
  return;
}

int __fc_lam2_body_3(struct __fc_lam2 const *__fc_closure, int val)
{
  int __retres;
  /*@ assert Eva: signed_overflow: -2147483648 ≤ __fc_closure->cap - val;
  */
  /*@ assert Eva: signed_overflow: __fc_closure->cap - val ≤ 2147483647; */
  __retres = __fc_closure->cap - val;
  return __retres;
}

void __fc_lam2_init_2(struct __fc_lam2 const *__fc_closure,
                      float (*__fc_func)(struct __fc_lam2 const *, float ))
{
  __fc_closure->__fc_lambda_overload_2 = __fc_func;
  return;
}

float __fc_lam2_body_2(struct __fc_lam2 const *__fc_closure, float val)
{
  float __retres;
  __retres = (float)__fc_closure->cap - val;
  return __retres;
}

int test_cxx14_multi_inst(int cap, int i, float f)
{
  int __retres;
  struct __fc_lam2 lam3;
  struct __fc_lam2 const __fc_lambda_tmp_1;
  float tmp;
  int tmp_0;
  __fc_lam2_init_captures(& __fc_lambda_tmp_1,cap);
  __fc_lam2_init_3(& __fc_lambda_tmp_1,& __fc_lam2_body_3);
  __fc_lam2_init_2(& __fc_lambda_tmp_1,& __fc_lam2_body_2);
  lam3 = __fc_lambda_tmp_1;
  int addend = 1;
  tmp = (*(lam3.__fc_lambda_overload_2))((struct __fc_lam2 const *)(& lam3),
                                         f);
  if ((double)tmp < 0.5) addend = 0;
  tmp_0 = (*(lam3.__fc_lambda_overload_3))((struct __fc_lam2 const *)(& lam3),
                                           i);
  ;
  /*@ assert Eva: signed_overflow: tmp_0 + addend ≤ 2147483647; */
  __retres = tmp_0 + addend;
  return __retres;
}

int main(int argc, char **argv)
{
  int __retres;
  int res1 = test_cxx11_lambda(argc,argc);
  int res2 = test_cxx14_single_inst(argc,argc);
  int res3 = test_cxx14_multi_inst(argc,argc,(float)argc);
  /*@ assert Eva: signed_overflow: -2147483648 ≤ res1 + res2; */
  /*@ assert Eva: signed_overflow: res1 + res2 ≤ 2147483647; */
  /*@ assert Eva: signed_overflow: -2147483648 ≤ (int)(res1 + res2) + res3;
  */
  /*@ assert Eva: signed_overflow: (int)(res1 + res2) + res3 ≤ 2147483647;
  */
  __retres = (res1 + res2) + res3;
  return __retres;
}


