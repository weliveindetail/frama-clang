[kernel] Parsing tests/basic/delete_all_kind.cpp (external front-end)
Now output intermediate result
[kernel] Warning: Assuming declared function malloc can't throw any exception
[kernel] Warning: Assuming declared function malloc can't throw any exception
[kernel] Warning: Assuming declared function malloc can't throw any exception
[kernel] Warning: Assuming declared function malloc can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
[kernel] Warning: Assuming declared function free can't throw any exception
/* Generated by Frama-C */
struct _frama_c_vmt_content {
   void (*method_ptr)() ;
   int shift_this ;
};
struct _frama_c_rtti_name_info_node;
struct _frama_c_vmt {
   struct _frama_c_vmt_content *table ;
   int table_size ;
   struct _frama_c_rtti_name_info_node *rtti_info ;
};
struct _frama_c_rtti_name_info_content {
   struct _frama_c_rtti_name_info_node *value ;
   int shift_object ;
   int shift_vmt ;
};
struct _frama_c_rtti_name_info_node {
   char const *name ;
   struct _frama_c_rtti_name_info_content *base_classes ;
   int number_of_base_classes ;
   struct _frama_c_vmt *pvmt ;
};
typedef unsigned int size_t;
struct A;
struct A {
   int _ ;
};
struct B;
struct B {
   int _ ;
};
void *malloc(unsigned int size);

void free(void *ptr);

void A::Ctor(struct A const *this);

void A::Dtor(struct A const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

void A::delete(void *ptr)
{
  return;
}

void A::delete[](void *ptr)
{
  return;
}

void *A::new(size_t n)
{
  void *__retres;
  __retres = (void *)((struct A *)1);
  return __retres;
}

void *A::new[](size_t n)
{
  void *__retres;
  __retres = (void *)((struct A *)2);
  return __retres;
}

/*@ requires \valid_read(this); */
void A::Ctor(struct A const *this)
{
  return;
}

/*@ requires \valid_read(this); */
void A::Dtor(struct A const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "A",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void B::Ctor(struct B const *this);

void B::Dtor(struct B const *this);

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

/*@ requires \valid_read(this); */
void B::Ctor(struct B const *this)
{
  return;
}

/*@ requires \valid_read(this); */
void B::Dtor(struct B const *this)
{
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "B",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
int main(void)
{
  int __retres;
  struct A *p1;
  struct A *__fc_tmp_0;
  struct A *tmp;
  struct B *p3;
  struct B *__fc_tmp_3;
  struct B *tmp_0;
  __fc_tmp_0 = (struct A *)A::new(sizeof(struct A));
  A::Ctor((struct A const *)__fc_tmp_0);
  p1 = __fc_tmp_0;
  {
    struct A *__fc_tmp_1;
    __fc_tmp_1 = (struct A *)A::new[]((unsigned int)10 * sizeof(struct A));
    {
      unsigned long long __fc_tmp_2 = 0ULL;
      while (__fc_tmp_2 < (unsigned long long)10) {
        A::Ctor((struct A const *)(__fc_tmp_1 + __fc_tmp_2));
        __fc_tmp_2 ++;
      }
    }
    tmp = __fc_tmp_1;
  }
  struct A *p2 = tmp;
  __fc_tmp_3 = (struct B *)malloc(sizeof(struct B));
  B::Ctor((struct B const *)__fc_tmp_3);
  p3 = __fc_tmp_3;
  {
    struct B *__fc_tmp_4;
    __fc_tmp_4 = (struct B *)malloc(sizeof(struct B) * (unsigned int)10);
    {
      unsigned long long __fc_tmp_5 = 0ULL;
      while (__fc_tmp_5 < (unsigned long long)10) {
        B::Ctor((struct B const *)(__fc_tmp_4 + __fc_tmp_5));
        __fc_tmp_5 ++;
      }
    }
    tmp_0 = __fc_tmp_4;
  }
  struct B *p4 = tmp_0;
  int *p5 = malloc(sizeof(int));
  int *p6 = malloc(sizeof(int) * (unsigned int)10);
  A::Dtor((struct A const *)p1);
  A::delete((void *)p1);
  {
    unsigned long long __fc_tmp_6 = 0ULL;
    while (__fc_tmp_6 < 1ULL) {
      A::Dtor((struct A const *)(p2 + ((1ULL - 1ULL) - __fc_tmp_6)));
      __fc_tmp_6 ++;
    }
  }
  A::delete[]((void *)p2);
  B::Dtor((struct B const *)p3);
  free((void *)p3);
  {
    unsigned long long __fc_tmp_7 = 0ULL;
    while (__fc_tmp_7 < 1ULL) {
      B::Dtor((struct B const *)(p4 + ((1ULL - 1ULL) - __fc_tmp_7)));
      __fc_tmp_7 ++;
    }
  }
  free((void *)p4);
  free((void *)p5);
  free((void *)p6);
  __retres = 0;
  return __retres;
}


