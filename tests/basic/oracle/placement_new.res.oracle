[kernel] Parsing tests/basic/placement_new.cpp (external front-end)
Now output intermediate result
[kernel] Warning: Assuming declared function malloc can't throw any exception
/* Generated by Frama-C */
typedef unsigned int size_t;
struct _frama_c_vmt_content {
   void (*method_ptr)() ;
   int shift_this ;
};
struct _frama_c_rtti_name_info_node;
struct _frama_c_vmt {
   struct _frama_c_vmt_content *table ;
   int table_size ;
   struct _frama_c_rtti_name_info_node *rtti_info ;
};
struct _frama_c_rtti_name_info_content {
   struct _frama_c_rtti_name_info_node *value ;
   int shift_object ;
   int shift_vmt ;
};
struct _frama_c_rtti_name_info_node {
   char const *name ;
   struct _frama_c_rtti_name_info_content *base_classes ;
   int number_of_base_classes ;
   struct _frama_c_vmt *pvmt ;
};
struct __fc_div_t {
   int quot ;
   int rem ;
};
typedef struct __fc_div_t div_t;
struct __fc_ldiv_t {
   long quot ;
   long rem ;
};
typedef struct __fc_ldiv_t ldiv_t;
struct __fc_lldiv_t {
   long long quot ;
   long long rem ;
};
typedef struct __fc_lldiv_t lldiv_t;
typedef size_t size_t;
struct T;
struct T {
   int x ;
};
struct U;
struct U {
   int foo ;
};
void *malloc(size_t size);

void free(void *p);

/*@ ghost int __fc_heap_status; */
/*@ requires freeable: p ≡ \null ∨ \freeable(p);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status;
    frees p;
    
    behavior deallocation:
      assumes nonnull_p: p ≢ \null;
      ensures freed: \allocable(\old(p));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status;
    
    behavior no_deallocation:
      assumes null_p: p ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_deallocation, deallocation;
    disjoint behaviors no_deallocation, deallocation;
 */
void free(void *p);

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(ℤ n) 
    reads __fc_heap_status;
  
  axiom never_allocable{L}:
    ∀ ℤ i; i < 0 ∨ i > 4294967295U ⇒ ¬is_allocable(i);
  
  }
 */
/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(size);
      ensures allocation: \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void *malloc(size_t size);

/*@
axiomatic MemCmp {
  logic ℤ memcmp{L1, L2}(char *s1, char *s2, ℤ n) 
    reads \at(*(s1 + (0 .. n - 1)),L1), \at(*(s2 + (0 .. n - 1)),L2);
  
  axiom memcmp_zero{L1, L2}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L1, L2}(s1, s2, n) ≡ 0 ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ \at(*(s1 + i),L1) ≡ \at(*(s2 + i),L2));
  
  }
 */
/*@
axiomatic MemChr {
  logic 𝔹 memchr{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  logic ℤ memchr_off{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memchr(s, c, n) ≢ (0 ≢ 0) ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic MemSet {
  logic 𝔹 memset{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memset_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memset(s, c, n) ≢ (0 ≢ 0) ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic StrLen {
  logic ℤ strlen{L}(char *s) 
    reads *(s + (0 ..));
  
  axiom strlen_pos_or_null{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ (char)0) ∧
      *(s + i) ≡ (char)0 ⇒ strlen(s) ≡ i;
  
  axiom strlen_neg{L}:
    ∀ char *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ (char)0) ⇒ strlen(s) < 0;
  
  axiom strlen_before_null{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i < strlen(s) ⇒ *(s + i) ≢ (char)0;
  
  axiom strlen_at_null{L}:
    ∀ char *s; 0 ≤ strlen(s) ⇒ *(s + strlen(s)) ≡ (char)0;
  
  axiom strlen_not_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≢ (char)0 ⇒ i < strlen(s);
  
  axiom strlen_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ (char)0 ⇒ i ≡ strlen(s);
  
  axiom strlen_sup{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ (char)0 ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_shift{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ≤ strlen(s) ⇒ strlen(s + i) ≡ strlen(s) - i;
  
  axiom strlen_create{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ (char)0 ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_create_shift{L}:
    ∀ char *s;
    ∀ ℤ i;
    ∀ ℤ k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ (char)0 ⇒
      0 ≤ strlen(s + k) ≤ i - k;
  
  axiom memcmp_strlen_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s1) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s2) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_shift_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1, s2 + k, n) ≡ 0 ≤ k ∧ strlen(s1) < n ⇒
      0 ≤ strlen(s2) ≤ k + strlen(s1);
  
  axiom memcmp_strlen_shift_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1 + k, s2, n) ≡ 0 ≤ k ∧ strlen(s2) < n ⇒
      0 ≤ strlen(s1) ≤ k + strlen(s2);
  
  }
 */
/*@
axiomatic StrCmp {
  logic ℤ strcmp{L}(char *s1, char *s2) 
    reads *(s1 + (0 .. strlen(s1))), *(s2 + (0 .. strlen(s2)));
  
  axiom strcmp_zero{L}:
    ∀ char *s1, char *s2;
      strcmp(s1, s2) ≡ 0 ⇔
      strlen(s1) ≡ strlen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ strlen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrNCmp {
  logic ℤ strncmp{L}(char *s1, char *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom strncmp_zero{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      strncmp(s1, s2, n) ≡ 0 ⇔
      (strlen(s1) < n ∧ strcmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrChr {
  logic 𝔹 strchr{L}(char *s, ℤ c) 
    reads *(s + (0 .. strlen(s)));
  
  axiom strchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
      strchr(s, c) ≢ (0 ≢ 0) ⇔
      (∃ ℤ i; 0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ (char)((int)c));
  
  }
 */
/*@
axiomatic WMemChr {
  logic 𝔹 wmemchr{L}(int *s, int c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  logic ℤ wmemchr_off{L}(int *s, int c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom wmemchr_def{L}:
    ∀ int *s;
    ∀ int c;
    ∀ ℤ n;
      wmemchr(s, c, n) ≢ (0 ≢ 0) ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic WcsLen {
  logic ℤ wcslen{L}(int *s) 
    reads *(s + (0 ..));
  
  axiom wcslen_pos_or_null{L}:
    ∀ int *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ (int)0) ∧
      *(s + i) ≡ (int)0 ⇒ wcslen(s) ≡ i;
  
  axiom wcslen_neg{L}:
    ∀ int *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ (int)0) ⇒ wcslen(s) < 0;
  
  axiom wcslen_before_null{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i < wcslen(s) ⇒ *(s + i) ≢ (int)0;
  
  axiom wcslen_at_null{L}:
    ∀ int *s; 0 ≤ wcslen(s) ⇒ *(s + wcslen(s)) ≡ (int)0;
  
  axiom wcslen_not_zero{L}:
    ∀ int *s;
    ∀ int i;
      0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≢ (int)0 ⇒ i < wcslen(s);
  
  axiom wcslen_zero{L}:
    ∀ int *s;
    ∀ int i;
      0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≡ (int)0 ⇒ i ≡ wcslen(s);
  
  axiom wcslen_sup{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ (int)0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_shift{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ⇒ wcslen(s + i) ≡ wcslen(s) - i;
  
  axiom wcslen_create{L}:
    ∀ int *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ (int)0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_create_shift{L}:
    ∀ int *s;
    ∀ int i;
    ∀ int k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ (int)0 ⇒ 0 ≤ wcslen(s + k) ≤ i - k;
  
  }
 */
/*@
axiomatic WcsCmp {
  logic ℤ wcscmp{L}(int *s1, int *s2) 
    reads *(s1 + (0 .. wcslen(s1))), *(s2 + (0 .. wcslen(s2)));
  
  axiom wcscmp_zero{L}:
    ∀ int *s1, int *s2;
      wcscmp(s1, s2) ≡ 0 ⇔
      wcslen(s1) ≡ wcslen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ wcslen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsNCmp {
  logic ℤ wcsncmp{L}(int *s1, int *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom wcsncmp_zero{L}:
    ∀ int *s1, int *s2;
    ∀ ℤ n;
      wcsncmp(s1, s2, n) ≡ 0 ⇔
      (wcslen(s1) < n ∧ wcscmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsChr {
  logic 𝔹 wcschr{L}(int *wcs, ℤ wc) 
    reads *(wcs + (0 .. wcslen(wcs)));
  
  axiom wcschr_def{L}:
    ∀ int *wcs;
    ∀ ℤ wc;
      wcschr(wcs, wc) ≢ (0 ≢ 0) ⇔
      (∃ ℤ i; 0 ≤ i ≤ wcslen(wcs) ∧ *(wcs + i) ≡ (int)((int)wc));
  
  }
 */
/*@ logic ℤ minimum(ℤ i, ℤ j) = i < j? i: j;
 */
/*@ logic ℤ maximum(ℤ i, ℤ j) = i < j? j: i;
 */
/*@
predicate valid_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid_read(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_nstring{L}(char *s, ℤ n) =
  (\valid_read(s + (0 .. n - 1)) ∧ \initialized(s + (0 .. n - 1))) ∨
  valid_read_string(s);
 */
/*@
predicate valid_string_or_null{L}(char *s) = s ≡ \null ∨ valid_string(s);
 */
/*@
predicate valid_wstring{L}(int *s) =
  0 ≤ wcslen(s) ∧ \valid(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_read_wstring{L}(int *s) =
  0 ≤ wcslen(s) ∧ \valid_read(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_read_nwstring{L}(int *s, ℤ n) =
  (\valid_read(s + (0 .. n - 1)) ∧ \initialized(s + (0 .. n - 1))) ∨
  valid_read_wstring(s);
 */
/*@
predicate valid_wstring_or_null{L}(int *s) =
  s ≡ \null ∨ valid_wstring(s);
 */
/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
double atof(char const *nptr);

/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
int atoi(char const *nptr);

/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
long atol(char const *nptr);

/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
long long atoll(char const *nptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
double strtod(char const * __restrict nptr, char ** __restrict endptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
float strtof(char const * __restrict nptr, char ** __restrict endptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
long double strtold(char const * __restrict nptr, char ** __restrict endptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
long strtol(char const * __restrict nptr, char ** __restrict endptr, int base);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
long long strtoll(char const * __restrict nptr, char ** __restrict endptr,
                  int base);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
unsigned long strtoul(char const * __restrict nptr,
                      char ** __restrict endptr, int base);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
unsigned long long strtoull(char const * __restrict nptr,
                            char ** __restrict endptr, int base);

/*@ ghost int __fc_random_counter; */
static unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ensures result_range: 0 ≤ \result ≤ __fc_rand_max;
    assigns \result, __fc_random_counter;
    assigns \result \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
int rand(void);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
void srand(unsigned int seed);

/*@ ensures result_range: 0 ≤ \result ≤ __fc_rand_max;
    assigns \result;
    assigns \result \from __fc_random_counter;
 */
long random(void);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
void srandom(unsigned int seed);

int __fc_random48_init;
unsigned short __fc_random48_counter[3];
unsigned short *__fc_p_random48_counter = __fc_random48_counter;
/*@ ensures random48_initialized: __fc_random48_init ≡ 1;
    assigns __fc_random48_counter[0 .. 2], __fc_random48_init;
    assigns __fc_random48_counter[0 .. 2] \from seed;
    assigns __fc_random48_init \from \nothing;
 */
void srand48(long seed);

/*@ requires
      initialized_seed16v: initialization: \initialized(seed16v + (0 .. 2));
    ensures random48_initialized: __fc_random48_init ≡ 1;
    ensures result_counter: \result ≡ __fc_p_random48_counter;
    assigns __fc_random48_counter[0 .. 2], __fc_random48_init, \result;
    assigns __fc_random48_counter[0 .. 2]
      \from (indirect: *(seed16v + (0 .. 2)));
    assigns __fc_random48_init \from \nothing;
    assigns \result \from __fc_p_random48_counter;
 */
unsigned short *seed48(unsigned short * /*[3]*/ seed16v);

/*@ ensures random48_initialized: __fc_random48_init ≡ 1;
    assigns __fc_random48_counter[0 .. 2], __fc_random48_init;
    assigns __fc_random48_counter[0 .. 2] \from *(param + (0 .. 5));
    assigns __fc_random48_init \from \nothing;
 */
void lcong48(unsigned short * /*[7]*/ param);

/*@ requires random48_initialized: __fc_random48_init ≡ 1;
    ensures result_range: \is_finite(\result) ∧ 0.0 ≤ \result < 1.0;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
double drand48(void);

/*@ requires
      initialized_xsubi: initialization: \initialized(xsubi + (0 .. 2));
    ensures result_range: \is_finite(\result) ∧ 0.0 ≤ \result < 1.0;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
double erand48(unsigned short * /*[3]*/ xsubi);

/*@ requires random48_initialized: __fc_random48_init ≡ 1;
    ensures result_range: 0 ≤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
long lrand48(void);

/*@ requires
      initialized_xsubi: initialization: \initialized(xsubi + (0 .. 2));
    ensures result_range: 0 ≤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
long nrand48(unsigned short * /*[3]*/ xsubi);

/*@ requires random48_initialized: __fc_random48_init ≡ 1;
    ensures result_range: -2147483648 ≤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
long mrand48(void);

/*@ requires
      initialized_xsubi: initialization: \initialized(xsubi + (0 .. 2));
    ensures result_range: -2147483648 ≤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
long jrand48(unsigned short * /*[3]*/ xsubi);

/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status
      \from (indirect: nmemb), (indirect: size), __fc_heap_status;
    assigns \result
      \from (indirect: nmemb), (indirect: size), (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(nmemb * size);
      ensures
        allocation: \fresh{Old, Here}(\result,\old(nmemb) * \old(size));
      ensures
        initialization:
          \initialized((char *)\result + (0 .. \old(nmemb) * \old(size) - 1));
      ensures
        zero_initialization:
          \subset(*((char *)\result + (0 .. \old(nmemb) * \old(size) - 1)),
                 {0});
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(nmemb * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void *calloc(size_t nmemb, size_t size);

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from __fc_heap_status;
    assigns \result \from size, ptr, __fc_heap_status;
    frees ptr;
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(size);
      ensures allocation: \fresh{Old, Here}(\result,\old(size));
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \result;
    
    behavior deallocation:
      assumes nonnull_ptr: ptr ≢ \null;
      assumes can_allocate: is_allocable(size);
      ensures freed: \allocable(\old(ptr));
      ensures freeable: \result ≡ \null ∨ \freeable(\result);
      frees ptr;
    
    behavior fail:
      assumes cannot_allocate: ¬is_allocable(size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \nothing;
    
    complete behaviors fail, deallocation, allocation;
    disjoint behaviors allocation, fail;
    disjoint behaviors deallocation, fail;
 */
void *realloc(void *ptr, size_t size);

/*@ exits status: \exit_status ≢ 0;
    ensures never_terminates: \false;
    
    assigns \exit_status \from \nothing;
 */
void abort(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
int atexit(void (*func)(void));

/*@ assigns \result;
    assigns \result \from \nothing; */
int at_quick_exit(void (*func)(void));

/*@ exits status: \exit_status ≡ \old(status);
    ensures never_terminates: \false;
    
    assigns \exit_status \from status;
 */
void exit(int status);

/*@ ensures never_terminates: \false;
    assigns \nothing; */
void _Exit(int status);

char *__fc_env[4096];
/*@ requires valid_name: valid_read_string(name);
    ensures null_or_valid_result: \result ≡ \null ∨ \valid(\result);
    assigns \result;
    assigns \result \from __fc_env[0 ..], (indirect: name), *(name + (0 ..));
 */
char *getenv(char const *name);

/*@ requires valid_string: valid_read_string(string);
    assigns __fc_env[0 ..], \result;
    assigns __fc_env[0 ..] \from __fc_env[0 ..], string;
    assigns \result \from (indirect: __fc_env[0 ..]), (indirect: string);
 */
int putenv(char *string);

/*@ requires valid_name: valid_read_string(name);
    requires valid_value: valid_read_string(value);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_env[0 ..];
    assigns \result
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..))),
            (indirect: value), (indirect: *(value + (0 ..))),
            (indirect: overwrite);
    assigns __fc_env[0 ..]
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..))),
            (indirect: value), (indirect: *(value + (0 ..))),
            (indirect: overwrite);
 */
int setenv(char const *name, char const *value, int overwrite);

/*@ requires valid_name: valid_read_string(name);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_env[0 ..];
    assigns \result
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..)));
    assigns __fc_env[0 ..]
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..)));
 */
int unsetenv(char const *name);

/*@ ensures never_terminates: \false;
    assigns \nothing; */
void quick_exit(int status);

/*@ requires
      null_or_valid_string_command:
        command ≡ \null ∨ valid_read_string(command);
    assigns \result;
    assigns \result
      \from (indirect: command), (indirect: *(command + (0 ..)));
 */
int system(char const *command);

/*@ requires valid_function_compar: \valid_function(compar);
    ensures
      null_or_correct_result:
        \result ≡ \null ∨
        \subset(\result,
               (void *)((char *)\old(base) +
                        (0 .. \old(size) * (\old(nmemb) - 1))));
    assigns \result;
    assigns \result
      \from (indirect: key), *((char *)key + (0 .. size - 1)), base,
            *((char *)base + (0 .. size * (nmemb - 1))), (indirect: nmemb),
            (indirect: size), (indirect: *compar);
 */
void *bsearch(void const *key, void const *base, size_t nmemb, size_t size,
              int (*compar)(void const *, void const *));

/*@ requires valid_function_compar: \valid_function(compar);
    assigns *((char *)base + (0 ..));
    assigns *((char *)base + (0 ..))
      \from (indirect: base), *((char *)base + (0 ..)), (indirect: nmemb),
            (indirect: size), (indirect: compar), (indirect: *compar);
 */
void qsort(void *base, size_t nmemb, size_t size,
           int (*compar)(void const *, void const *));

/*@ requires abs_representable: j > -2147483647 - 1;
    assigns \result;
    assigns \result \from j;
    
    behavior negative:
      assumes negative: j < 0;
      ensures opposite_result: \result ≡ -\old(j);
    
    behavior nonnegative:
      assumes nonnegative: j ≥ 0;
      ensures same_result: \result ≡ \old(j);
    
    complete behaviors nonnegative, negative;
    disjoint behaviors nonnegative, negative;
 */
int abs(int j);

/*@ requires abs_representable: j > -2147483647L - 1L;
    assigns \result;
    assigns \result \from j;
    
    behavior negative:
      assumes negative: j < 0;
      ensures opposite_result: \result ≡ -\old(j);
    
    behavior nonnegative:
      assumes nonnegative: j ≥ 0;
      ensures same_result: \result ≡ \old(j);
    
    complete behaviors nonnegative, negative;
    disjoint behaviors nonnegative, negative;
 */
long labs(long j);

/*@ requires abs_representable: j > -9223372036854775807LL - 1LL;
    assigns \result;
    assigns \result \from j;
    
    behavior negative:
      assumes negative: j < 0;
      ensures opposite_result: \result ≡ -\old(j);
    
    behavior nonnegative:
      assumes nonnegative: j ≥ 0;
      ensures same_result: \result ≡ \old(j);
    
    complete behaviors nonnegative, negative;
    disjoint behaviors nonnegative, negative;
 */
long long llabs(long long j);

/*@ assigns \result;
    assigns \result \from numer, denom; */
div_t div(int numer, int denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
ldiv_t ldiv(long numer, long denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
lldiv_t lldiv(long long numer, long long denom);

/*@ ghost int __fc_mblen_state; */
/*@ assigns \result, __fc_mblen_state;
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 ..))), (indirect: n),
            __fc_mblen_state;
    assigns __fc_mblen_state
      \from (indirect: s), (indirect: *(s + (0 ..))), (indirect: n),
            __fc_mblen_state;
 */
int mblen(char const *s, size_t n);

/*@ ghost int __fc_mbtowc_state; */
/*@ requires separation: \separated(pwc, s);
    ensures consumed_range: \result ≤ \old(n);
    assigns \result, *(pwc + (0 .. \result - 1)), __fc_mbtowc_state;
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 .. n - 1))), (indirect: n),
            __fc_mbtowc_state;
    assigns *(pwc + (0 .. \result - 1))
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n),
            __fc_mbtowc_state;
    assigns __fc_mbtowc_state
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n),
            __fc_mbtowc_state;
 */
int mbtowc(int * __restrict pwc, char const * __restrict s, size_t n);

/*@ ghost int __fc_wctomb_state; */
/*@ assigns \result, *(s + (0 ..)), __fc_wctomb_state;
    assigns \result \from (indirect: wc), __fc_wctomb_state;
    assigns *(s + (0 ..)) \from wc, __fc_wctomb_state;
    assigns __fc_wctomb_state \from wc, __fc_wctomb_state;
 */
int wctomb(char *s, int wc);

/*@ requires separation: \separated(pwcs, s);
    assigns \result, *(pwcs + (0 .. n - 1));
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 .. n - 1))), (indirect: n);
    assigns *(pwcs + (0 .. n - 1))
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n);
 */
size_t mbstowcs(int * __restrict pwcs, char const * __restrict s, size_t n);

/*@ requires separation: \separated(s, pwcs);
    assigns \result, *(s + (0 .. n - 1));
    assigns \result
      \from (indirect: pwcs), (indirect: *(pwcs + (0 .. n - 1))),
            (indirect: n);
    assigns *(s + (0 .. n - 1))
      \from (indirect: pwcs), *(pwcs + (0 .. n - 1)), (indirect: n);
 */
size_t wcstombs(char * __restrict s, int const * __restrict pwcs, size_t n);

/*@ requires valid_memptr: \valid(memptr);
    requires
      alignment_is_a_suitable_power_of_two:
        alignment ≥ sizeof(void *) ∧ (alignment & (alignment - 1)) ≡ 0;
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status
      \from (indirect: alignment), size, __fc_heap_status;
    assigns \result
      \from (indirect: alignment), (indirect: size),
            (indirect: __fc_heap_status);
    allocates *\old(memptr);
    
    behavior allocation:
      assumes can_allocate: is_allocable(size);
      ensures allocation: \fresh{Old, Here}(*\old(memptr),\old(size));
      ensures result_zero: \result ≡ 0;
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status
        \from (indirect: alignment), size, __fc_heap_status;
      assigns \result
        \from (indirect: alignment), (indirect: size),
              (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(size);
      ensures result_non_zero: \result < 0 ∨ \result > 0;
      assigns \result;
      assigns \result \from (indirect: alignment);
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int posix_memalign(void **memptr, size_t alignment, size_t size);

/*@ requires valid_template: valid_string(templat);
    ensures
      result_error_or_valid_fd: \result ≡ -1 ∨ (0 ≤ \result < 16);
    assigns *(templat + (0 ..)), \result;
    assigns *(templat + (0 ..)) \from \nothing;
    assigns \result \from \nothing;
 */
int mkstemp(char *templat);

void T::Ctor(struct T const *this, struct T const *__frama_c_arg_0);

void T::Ctor(struct T const *this, struct T *__frama_c_arg_0);

struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this); */
void T::Ctor(struct T const *this)
{
  this->x = 42;
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void T::Ctor(struct T const *this, struct T const *__frama_c_arg_0)
{
  this->x = __frama_c_arg_0->x;
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid(__frama_c_arg_0);
 */
void T::Ctor(struct T const *this, struct T *__frama_c_arg_0)
{
  this->x = __frama_c_arg_0->x;
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "T",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void U::Ctor(struct U const *this, struct U const *__frama_c_arg_0);

void U::Ctor(struct U const *this, struct U *__frama_c_arg_0);

struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
int id;
void *U::new(size_t s, int x)
{
  void *tmp;
  id = x;
  tmp = malloc(s);
  return tmp;
}

/*@ requires \valid_read(this); */
void U::Ctor(struct U const *this)
{
  this->foo = 1;
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void U::Ctor(struct U const *this, struct U const *__frama_c_arg_0)
{
  this->foo = __frama_c_arg_0->foo;
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid(__frama_c_arg_0);
 */
void U::Ctor(struct U const *this, struct U *__frama_c_arg_0)
{
  this->foo = __frama_c_arg_0->foo;
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "U",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
int main(void)
{
  int __retres;
  int t;
  struct T *__fc_tmp_0;
  struct U *u;
  struct U *__fc_tmp_1;
  struct T *__fc_tmp_2;
  void *p = (void *)(& t);
  __fc_tmp_0 = (struct T *)p;
  T::Ctor((struct T const *)__fc_tmp_0);
  p = (void *)__fc_tmp_0;
  __fc_tmp_1 = (struct U *)U::new(sizeof(struct U),43);
  U::Ctor((struct U const *)__fc_tmp_1);
  u = __fc_tmp_1;
  struct T obj;
  T::Ctor(& obj);
  __fc_tmp_2 = & obj;
  T::Ctor((struct T const *)__fc_tmp_2);
  __retres = ((obj.x + ((struct T *)p)->x) + id) + u->foo;
  return __retres;
}


