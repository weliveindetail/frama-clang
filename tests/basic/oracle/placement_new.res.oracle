[kernel] Parsing tests/basic/placement_new.cpp (external front-end)
Now output intermediate result
[kernel] Warning: Assuming declared function malloc can't throw any exception
/* Generated by Frama-C */
typedef unsigned int size_t;
struct _frama_c_vmt_content {
   void (*method_ptr)() ;
   int shift_this ;
};
struct _frama_c_rtti_name_info_node;
struct _frama_c_vmt {
   struct _frama_c_vmt_content *table ;
   int table_size ;
   struct _frama_c_rtti_name_info_node *rtti_info ;
};
struct _frama_c_rtti_name_info_content {
   struct _frama_c_rtti_name_info_node *value ;
   int shift_object ;
   int shift_vmt ;
};
struct _frama_c_rtti_name_info_node {
   char const *name ;
   struct _frama_c_rtti_name_info_content *base_classes ;
   int number_of_base_classes ;
   struct _frama_c_vmt *pvmt ;
};
struct __fc_div_t {
   int quot ;
   int rem ;
};
typedef struct __fc_div_t div_t;
struct __fc_ldiv_t {
   long quot ;
   long rem ;
};
typedef struct __fc_ldiv_t ldiv_t;
struct __fc_lldiv_t {
   long long quot ;
   long long rem ;
};
typedef struct __fc_lldiv_t lldiv_t;
typedef size_t size_t;
struct T;
struct T {
   int x ;
};
struct U;
struct U {
   int foo ;
};
void *malloc(size_t size);

void free(void *p);

/*@ ghost int __fc_heap_status; */
/*@ requires freeable: p â‰¡ \null âˆ¨ \freeable(p);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status;
    frees p;
    
    behavior deallocation:
      assumes nonnull_p: p â‰¢ \null;
      ensures freed: \allocable(\old(p));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status;
    
    behavior no_deallocation:
      assumes null_p: p â‰¡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_deallocation, deallocation;
    disjoint behaviors no_deallocation, deallocation;
 */
void free(void *p);

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(â„¤ n) 
    reads __fc_heap_status;
  
  axiom never_allocable{L}:
    âˆ€ â„¤ i; i < 0 âˆ¨ i > 4294967295U â‡’ Â¬is_allocable(i);
  
  }
 */
/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(size);
      ensures allocation: \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: Â¬is_allocable(size);
      ensures null_result: \result â‰¡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void *malloc(size_t size);

/*@
axiomatic MemCmp {
  logic â„¤ memcmp{L1, L2}(char *s1, char *s2, â„¤ n) 
    reads \at(*(s1 + (0 .. n - 1)),L1), \at(*(s2 + (0 .. n - 1)),L2);
  
  axiom memcmp_zero{L1, L2}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ n;
      memcmp{L1, L2}(s1, s2, n) â‰¡ 0 â‡”
      (âˆ€ â„¤ i; 0 â‰¤ i < n â‡’ \at(*(s1 + i),L1) â‰¡ \at(*(s2 + i),L2));
  
  }
 */
/*@
axiomatic MemChr {
  logic ð”¹ memchr{L}(char *s, â„¤ c, â„¤ n) 
    reads *(s + (0 .. n - 1));
  
  logic â„¤ memchr_off{L}(char *s, â„¤ c, â„¤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memchr_def{L}:
    âˆ€ char *s;
    âˆ€ â„¤ c;
    âˆ€ â„¤ n;
      memchr(s, c, n) â‰¢ (0 â‰¢ 0) â‡”
      (âˆƒ int i; 0 â‰¤ i < n âˆ§ *(s + i) â‰¡ c);
  
  }
 */
/*@
axiomatic MemSet {
  logic ð”¹ memset{L}(char *s, â„¤ c, â„¤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memset_def{L}:
    âˆ€ char *s;
    âˆ€ â„¤ c;
    âˆ€ â„¤ n;
      memset(s, c, n) â‰¢ (0 â‰¢ 0) â‡”
      (âˆ€ â„¤ i; 0 â‰¤ i < n â‡’ *(s + i) â‰¡ c);
  
  }
 */
/*@
axiomatic StrLen {
  logic â„¤ strlen{L}(char *s) 
    reads *(s + (0 ..));
  
  axiom strlen_pos_or_null{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i;
      0 â‰¤ i âˆ§ (âˆ€ â„¤ j; 0 â‰¤ j < i â‡’ *(s + j) â‰¢ (char)0) âˆ§
      *(s + i) â‰¡ (char)0 â‡’ strlen(s) â‰¡ i;
  
  axiom strlen_neg{L}:
    âˆ€ char *s;
      (âˆ€ â„¤ i; 0 â‰¤ i â‡’ *(s + i) â‰¢ (char)0) â‡’ strlen(s) < 0;
  
  axiom strlen_before_null{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i; 0 â‰¤ i < strlen(s) â‡’ *(s + i) â‰¢ (char)0;
  
  axiom strlen_at_null{L}:
    âˆ€ char *s; 0 â‰¤ strlen(s) â‡’ *(s + strlen(s)) â‰¡ (char)0;
  
  axiom strlen_not_zero{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i;
      0 â‰¤ i â‰¤ strlen(s) âˆ§ *(s + i) â‰¢ (char)0 â‡’ i < strlen(s);
  
  axiom strlen_zero{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i;
      0 â‰¤ i â‰¤ strlen(s) âˆ§ *(s + i) â‰¡ (char)0 â‡’ i â‰¡ strlen(s);
  
  axiom strlen_sup{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i; 0 â‰¤ i âˆ§ *(s + i) â‰¡ (char)0 â‡’ 0 â‰¤ strlen(s) â‰¤ i;
  
  axiom strlen_shift{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i; 0 â‰¤ i â‰¤ strlen(s) â‡’ strlen(s + i) â‰¡ strlen(s) - i;
  
  axiom strlen_create{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i; 0 â‰¤ i âˆ§ *(s + i) â‰¡ (char)0 â‡’ 0 â‰¤ strlen(s) â‰¤ i;
  
  axiom strlen_create_shift{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i;
    âˆ€ â„¤ k;
      0 â‰¤ k â‰¤ i âˆ§ *(s + i) â‰¡ (char)0 â‡’
      0 â‰¤ strlen(s + k) â‰¤ i - k;
  
  axiom memcmp_strlen_left{L}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ n;
      memcmp{L, L}(s1, s2, n) â‰¡ 0 âˆ§ strlen(s1) < n â‡’
      strlen(s1) â‰¡ strlen(s2);
  
  axiom memcmp_strlen_right{L}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ n;
      memcmp{L, L}(s1, s2, n) â‰¡ 0 âˆ§ strlen(s2) < n â‡’
      strlen(s1) â‰¡ strlen(s2);
  
  axiom memcmp_strlen_shift_left{L}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ k, â„¤ n;
      memcmp{L, L}(s1, s2 + k, n) â‰¡ 0 â‰¤ k âˆ§ strlen(s1) < n â‡’
      0 â‰¤ strlen(s2) â‰¤ k + strlen(s1);
  
  axiom memcmp_strlen_shift_right{L}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ k, â„¤ n;
      memcmp{L, L}(s1 + k, s2, n) â‰¡ 0 â‰¤ k âˆ§ strlen(s2) < n â‡’
      0 â‰¤ strlen(s1) â‰¤ k + strlen(s2);
  
  }
 */
/*@
axiomatic StrCmp {
  logic â„¤ strcmp{L}(char *s1, char *s2) 
    reads *(s1 + (0 .. strlen(s1))), *(s2 + (0 .. strlen(s2)));
  
  axiom strcmp_zero{L}:
    âˆ€ char *s1, char *s2;
      strcmp(s1, s2) â‰¡ 0 â‡”
      strlen(s1) â‰¡ strlen(s2) âˆ§
      (âˆ€ â„¤ i; 0 â‰¤ i â‰¤ strlen(s1) â‡’ *(s1 + i) â‰¡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrNCmp {
  logic â„¤ strncmp{L}(char *s1, char *s2, â„¤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom strncmp_zero{L}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ n;
      strncmp(s1, s2, n) â‰¡ 0 â‡”
      (strlen(s1) < n âˆ§ strcmp(s1, s2) â‰¡ 0) âˆ¨
      (âˆ€ â„¤ i; 0 â‰¤ i < n â‡’ *(s1 + i) â‰¡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrChr {
  logic ð”¹ strchr{L}(char *s, â„¤ c) 
    reads *(s + (0 .. strlen(s)));
  
  axiom strchr_def{L}:
    âˆ€ char *s;
    âˆ€ â„¤ c;
      strchr(s, c) â‰¢ (0 â‰¢ 0) â‡”
      (âˆƒ â„¤ i; 0 â‰¤ i â‰¤ strlen(s) âˆ§ *(s + i) â‰¡ (char)((int)c));
  
  }
 */
/*@
axiomatic WMemChr {
  logic ð”¹ wmemchr{L}(int *s, int c, â„¤ n) 
    reads *(s + (0 .. n - 1));
  
  logic â„¤ wmemchr_off{L}(int *s, int c, â„¤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom wmemchr_def{L}:
    âˆ€ int *s;
    âˆ€ int c;
    âˆ€ â„¤ n;
      wmemchr(s, c, n) â‰¢ (0 â‰¢ 0) â‡”
      (âˆƒ int i; 0 â‰¤ i < n âˆ§ *(s + i) â‰¡ c);
  
  }
 */
/*@
axiomatic WcsLen {
  logic â„¤ wcslen{L}(int *s) 
    reads *(s + (0 ..));
  
  axiom wcslen_pos_or_null{L}:
    âˆ€ int *s;
    âˆ€ â„¤ i;
      0 â‰¤ i âˆ§ (âˆ€ â„¤ j; 0 â‰¤ j < i â‡’ *(s + j) â‰¢ (int)0) âˆ§
      *(s + i) â‰¡ (int)0 â‡’ wcslen(s) â‰¡ i;
  
  axiom wcslen_neg{L}:
    âˆ€ int *s;
      (âˆ€ â„¤ i; 0 â‰¤ i â‡’ *(s + i) â‰¢ (int)0) â‡’ wcslen(s) < 0;
  
  axiom wcslen_before_null{L}:
    âˆ€ int *s;
    âˆ€ int i; 0 â‰¤ i < wcslen(s) â‡’ *(s + i) â‰¢ (int)0;
  
  axiom wcslen_at_null{L}:
    âˆ€ int *s; 0 â‰¤ wcslen(s) â‡’ *(s + wcslen(s)) â‰¡ (int)0;
  
  axiom wcslen_not_zero{L}:
    âˆ€ int *s;
    âˆ€ int i;
      0 â‰¤ i â‰¤ wcslen(s) âˆ§ *(s + i) â‰¢ (int)0 â‡’ i < wcslen(s);
  
  axiom wcslen_zero{L}:
    âˆ€ int *s;
    âˆ€ int i;
      0 â‰¤ i â‰¤ wcslen(s) âˆ§ *(s + i) â‰¡ (int)0 â‡’ i â‰¡ wcslen(s);
  
  axiom wcslen_sup{L}:
    âˆ€ int *s;
    âˆ€ int i; 0 â‰¤ i âˆ§ *(s + i) â‰¡ (int)0 â‡’ 0 â‰¤ wcslen(s) â‰¤ i;
  
  axiom wcslen_shift{L}:
    âˆ€ int *s;
    âˆ€ int i; 0 â‰¤ i â‰¤ wcslen(s) â‡’ wcslen(s + i) â‰¡ wcslen(s) - i;
  
  axiom wcslen_create{L}:
    âˆ€ int *s;
    âˆ€ int i; 0 â‰¤ i âˆ§ *(s + i) â‰¡ (int)0 â‡’ 0 â‰¤ wcslen(s) â‰¤ i;
  
  axiom wcslen_create_shift{L}:
    âˆ€ int *s;
    âˆ€ int i;
    âˆ€ int k;
      0 â‰¤ k â‰¤ i âˆ§ *(s + i) â‰¡ (int)0 â‡’ 0 â‰¤ wcslen(s + k) â‰¤ i - k;
  
  }
 */
/*@
axiomatic WcsCmp {
  logic â„¤ wcscmp{L}(int *s1, int *s2) 
    reads *(s1 + (0 .. wcslen(s1))), *(s2 + (0 .. wcslen(s2)));
  
  axiom wcscmp_zero{L}:
    âˆ€ int *s1, int *s2;
      wcscmp(s1, s2) â‰¡ 0 â‡”
      wcslen(s1) â‰¡ wcslen(s2) âˆ§
      (âˆ€ â„¤ i; 0 â‰¤ i â‰¤ wcslen(s1) â‡’ *(s1 + i) â‰¡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsNCmp {
  logic â„¤ wcsncmp{L}(int *s1, int *s2, â„¤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom wcsncmp_zero{L}:
    âˆ€ int *s1, int *s2;
    âˆ€ â„¤ n;
      wcsncmp(s1, s2, n) â‰¡ 0 â‡”
      (wcslen(s1) < n âˆ§ wcscmp(s1, s2) â‰¡ 0) âˆ¨
      (âˆ€ â„¤ i; 0 â‰¤ i < n â‡’ *(s1 + i) â‰¡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsChr {
  logic ð”¹ wcschr{L}(int *wcs, â„¤ wc) 
    reads *(wcs + (0 .. wcslen(wcs)));
  
  axiom wcschr_def{L}:
    âˆ€ int *wcs;
    âˆ€ â„¤ wc;
      wcschr(wcs, wc) â‰¢ (0 â‰¢ 0) â‡”
      (âˆƒ â„¤ i; 0 â‰¤ i â‰¤ wcslen(wcs) âˆ§ *(wcs + i) â‰¡ (int)((int)wc));
  
  }
 */
/*@ logic â„¤ minimum(â„¤ i, â„¤ j) = i < j? i: j;
 */
/*@ logic â„¤ maximum(â„¤ i, â„¤ j) = i < j? j: i;
 */
/*@
predicate valid_string{L}(char *s) =
  0 â‰¤ strlen(s) âˆ§ \valid(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_string{L}(char *s) =
  0 â‰¤ strlen(s) âˆ§ \valid_read(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_nstring{L}(char *s, â„¤ n) =
  (\valid_read(s + (0 .. n - 1)) âˆ§ \initialized(s + (0 .. n - 1))) âˆ¨
  valid_read_string(s);
 */
/*@
predicate valid_string_or_null{L}(char *s) = s â‰¡ \null âˆ¨ valid_string(s);
 */
/*@
predicate valid_wstring{L}(int *s) =
  0 â‰¤ wcslen(s) âˆ§ \valid(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_read_wstring{L}(int *s) =
  0 â‰¤ wcslen(s) âˆ§ \valid_read(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_read_nwstring{L}(int *s, â„¤ n) =
  (\valid_read(s + (0 .. n - 1)) âˆ§ \initialized(s + (0 .. n - 1))) âˆ¨
  valid_read_wstring(s);
 */
/*@
predicate valid_wstring_or_null{L}(int *s) =
  s â‰¡ \null âˆ¨ valid_wstring(s);
 */
/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
double atof(char const *nptr);

/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
int atoi(char const *nptr);

/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
long atol(char const *nptr);

/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
long long atoll(char const *nptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior no_storage:
      assumes null_endptr: endptr â‰¡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior store_position:
      assumes nonnull_endptr: endptr â‰¢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
double strtod(char const * __restrict nptr, char ** __restrict endptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior no_storage:
      assumes null_endptr: endptr â‰¡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior store_position:
      assumes nonnull_endptr: endptr â‰¢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
float strtof(char const * __restrict nptr, char ** __restrict endptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior no_storage:
      assumes null_endptr: endptr â‰¡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior store_position:
      assumes nonnull_endptr: endptr â‰¢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
long double strtold(char const * __restrict nptr, char ** __restrict endptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base â‰¡ 0 âˆ¨ (2 â‰¤ base â‰¤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr â‰¡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr â‰¢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
long strtol(char const * __restrict nptr, char ** __restrict endptr, int base);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base â‰¡ 0 âˆ¨ (2 â‰¤ base â‰¤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr â‰¡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr â‰¢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
long long strtoll(char const * __restrict nptr, char ** __restrict endptr,
                  int base);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base â‰¡ 0 âˆ¨ (2 â‰¤ base â‰¤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr â‰¡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr â‰¢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
unsigned long strtoul(char const * __restrict nptr,
                      char ** __restrict endptr, int base);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base â‰¡ 0 âˆ¨ (2 â‰¤ base â‰¤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr â‰¡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr â‰¢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
unsigned long long strtoull(char const * __restrict nptr,
                            char ** __restrict endptr, int base);

/*@ ghost int __fc_random_counter; */
static unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ensures result_range: 0 â‰¤ \result â‰¤ __fc_rand_max;
    assigns \result, __fc_random_counter;
    assigns \result \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
int rand(void);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
void srand(unsigned int seed);

/*@ ensures result_range: 0 â‰¤ \result â‰¤ __fc_rand_max;
    assigns \result;
    assigns \result \from __fc_random_counter;
 */
long random(void);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
void srandom(unsigned int seed);

int __fc_random48_init;
unsigned short __fc_random48_counter[3];
unsigned short *__fc_p_random48_counter = __fc_random48_counter;
/*@ ensures random48_initialized: __fc_random48_init â‰¡ 1;
    assigns __fc_random48_counter[0 .. 2], __fc_random48_init;
    assigns __fc_random48_counter[0 .. 2] \from seed;
    assigns __fc_random48_init \from \nothing;
 */
void srand48(long seed);

/*@ requires
      initialized_seed16v: initialization: \initialized(seed16v + (0 .. 2));
    ensures random48_initialized: __fc_random48_init â‰¡ 1;
    ensures result_counter: \result â‰¡ __fc_p_random48_counter;
    assigns __fc_random48_counter[0 .. 2], __fc_random48_init, \result;
    assigns __fc_random48_counter[0 .. 2]
      \from (indirect: *(seed16v + (0 .. 2)));
    assigns __fc_random48_init \from \nothing;
    assigns \result \from __fc_p_random48_counter;
 */
unsigned short *seed48(unsigned short * /*[3]*/ seed16v);

/*@ ensures random48_initialized: __fc_random48_init â‰¡ 1;
    assigns __fc_random48_counter[0 .. 2], __fc_random48_init;
    assigns __fc_random48_counter[0 .. 2] \from *(param + (0 .. 5));
    assigns __fc_random48_init \from \nothing;
 */
void lcong48(unsigned short * /*[7]*/ param);

/*@ requires random48_initialized: __fc_random48_init â‰¡ 1;
    ensures result_range: \is_finite(\result) âˆ§ 0.0 â‰¤ \result < 1.0;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
double drand48(void);

/*@ requires
      initialized_xsubi: initialization: \initialized(xsubi + (0 .. 2));
    ensures result_range: \is_finite(\result) âˆ§ 0.0 â‰¤ \result < 1.0;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
double erand48(unsigned short * /*[3]*/ xsubi);

/*@ requires random48_initialized: __fc_random48_init â‰¡ 1;
    ensures result_range: 0 â‰¤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
long lrand48(void);

/*@ requires
      initialized_xsubi: initialization: \initialized(xsubi + (0 .. 2));
    ensures result_range: 0 â‰¤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
long nrand48(unsigned short * /*[3]*/ xsubi);

/*@ requires random48_initialized: __fc_random48_init â‰¡ 1;
    ensures result_range: -2147483648 â‰¤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
long mrand48(void);

/*@ requires
      initialized_xsubi: initialization: \initialized(xsubi + (0 .. 2));
    ensures result_range: -2147483648 â‰¤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
long jrand48(unsigned short * /*[3]*/ xsubi);

/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status
      \from (indirect: nmemb), (indirect: size), __fc_heap_status;
    assigns \result
      \from (indirect: nmemb), (indirect: size), (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(nmemb * size);
      ensures
        allocation: \fresh{Old, Here}(\result,\old(nmemb) * \old(size));
      ensures
        initialization:
          \initialized((char *)\result + (0 .. \old(nmemb) * \old(size) - 1));
      ensures
        zero_initialization:
          \subset(*((char *)\result + (0 .. \old(nmemb) * \old(size) - 1)),
                 {0});
    
    behavior no_allocation:
      assumes cannot_allocate: Â¬is_allocable(nmemb * size);
      ensures null_result: \result â‰¡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void *calloc(size_t nmemb, size_t size);

/*@ requires freeable: ptr â‰¡ \null âˆ¨ \freeable(ptr);
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from __fc_heap_status;
    assigns \result \from size, ptr, __fc_heap_status;
    frees ptr;
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(size);
      ensures allocation: \fresh{Old, Here}(\result,\old(size));
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \result;
    
    behavior deallocation:
      assumes nonnull_ptr: ptr â‰¢ \null;
      assumes can_allocate: is_allocable(size);
      ensures freed: \allocable(\old(ptr));
      ensures freeable: \result â‰¡ \null âˆ¨ \freeable(\result);
      frees ptr;
    
    behavior fail:
      assumes cannot_allocate: Â¬is_allocable(size);
      ensures null_result: \result â‰¡ \null;
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \nothing;
    
    complete behaviors fail, deallocation, allocation;
    disjoint behaviors allocation, fail;
    disjoint behaviors deallocation, fail;
 */
void *realloc(void *ptr, size_t size);

/*@ exits status: \exit_status â‰¢ 0;
    ensures never_terminates: \false;
    
    assigns \exit_status \from \nothing;
 */
void abort(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
int atexit(void (*func)(void));

/*@ assigns \result;
    assigns \result \from \nothing; */
int at_quick_exit(void (*func)(void));

/*@ exits status: \exit_status â‰¡ \old(status);
    ensures never_terminates: \false;
    
    assigns \exit_status \from status;
 */
void exit(int status);

/*@ ensures never_terminates: \false;
    assigns \nothing; */
void _Exit(int status);

char *__fc_env[4096];
/*@ requires valid_name: valid_read_string(name);
    ensures null_or_valid_result: \result â‰¡ \null âˆ¨ \valid(\result);
    assigns \result;
    assigns \result \from __fc_env[0 ..], (indirect: name), *(name + (0 ..));
 */
char *getenv(char const *name);

/*@ requires valid_string: valid_read_string(string);
    assigns __fc_env[0 ..], \result;
    assigns __fc_env[0 ..] \from __fc_env[0 ..], string;
    assigns \result \from (indirect: __fc_env[0 ..]), (indirect: string);
 */
int putenv(char *string);

/*@ requires valid_name: valid_read_string(name);
    requires valid_value: valid_read_string(value);
    ensures result_ok_or_error: \result â‰¡ 0 âˆ¨ \result â‰¡ -1;
    assigns \result, __fc_env[0 ..];
    assigns \result
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..))),
            (indirect: value), (indirect: *(value + (0 ..))),
            (indirect: overwrite);
    assigns __fc_env[0 ..]
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..))),
            (indirect: value), (indirect: *(value + (0 ..))),
            (indirect: overwrite);
 */
int setenv(char const *name, char const *value, int overwrite);

/*@ requires valid_name: valid_read_string(name);
    ensures result_ok_or_error: \result â‰¡ 0 âˆ¨ \result â‰¡ -1;
    assigns \result, __fc_env[0 ..];
    assigns \result
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..)));
    assigns __fc_env[0 ..]
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..)));
 */
int unsetenv(char const *name);

/*@ ensures never_terminates: \false;
    assigns \nothing; */
void quick_exit(int status);

/*@ requires
      null_or_valid_string_command:
        command â‰¡ \null âˆ¨ valid_read_string(command);
    assigns \result;
    assigns \result
      \from (indirect: command), (indirect: *(command + (0 ..)));
 */
int system(char const *command);

/*@ requires valid_function_compar: \valid_function(compar);
    ensures
      null_or_correct_result:
        \result â‰¡ \null âˆ¨
        \subset(\result,
               (void *)((char *)\old(base) +
                        (0 .. \old(size) * (\old(nmemb) - 1))));
    assigns \result;
    assigns \result
      \from (indirect: key), *((char *)key + (0 .. size - 1)), base,
            *((char *)base + (0 .. size * (nmemb - 1))), (indirect: nmemb),
            (indirect: size), (indirect: *compar);
 */
void *bsearch(void const *key, void const *base, size_t nmemb, size_t size,
              int (*compar)(void const *, void const *));

/*@ requires valid_function_compar: \valid_function(compar);
    assigns *((char *)base + (0 ..));
    assigns *((char *)base + (0 ..))
      \from (indirect: base), *((char *)base + (0 ..)), (indirect: nmemb),
            (indirect: size), (indirect: compar), (indirect: *compar);
 */
void qsort(void *base, size_t nmemb, size_t size,
           int (*compar)(void const *, void const *));

/*@ requires abs_representable: j > -2147483647 - 1;
    assigns \result;
    assigns \result \from j;
    
    behavior negative:
      assumes negative: j < 0;
      ensures opposite_result: \result â‰¡ -\old(j);
    
    behavior nonnegative:
      assumes nonnegative: j â‰¥ 0;
      ensures same_result: \result â‰¡ \old(j);
    
    complete behaviors nonnegative, negative;
    disjoint behaviors nonnegative, negative;
 */
int abs(int j);

/*@ requires abs_representable: j > -2147483647L - 1L;
    assigns \result;
    assigns \result \from j;
    
    behavior negative:
      assumes negative: j < 0;
      ensures opposite_result: \result â‰¡ -\old(j);
    
    behavior nonnegative:
      assumes nonnegative: j â‰¥ 0;
      ensures same_result: \result â‰¡ \old(j);
    
    complete behaviors nonnegative, negative;
    disjoint behaviors nonnegative, negative;
 */
long labs(long j);

/*@ requires abs_representable: j > -9223372036854775807LL - 1LL;
    assigns \result;
    assigns \result \from j;
    
    behavior negative:
      assumes negative: j < 0;
      ensures opposite_result: \result â‰¡ -\old(j);
    
    behavior nonnegative:
      assumes nonnegative: j â‰¥ 0;
      ensures same_result: \result â‰¡ \old(j);
    
    complete behaviors nonnegative, negative;
    disjoint behaviors nonnegative, negative;
 */
long long llabs(long long j);

/*@ assigns \result;
    assigns \result \from numer, denom; */
div_t div(int numer, int denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
ldiv_t ldiv(long numer, long denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
lldiv_t lldiv(long long numer, long long denom);

/*@ ghost int __fc_mblen_state; */
/*@ assigns \result, __fc_mblen_state;
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 ..))), (indirect: n),
            __fc_mblen_state;
    assigns __fc_mblen_state
      \from (indirect: s), (indirect: *(s + (0 ..))), (indirect: n),
            __fc_mblen_state;
 */
int mblen(char const *s, size_t n);

/*@ ghost int __fc_mbtowc_state; */
/*@ requires separation: \separated(pwc, s);
    ensures consumed_range: \result â‰¤ \old(n);
    assigns \result, *(pwc + (0 .. \result - 1)), __fc_mbtowc_state;
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 .. n - 1))), (indirect: n),
            __fc_mbtowc_state;
    assigns *(pwc + (0 .. \result - 1))
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n),
            __fc_mbtowc_state;
    assigns __fc_mbtowc_state
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n),
            __fc_mbtowc_state;
 */
int mbtowc(int * __restrict pwc, char const * __restrict s, size_t n);

/*@ ghost int __fc_wctomb_state; */
/*@ assigns \result, *(s + (0 ..)), __fc_wctomb_state;
    assigns \result \from (indirect: wc), __fc_wctomb_state;
    assigns *(s + (0 ..)) \from wc, __fc_wctomb_state;
    assigns __fc_wctomb_state \from wc, __fc_wctomb_state;
 */
int wctomb(char *s, int wc);

/*@ requires separation: \separated(pwcs, s);
    assigns \result, *(pwcs + (0 .. n - 1));
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 .. n - 1))), (indirect: n);
    assigns *(pwcs + (0 .. n - 1))
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n);
 */
size_t mbstowcs(int * __restrict pwcs, char const * __restrict s, size_t n);

/*@ requires separation: \separated(s, pwcs);
    assigns \result, *(s + (0 .. n - 1));
    assigns \result
      \from (indirect: pwcs), (indirect: *(pwcs + (0 .. n - 1))),
            (indirect: n);
    assigns *(s + (0 .. n - 1))
      \from (indirect: pwcs), *(pwcs + (0 .. n - 1)), (indirect: n);
 */
size_t wcstombs(char * __restrict s, int const * __restrict pwcs, size_t n);

/*@ requires valid_memptr: \valid(memptr);
    requires
      alignment_is_a_suitable_power_of_two:
        alignment â‰¥ sizeof(void *) âˆ§ (alignment & (alignment - 1)) â‰¡ 0;
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status
      \from (indirect: alignment), size, __fc_heap_status;
    assigns \result
      \from (indirect: alignment), (indirect: size),
            (indirect: __fc_heap_status);
    allocates *\old(memptr);
    
    behavior allocation:
      assumes can_allocate: is_allocable(size);
      ensures allocation: \fresh{Old, Here}(*\old(memptr),\old(size));
      ensures result_zero: \result â‰¡ 0;
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status
        \from (indirect: alignment), size, __fc_heap_status;
      assigns \result
        \from (indirect: alignment), (indirect: size),
              (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: Â¬is_allocable(size);
      ensures result_non_zero: \result < 0 âˆ¨ \result > 0;
      assigns \result;
      assigns \result \from (indirect: alignment);
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int posix_memalign(void **memptr, size_t alignment, size_t size);

/*@ requires valid_template: valid_string(templat);
    ensures
      result_error_or_valid_fd: \result â‰¡ -1 âˆ¨ (0 â‰¤ \result < 16);
    assigns *(templat + (0 ..)), \result;
    assigns *(templat + (0 ..)) \from \nothing;
    assigns \result \from \nothing;
 */
int mkstemp(char *templat);

void T::Ctor(struct T const *this, struct T const *__frama_c_arg_0);

void T::Ctor(struct T const *this, struct T *__frama_c_arg_0);

struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this); */
void T::Ctor(struct T const *this)
{
  this->x = 42;
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void T::Ctor(struct T const *this, struct T const *__frama_c_arg_0)
{
  this->x = __frama_c_arg_0->x;
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid(__frama_c_arg_0);
 */
void T::Ctor(struct T const *this, struct T *__frama_c_arg_0)
{
  this->x = __frama_c_arg_0->x;
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "T",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void U::Ctor(struct U const *this, struct U const *__frama_c_arg_0);

void U::Ctor(struct U const *this, struct U *__frama_c_arg_0);

struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
int id;
void *U::new(size_t s, int x)
{
  void *tmp;
  id = x;
  tmp = malloc(s);
  return tmp;
}

/*@ requires \valid_read(this); */
void U::Ctor(struct U const *this)
{
  this->foo = 1;
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid_read(__frama_c_arg_0);
 */
void U::Ctor(struct U const *this, struct U const *__frama_c_arg_0)
{
  this->foo = __frama_c_arg_0->foo;
  return;
}

/*@ requires \separated(this, __frama_c_arg_0);
    requires \valid_read(this);
    requires \valid(__frama_c_arg_0);
 */
void U::Ctor(struct U const *this, struct U *__frama_c_arg_0)
{
  this->foo = __frama_c_arg_0->foo;
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "U",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
int main(void)
{
  int __retres;
  int t;
  struct T *__fc_tmp_0;
  struct U *u;
  struct U *__fc_tmp_1;
  struct T *__fc_tmp_2;
  void *p = (void *)(& t);
  __fc_tmp_0 = (struct T *)p;
  T::Ctor((struct T const *)__fc_tmp_0);
  p = (void *)__fc_tmp_0;
  __fc_tmp_1 = (struct U *)U::new(sizeof(struct U),43);
  U::Ctor((struct U const *)__fc_tmp_1);
  u = __fc_tmp_1;
  struct T obj;
  T::Ctor(& obj);
  __fc_tmp_2 = & obj;
  T::Ctor((struct T const *)__fc_tmp_2);
  __retres = ((obj.x + ((struct T *)p)->x) + id) + u->foo;
  return __retres;
}


