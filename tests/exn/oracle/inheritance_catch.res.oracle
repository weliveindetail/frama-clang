[kernel] Parsing tests/exn/inheritance_catch.cpp (external front-end)
Now output intermediate result
/* Generated by Frama-C */
struct _frama_c_vmt_content {
   void (*method_ptr)() ;
   int shift_this ;
};
struct _frama_c_rtti_name_info_node;
struct _frama_c_vmt {
   struct _frama_c_vmt_content *table ;
   int table_size ;
   struct _frama_c_rtti_name_info_node *rtti_info ;
};
struct _frama_c_rtti_name_info_content {
   struct _frama_c_rtti_name_info_node *value ;
   int shift_object ;
   int shift_vmt ;
};
struct _frama_c_rtti_name_info_node {
   char const *name ;
   struct _frama_c_rtti_name_info_content *base_classes ;
   int number_of_base_classes ;
   struct _frama_c_vmt *pvmt ;
};
struct A;
struct A {
   int x ;
};
struct B;
struct B {
   struct A _frama_c__Z1A ;
};
struct C;
struct C {
   struct A _frama_c__Z1A ;
};
struct D;
struct D {
   struct B _frama_c__Z1B ;
   struct C _frama_c__Z1C ;
};
enum __fc_exn_enum {
    __fc_exn_kind___fc_S_Z1D = 3,
    __fc_exn_kind___fc_S_Z1C = 2,
    __fc_exn_kind___fc_S_Z1B = 1,
    __fc_exn_kind___fc_S_Z1A = 0
};
union __fc_exn_union {
   struct D __fc_S_Z1D ;
   struct C __fc_S_Z1C ;
   struct B __fc_S_Z1B ;
   struct A __fc_S_Z1A ;
};
struct __fc_exn_struct {
   int exn_uncaught ;
   enum __fc_exn_enum exn_kind ;
   union __fc_exn_union exn_obj ;
};
struct __fc_exn_struct __fc_exn =
  {.exn_uncaught = 0,
   .exn_kind = 0,
   .exn_obj = {.__fc_S_Z1D = {._frama_c__Z1B = {._frama_c__Z1A = {.x = 0}},
                              ._frama_c__Z1C = {._frama_c__Z1A = {.x = 0}}}}};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this); */
void A::Ctor(struct A const *this, int _x)
{
  this->x = _x;
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "A",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];
struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this); */
void B::Ctor(struct B const *this, int _x)
{
  A::Ctor(& this->_frama_c__Z1A,_x);
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "B",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[1];
struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this); */
void C::Ctor(struct C const *this, int _x)
{
  A::Ctor(& this->_frama_c__Z1A,_x);
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "C",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
struct _frama_c_vmt _frama_c_vmt_header;
struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info;

struct _frama_c_rtti_name_info_content _frama_c_base_classes[2];
struct _frama_c_vmt_content _frama_c_vmt[1];
/*@ requires \valid_read(this); */
void D::Ctor(struct D const *this, int _x)
{
  B::Ctor(& this->_frama_c__Z1B,_x - 1);
  C::Ctor(& this->_frama_c__Z1C,_x);
  return;
}

struct _frama_c_rtti_name_info_node _frama_c_rtti_name_info =
  {.name = "D",
   .base_classes = (struct _frama_c_rtti_name_info_content *)0,
   .number_of_base_classes = 0,
   .pvmt = (struct _frama_c_vmt *)0};
void nil(void)
{
  return;
}

void a(void)
{
  struct A __fc_tmp_0;
  A::Ctor(& __fc_tmp_0,0);
  __fc_exn.exn_uncaught = 1;
  __fc_exn.exn_kind = __fc_exn_kind___fc_S_Z1A;
  __fc_exn.exn_obj.__fc_S_Z1A = __fc_tmp_0;
  goto __ret_label;
  __ret_label: return;
}

void b(void)
{
  struct B __fc_tmp_1;
  B::Ctor(& __fc_tmp_1,1);
  __fc_exn.exn_uncaught = 1;
  __fc_exn.exn_kind = __fc_exn_kind___fc_S_Z1B;
  __fc_exn.exn_obj.__fc_S_Z1B = __fc_tmp_1;
  goto __ret_label;
  __ret_label: return;
}

void c(void)
{
  struct C __fc_tmp_2;
  C::Ctor(& __fc_tmp_2,2);
  __fc_exn.exn_uncaught = 1;
  __fc_exn.exn_kind = __fc_exn_kind___fc_S_Z1C;
  __fc_exn.exn_obj.__fc_S_Z1C = __fc_tmp_2;
  goto __ret_label;
  __ret_label: return;
}

void d(void)
{
  struct D __fc_tmp_3;
  D::Ctor(& __fc_tmp_3,3);
  __fc_exn.exn_uncaught = 1;
  __fc_exn.exn_kind = __fc_exn_kind___fc_S_Z1D;
  __fc_exn.exn_obj.__fc_S_Z1D = __fc_tmp_3;
  goto __ret_label;
  __ret_label: return;
}

void (*p[5])(void) = {& nil, & a, & b, & c, & d};
int f(int x)
{
  int __retres;
  if (x < 0) {
    __retres = x;
    goto return_label;
  }
  else 
    if (x > 4) {
      __retres = x;
      goto return_label;
    }
  (*(p[x]))();
  if (__fc_exn.exn_uncaught == 1) 
    switch (__fc_exn.exn_kind) {
      case __fc_exn_kind___fc_S_Z1B: goto __fc_S_Z1B_2;
      case __fc_exn_kind___fc_S_Z1C: goto __fc_S_Z1C_4;
      case __fc_exn_kind___fc_S_Z1D: goto __fc_S_Z1D_3;
      default: {
                 __retres = 0;
                 goto return_label;
               }
    }
  if (0) {
    struct C c;
    if (0) {
      struct C c_0;
      __fc_S_Z1C_4: c_0 = __fc_exn.exn_obj.__fc_S_Z1C;
      c = c_0;
      goto __fc_S_Z1C;
    }
    if (0) {
      struct D c_1;
      __fc_S_Z1D_3: c_1 = __fc_exn.exn_obj.__fc_S_Z1D;
      c = c_1._frama_c__Z1C;
      goto __fc_S_Z1C;
    }
    __fc_S_Z1C: __fc_exn.exn_uncaught = 0;
    __retres = c._frama_c__Z1A.x;
    goto return_label;
  }
  if (0) {
    struct B b;
    if (0) {
      struct B b_0;
      __fc_S_Z1B_2: b_0 = __fc_exn.exn_obj.__fc_S_Z1B;
      b = b_0;
      goto __fc_S_Z1B;
    }
    if (0) {
      struct D b_1;
      __fc_S_Z1D_1: b_1 = __fc_exn.exn_obj.__fc_S_Z1D;
      b = b_1._frama_c__Z1B;
      goto __fc_S_Z1B;
    }
    __fc_S_Z1B: __fc_exn.exn_uncaught = 0;
    __retres = - b._frama_c__Z1A.x;
    goto return_label;
  }
  __retres = 10;
  return_label: return __retres;
}

int main(int c, char **v)
{
  int __retres;
  if (c < 0) {
    __retres = c;
    goto return_label;
  }
  else 
    if (c > 4) {
      __retres = c;
      goto return_label;
    }
  {
    int y = f(c);
    if (__fc_exn.exn_uncaught == 1) 
      switch (__fc_exn.exn_kind) case __fc_exn_kind___fc_S_Z1A:
                                 goto __fc_S_Z1A_3;
    __retres = y + 100;
    goto return_label;
    if (0) {
      struct A a;
      if (0) {
        struct A a_0;
        __fc_S_Z1A_3: a_0 = __fc_exn.exn_obj.__fc_S_Z1A;
        a = a_0;
        goto __fc_S_Z1A;
      }
      if (0) {
        struct B a_1;
        __fc_S_Z1B_2: a_1 = __fc_exn.exn_obj.__fc_S_Z1B;
        a = a_1._frama_c__Z1A;
        goto __fc_S_Z1A;
      }
      if (0) {
        struct C a_2;
        __fc_S_Z1C_1: a_2 = __fc_exn.exn_obj.__fc_S_Z1C;
        a = a_2._frama_c__Z1A;
        goto __fc_S_Z1A;
      }
      __fc_S_Z1A: __fc_exn.exn_uncaught = 0;
      __retres = a.x + 10;
      goto return_label;
    }
  }
  return_label: return __retres;
}


