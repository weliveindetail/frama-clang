[kernel] Parsing tests/exn/integer_exn.cpp (external front-end)
Now output intermediate result
/* Generated by Frama-C */
enum foo {
    BAR = 2U
};
enum __fc_exn_enum {
    __fc_exn_kind___fc_E_Z3foo = 3,
    __fc_exn_kind___fc_pE_Z3foo = 2,
    __fc_exn_kind___fc_pi = 1,
    __fc_exn_kind___fc_i = 0
};
union __fc_exn_union {
   enum foo __fc_E_Z3foo ;
   enum foo *__fc_pE_Z3foo ;
   int *__fc_pi ;
   int __fc_i ;
};
struct __fc_exn_struct {
   int exn_uncaught ;
   enum __fc_exn_enum exn_kind ;
   union __fc_exn_union exn_obj ;
};
struct __fc_exn_struct __fc_exn =
  {.exn_uncaught = 0, .exn_kind = 0, .exn_obj = {.__fc_E_Z3foo = 0}};
int x;
enum foo y = (enum foo)BAR;
void throw_foo(void)
{
  __fc_exn.exn_uncaught = 1;
  __fc_exn.exn_kind = __fc_exn_kind___fc_E_Z3foo;
  __fc_exn.exn_obj.__fc_E_Z3foo = (enum foo)BAR;
  goto __ret_label;
  __ret_label: return;
}

void throw_2(void)
{
  __fc_exn.exn_uncaught = 1;
  __fc_exn.exn_kind = __fc_exn_kind___fc_i;
  __fc_exn.exn_obj.__fc_i = 2;
  goto __ret_label;
  __ret_label: return;
}

void throw_foop(void)
{
  __fc_exn.exn_uncaught = 1;
  __fc_exn.exn_kind = __fc_exn_kind___fc_pE_Z3foo;
  __fc_exn.exn_obj.__fc_pE_Z3foo = & y;
  goto __ret_label;
  __ret_label: return;
}

void throw_2p(void)
{
  __fc_exn.exn_uncaught = 1;
  __fc_exn.exn_kind = __fc_exn_kind___fc_pi;
  __fc_exn.exn_obj.__fc_pi = & x;
  goto __ret_label;
  __ret_label: return;
}

int catch_exn1(void (*f)(void))
{
  int __retres;
  (*f)();
  if (__fc_exn.exn_uncaught == 1) 
    switch (__fc_exn.exn_kind) {
      case __fc_exn_kind___fc_i: goto __fc_i;
      case __fc_exn_kind___fc_pi: goto __fc_pi;
      case __fc_exn_kind___fc_pE_Z3foo: goto __fc_pE_Z3foo;
      case __fc_exn_kind___fc_E_Z3foo: goto __fc_E_Z3foo;
    }
  if (0) {
    enum foo x;
    __fc_E_Z3foo: __fc_exn.exn_uncaught = 0;
    x = __fc_exn.exn_obj.__fc_E_Z3foo;
    __retres = 1;
    goto return_label;
  }
  if (0) {
    int x_0;
    __fc_i: __fc_exn.exn_uncaught = 0;
    x_0 = __fc_exn.exn_obj.__fc_i;
    __retres = 0;
    goto return_label;
  }
  if (0) {
    int *x_1;
    __fc_pi: __fc_exn.exn_uncaught = 0;
    x_1 = __fc_exn.exn_obj.__fc_pi;
    __retres = 2;
    goto return_label;
  }
  if (0) {
    enum foo *x_2;
    __fc_pE_Z3foo: __fc_exn.exn_uncaught = 0;
    x_2 = __fc_exn.exn_obj.__fc_pE_Z3foo;
    __retres = 3;
    goto return_label;
  }
  if (0) {
    catch_all: __fc_exn.exn_uncaught = 0;
    __retres = 4;
    goto return_label;
  }
  __retres = 5;
  return_label: return __retres;
}

int catch_exn2(void (*f)(void))
{
  int __retres;
  (*f)();
  if (__fc_exn.exn_uncaught == 1) 
    switch (__fc_exn.exn_kind) {
      case __fc_exn_kind___fc_i: goto __fc_i;
      case __fc_exn_kind___fc_pi: goto __fc_pi;
      case __fc_exn_kind___fc_pE_Z3foo: goto __fc_pE_Z3foo;
      case __fc_exn_kind___fc_E_Z3foo: goto __fc_E_Z3foo;
    }
  if (0) {
    int x;
    __fc_i: __fc_exn.exn_uncaught = 0;
    x = __fc_exn.exn_obj.__fc_i;
    __retres = 0;
    goto return_label;
  }
  if (0) {
    enum foo x_0;
    __fc_E_Z3foo: __fc_exn.exn_uncaught = 0;
    x_0 = __fc_exn.exn_obj.__fc_E_Z3foo;
    __retres = 1;
    goto return_label;
  }
  if (0) {
    int *x_1;
    __fc_pi: __fc_exn.exn_uncaught = 0;
    x_1 = __fc_exn.exn_obj.__fc_pi;
    __retres = 2;
    goto return_label;
  }
  if (0) {
    enum foo *x_2;
    __fc_pE_Z3foo: __fc_exn.exn_uncaught = 0;
    x_2 = __fc_exn.exn_obj.__fc_pE_Z3foo;
    __retres = 3;
    goto return_label;
  }
  if (0) {
    catch_all: __fc_exn.exn_uncaught = 0;
    __retres = 4;
    goto return_label;
  }
  __retres = 5;
  return_label: return __retres;
}

int main(void)
{
  int x;
  int y;
  int z;
  int t;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  x = catch_exn1(& throw_foo);
  y = catch_exn1(& throw_2);
  z = catch_exn1(& throw_foop);
  t = catch_exn1(& throw_2p);
  tmp = catch_exn2(& throw_foo);
  x += tmp;
  tmp_0 = catch_exn2(& throw_2);
  y += tmp_0;
  tmp_1 = catch_exn2(& throw_foop);
  z += tmp_1;
  tmp_2 = catch_exn2(& throw_2p);
  t += tmp_2;
  return t;
}


